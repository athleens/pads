#ifdef _USE_PROTO
#pragma prototyped
#endif
/*
 * WARNING: GENERATED FILE.  Do not edit this file, edit /Users/kfisher/pads/padsc/libpads/pads.c instead. 
 */

#ifndef __PADS_ACC_MACROS_GEN_H__
#define __PADS_ACC_MACROS_GEN_H__

/*
 * Macros that help implement accum functions
 * 
 * Kathleen Fisher, Robert Gruber
 * AT&T Labs Research
 */

#include "pads-config.h"

#define PDCI_INT_ACCUM_GEN(int_type, int_descr, num_bytes, fmt, mfmt, fold_test) \
 \
/* \
 * Order set comparison function: only used at the end to rehash \
 * the (formerly unordered) set.  Since same val only occurs \
 * once, ptr equivalence produces key equivalence. \
 *   different keys: sort keys by cnt field, break tie with vals \
 */ \
int \
int_type ## _dt_elt_oset_cmp(Dt_t *dt, int_type ## _dt_key_t *a, int_type ## _dt_key_t *b, Dtdisc_t *disc) \
{ \
  NoP(dt); \
  NoP(disc); \
  if (a == b) { /* same key */ \
    return 0; \
  } \
  if (a->cnt == b->cnt) { /* same count, do val comparison */ \
    return (a->val < b->val) ? -1 : 1; \
  } \
  /* different counts */ \
  return (a->cnt > b->cnt) ? -1 : 1; \
} \
 \
/* \
 * Unordered set comparison function: all that matters is val equality \
 * (0 => equal, 1 => not equal) \
 */ \
int \
int_type ## _dt_elt_set_cmp(Dt_t *dt, int_type ## _dt_key_t *a, int_type ## _dt_key_t *b, Dtdisc_t *disc) \
{ \
  NoP(dt); \
  NoP(disc); \
  if (a->val == b->val) { \
    return 0; \
  } \
  return 1; \
} \
 \
void* \
int_type ## _dt_elt_make(Dt_t *dt, int_type ## _dt_elt_t *a, Dtdisc_t *disc) \
{ \
  int_type ## _dt_elt_t *b; \
  if ((b = oldof(0, int_type ## _dt_elt_t, 1, 0))) { \
    b->key.val  = a->key.val; \
    b->key.cnt  = a->key.cnt; \
  } \
  return b; \
} \
 \
void \
int_type ## _dt_elt_free(Dt_t *dt, int_type ## _dt_elt_t *a, Dtdisc_t *disc) \
{ \
  free(a); \
} \
 \
static Dtdisc_t int_type ## _acc_dt_set_disc = { \
  DTOFFSET(int_type ## _dt_elt_t, key),     /* key     */ \
  num_bytes,                                /* size    */ \
  DTOFFSET(int_type ## _dt_elt_t, link),    /* link    */ \
  (Dtmake_f)int_type ## _dt_elt_make,       /* makef   */ \
  (Dtfree_f)int_type ## _dt_elt_free,       /* freef   */ \
  (Dtcompar_f)int_type ## _dt_elt_set_cmp,  /* comparf */ \
  NiL,                                      /* hashf   */ \
  NiL,                                      /* memoryf */ \
  NiL                                       /* eventf  */ \
}; \
 \
static Dtdisc_t int_type ## _acc_dt_oset_disc = { \
  DTOFFSET(int_type ## _dt_elt_t, key),     /* key     */ \
  num_bytes,                                /* size    */ \
  DTOFFSET(int_type ## _dt_elt_t, link),    /* link    */ \
  (Dtmake_f)int_type ## _dt_elt_make,       /* makef   */ \
  (Dtfree_f)int_type ## _dt_elt_free,       /* freef   */ \
  (Dtcompar_f)int_type ## _dt_elt_oset_cmp, /* comparf */ \
  NiL,                                      /* hashf   */ \
  NiL,                                      /* memoryf */ \
  NiL                                       /* eventf  */ \
}; \
 \
Perror_t \
int_type ## _acc_init(P_t *pads, int_type ## _acc *a) \
{ \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(int_type) "_acc_init", a); \
  memset((void*)a, 0, sizeof(*a)); \
  if (!(a->dict = dtopen(&int_type ## _acc_dt_set_disc, Dtset))) { \
    return P_ERR; \
  } \
  a->max2track  = pads->disc->acc_max2track; \
  a->max2rep    = pads->disc->acc_max2rep; \
  a->pcnt2rep   = pads->disc->acc_pcnt2rep; \
  return P_OK; \
} \
 \
Perror_t \
int_type ## _acc_reset(P_t *pads, int_type ## _acc *a) \
{ \
  Dt_t        *dict; \
 \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(int_type) "_acc_reset", a); \
  if (!(dict = a->dict)) { \
    return P_ERR; \
  } \
  memset((void*)a, 0, sizeof(*a)); \
  dtclear(dict); \
  a->dict = dict; \
  return P_OK; \
} \
 \
Perror_t \
int_type ## _acc_cleanup(P_t *pads, int_type ## _acc *a) \
{ \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(int_type) "_acc_cleanup", a); \
  if (a->dict) { \
    dtclose(a->dict); \
    a->dict = 0; \
  } \
  return P_OK; \
} \
 \
void \
int_type ## _acc_fold_psum(int_type ## _acc *a) { \
  Pfloat64 pavg, navg; \
  Puint64 recent = a->good - a->fold; \
  if (recent == 0) { \
    return; \
  } \
  pavg = a->psum / (Pfloat64)recent; \
  navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good; \
  /* could test for change between a->avg and navg */ \
  a->avg = navg; \
  a->psum = 0; \
  a->fold += recent; \
} \
 \
Pfloat64 \
int_type ## _acc_avg(P_t *pads, int_type ## _acc *a) { \
  int_type ## _acc_fold_psum(a); \
  return a->avg; \
} \
 \
int_type \
int_type ## _acc_ravg(P_t *pads, int_type ## _acc *a) { \
  int_type res; \
  int_type ## _acc_fold_psum(a); \
  if (a->avg >= 0) { \
    res = (a->avg + 0.5); /* truncate( avg + 0.5) */  \
  } else { \
    res = (a->avg - 0.5); /* truncate( avg - 0.5) */  \
  } \
  return res; \
} \
 \
Perror_t \
int_type ## _acc_add(P_t *pads, int_type ## _acc *a, const Pbase_pd *pd, const int_type *val) \
{ \
  int_type               v; \
  int_type ## _dt_elt_t  insert_elt; \
  int_type ## _dt_key_t  lookup_key; \
  int_type ## _dt_elt_t  *tmp1; \
  PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(int_type) "_acc_add", a, pd, val); \
  v = (*val); \
  if (!a->dict) { \
    return P_ERR; \
  } \
  if (pd->errCode != P_NO_ERR) { \
    (a->bad)++; \
    return P_OK; \
  } \
  if (fold_test(v, a->psum)) { \
    int_type ## _acc_fold_psum(a); \
  } \
  a->psum += v; \
  (a->good)++; \
  if (a->good == 1) { \
    a->min = a->max = v; \
  } else if (v < a->min) { \
    a->min = v; \
  } else if (v > a->max) { \
    a->max = v; \
  } \
  if (v == 0 || dtsize(a->dict) < a->max2track) { \
    insert_elt.key.val = v; \
    insert_elt.key.cnt = 0; \
    if (!(tmp1 = dtinsert(a->dict, &insert_elt))) { \
      P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **"); \
      return P_ERR; \
    } \
    (tmp1->key.cnt)++; \
    (a->tracked)++; \
  } else { \
    lookup_key.val = v; \
    lookup_key.cnt = 0; \
    if ((tmp1 = dtmatch(a->dict, &lookup_key))) { \
      (tmp1->key.cnt)++; \
      (a->tracked)++; \
    } \
  } \
  return P_OK; \
} \
 \
Perror_t \
int_type ## _acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, \
			   int_type ## _acc *a) \
{ \
  int                    i, sz, rp; \
  Puint64                cnt_sum; \
  Pfloat64               cnt_sum_pcnt; \
  Pfloat64               bad_pcnt; \
  Pfloat64               track_pcnt; \
  Pfloat64               elt_pcnt; \
  Void_t                *velt; \
  int_type ## _dt_elt_t *elt; \
 \
  P_TRACE(pads->disc, PDCI_MacroArg2String(int_type) "_acc_report2io called" ); \
  if (!prefix || *prefix == 0) { \
    prefix = "<top>"; \
  } \
  if (!what) { \
    what = int_descr; \
  } \
  PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0); \
  int_type ## _acc_fold_psum(a); \
  sz = dtsize(a->dict); \
  rp = (sz < a->max2rep) ? sz : a->max2rep; \
  if (sz == 0) { /* no values accumulated */ \
    sfprintf(outstr, "(No %s values.)\n", what); \
    return P_OK; \
  } \
  if (sz == 1 && a->bad == 0) { \
    elt = (int_type ## _dt_elt_t*)dtfirst(a->dict); \
    sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10" fmt "\n", \
	     a->good, what, elt->key.val); \
    dtnext(a->dict, 0); /* discard any iterator state */ \
    return P_OK; \
  } \
  if (a->good == 0) { \
    bad_pcnt = (a->bad == 0) ? 0.0 : 100.0; \
  } else { \
    bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad)); \
  } \
  sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", \
	   a->good, a->bad, bad_pcnt); \
  if (a->good == 0) { \
    sfprintf(outstr, "(No good %s values.)\n", what); \
    return P_OK; \
  } \
  /* check for 100% identical values */ \
  if (sz == 1) { \
    elt = (int_type ## _dt_elt_t*)dtfirst(a->dict); \
    sfprintf(outstr, "For good %s values, 100 pcnt identical: %10" fmt "\n", \
	     what, elt->key.val); \
    dtnext(a->dict, 0); /* discard any iterator state */ \
    return P_OK; \
  } \
  dtdisc(a->dict,   &int_type ## _acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */ \
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */ \
  sfprintf(outstr, "  Characterizing %s values:  min %" mfmt, what, a->min); \
  sfprintf(outstr, " max %" mfmt, a->max); \
  sfprintf(outstr, " avg %.3I8f\n", a->avg); \
  sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz); \
  if (sz == a->max2track && a->good > a->tracked) { \
    track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); \
    sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt); \
  } \
  for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict); \
       velt && i < a->max2rep; \
       velt = dtnext(a->dict, velt), i++) { \
    if (cnt_sum_pcnt >= a->pcnt2rep) { \
      sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", \
	       rp-i, rp, a->pcnt2rep); \
      break; \
    } \
    elt = (int_type ## _dt_elt_t*)velt; \
    elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good); \
    sfprintf(outstr, "        val: %10" fmt, elt->key.val); \
    sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt); \
    cnt_sum += elt->key.cnt; \
    cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good); \
  } \
  dtnext(a->dict, 0); /* discard any iterator state */ \
  sfprintf(outstr,   ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n"); \
  sfprintf(outstr,   "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", \
	   cnt_sum, cnt_sum_pcnt); \
  /* revert to unordered set in case more inserts will occur after this report */ \
  dtmethod(a->dict, Dtset); /* change to unordered set */ \
  dtdisc(a->dict,   &int_type ## _acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */ \
  return P_OK; \
} \
 \
Perror_t \
int_type ## _acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, int_type ## _acc *a) \
{ \
  int                    i, sz, rp; \
  Pfloat64               track_pcnt; \
  Void_t                *velt; \
  int_type ## _dt_elt_t *elt; \
 \
  P_TRACE(pads->disc, PDCI_MacroArg2String(int_type) "_acc_report2xml_io called" ); \
  int_type ## _acc_fold_psum(a); \
  sz = dtsize(a->dict); \
  rp = (sz < a->max2rep) ? sz : a->max2rep; \
  if (sz == 0) { /* no values accumulated */ \
    PDCI_indent(outstr, nst); \
    sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(int_type), PDCI_MacroArg2String(int_type)); \
    return P_OK; \
  } \
  PDCI_indent(outstr, nst++); \
  sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(int_type)); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<good>%" mfmt, a->good); \
  sfprintf(outstr, "</good>\n"); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<bad>%" mfmt, a->bad); \
  sfprintf(outstr, "</bad>\n"); \
 \
  dtdisc(a->dict,   &int_type ## _acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */ \
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */ \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<min>%" mfmt, a->min); \
  sfprintf(outstr, "</min>\n"); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<max>%" mfmt, a->max); \
  sfprintf(outstr, "</max>\n"); \
  if (sz!=0){ \
     PDCI_indent(outstr, nst++); \
     sfprintf(outstr, "<distribution>\n"); \
     PDCI_indent(outstr, nst); \
     sfprintf(outstr, "<top>%d</top>", rp); \
     sfprintf(outstr, "<distinct>%d</distinct>\n", sz); \
     if (sz == a->max2track && a->good > a->tracked) { \
       track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); \
       PDCI_indent(outstr, nst); \
       sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); \
     }; \
   \
     for (i = 0, velt = dtfirst(a->dict); \
          velt && i < a->max2rep; \
          velt = dtnext(a->dict, velt), i++) { \
            elt = (int_type ## _dt_elt_t*)velt; \
            PDCI_indent(outstr, nst); \
            sfprintf(outstr, "<item>"); \
            sfprintf(outstr, "<val>%" fmt, elt->key.val); \
            sfprintf(outstr, "</val>"); \
            sfprintf(outstr, "<count>%llu</count>", elt->key.cnt); \
            sfprintf(outstr, "</item>\n"); \
     } \
     PDCI_indent(outstr, --nst); \
     sfprintf(outstr, "</distribution>\n"); \
  } \
  PDCI_indent(outstr, --nst); \
  sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(int_type)); \
 \
  dtnext(a->dict, 0); /* discard any iterator state */ \
  /* revert to unordered set in case more inserts will occur after this report */ \
  dtmethod(a->dict, Dtset); /* change to unordered set */ \
  dtdisc(a->dict,   &int_type ## _acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */ \
  return P_OK; \
} \
 \
 \
Perror_t \
int_type ## _acc_report(P_t *pads, const char *prefix, const char *what, int nst, \
			int_type ## _acc *a) \
{ \
  Sfio_t *tmpstr; \
  Perror_t res; \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(int_type) "_acc_report", a); \
 \
  if (!pads->disc->error_fn) { \
    return P_OK; \
  } \
  if (!(tmpstr = sfstropen ())) {  \
    return P_ERR; \
  } \
  res = int_type ## _acc_report2io(pads, tmpstr, prefix, what, nst, a); \
  if (res == P_OK) { \
    pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr)); \
  } \
  sfstrclose (tmpstr); \
  return res; \
} \

#define PDCI_INT_ACCUM_MAP_REPORT_GEN(int_type, int_descr, fmt, mfmt) \
Perror_t \
int_type ## _acc_map_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what,  int nst, \
			       int_type ## _map_fn fn, int_type ## _acc *a) \
{ \
  size_t                 pad; \
  const char            *mapped_min; \
  const char            *mapped_max; \
  const char            *mapped_val; \
  int                    i, sz, rp, tmp; \
  Puint64                cnt_sum; \
  Pfloat64               cnt_sum_pcnt; \
  Pfloat64               bad_pcnt; \
  Pfloat64               track_pcnt; \
  Pfloat64               elt_pcnt; \
  Void_t                *velt; \
  int_type ## _dt_elt_t *elt; \
 \
  P_TRACE(pads->disc, PDCI_MacroArg2String(int_type) "_acc_map_report2io called" ); \
  if (!prefix || *prefix == 0) { \
    prefix = "<top>"; \
  } \
  if (!what) { \
    what = int_descr; \
  } \
  PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0); \
  int_type ## _acc_fold_psum(a); \
  sz = dtsize(a->dict); \
  rp = (sz < a->max2rep) ? sz : a->max2rep; \
  if (sz == 0) { /* no values accumulated */ \
    sfprintf(outstr, "(No %s values.)\n", what); \
    return P_OK; \
  } \
  if (sz == 1 && a->bad == 0) { \
    elt = (int_type ## _dt_elt_t*)dtfirst(a->dict); \
    mapped_val = fn(elt->key.val); \
    sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %s (%5" fmt ")\n", \
	     a->good, what, mapped_val, elt->key.val); \
    dtnext(a->dict, 0); /* discard any iterator state */ \
    return P_OK; \
  } \
  if (a->good == 0) { \
    bad_pcnt = (a->bad == 0) ? 0.0 : 100.0; \
  } else { \
    bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad)); \
  } \
  sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", \
	   a->good, a->bad, bad_pcnt); \
  if (a->good == 0) { \
    sfprintf(outstr, "(No good %s values.)\n", what); \
    return P_OK; \
  } \
  /* check for 100% identical values */ \
  if (sz == 1) { \
    elt = (int_type ## _dt_elt_t*)dtfirst(a->dict); \
    mapped_val = fn(elt->key.val); \
    sfprintf(outstr, "For good %s values, 100 pcnt identical: %s (%5" fmt ")\n", \
	     what, mapped_val, elt->key.val); \
    dtnext(a->dict, 0); /* discard any iterator state */ \
    return P_OK; \
  } \
  dtdisc(a->dict,   &int_type ## _acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */ \
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */ \
  mapped_min = fn(a->min); \
  mapped_max = fn(a->max); \
  sfprintf(outstr, "  Characterizing %s values:  min %s (%5" mfmt, what, mapped_min, a->min); \
  sfprintf(outstr, ")  max %s (%5" mfmt, mapped_max, a->max); \
  sfprintf(outstr, ")\n"); \
  sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz); \
  if (sz == a->max2track && a->good > a->tracked) { \
    track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); \
    sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt); \
  } \
  sz = tmp = 0; \
  for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { \
    elt = (int_type ## _dt_elt_t*)velt; \
    sz = strlen(fn(elt->key.val)); \
    if (sz > tmp) { \
      tmp = sz;  \
    } \
  } \
  dtnext(a->dict, 0); /* discard any iterator state */ \
  for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict); \
       velt && i < a->max2rep; \
       velt = dtnext(a->dict, velt), i++) { \
    if (cnt_sum_pcnt >= a->pcnt2rep) { \
      sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", \
	       rp-i, rp, a->pcnt2rep); \
      break; \
    } \
    dtnext(a->dict, 0); /* discard any iterator state */ \
    elt = (int_type ## _dt_elt_t*)velt; \
    elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good); \
    mapped_val = fn(elt->key.val); \
    sfprintf(outstr, "        val: %s (%5" fmt, mapped_val, elt->key.val); \
    sfprintf(outstr, ") "); \
    pad = tmp-strlen(mapped_val); \
    sfprintf(outstr, "%-.*s", pad, PDCI_spaces); \
    sfprintf(outstr, "  count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt); \
    cnt_sum += elt->key.cnt; \
    cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good); \
  } \
  sfprintf(outstr,   "%-.*s", tmp, \
	   ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ."); \
  sfprintf(outstr,   " . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        SUMMING"); \
  sfprintf(outstr,   "%-.*s", tmp, PDCI_spaces); \
  sfprintf(outstr,   "         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt); \
  /* revert to unordered set in case more inserts will occur after this report */ \
  dtmethod(a->dict, Dtset); /* change to unordered set */ \
  dtdisc(a->dict,   &int_type ## _acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */ \
  return P_OK; \
} \
 \
Perror_t \
int_type ## _acc_map_report(P_t *pads, const char *prefix, const char *what, int nst, \
			    int_type ## _map_fn fn, int_type ## _acc *a) \
{ \
  Sfio_t *tmpstr; \
  Perror_t res; \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(int_type) "_acc_map_report", a); \
  if (!pads->disc->error_fn) { \
    return P_OK; \
  } \
  if (!(tmpstr = sfstropen ())) {  \
    return P_ERR; \
  } \
  res = int_type ## _acc_map_report2io(pads, tmpstr, prefix, what, nst, fn, a); \
  if (res == P_OK) { \
    pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr)); \
  } \
  sfstrclose (tmpstr); \
  return res; \
} \
 \
Perror_t \
int_type ## _acc_map_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, \
			           int_type ## _map_fn fn, int_type ## _acc *a) \
{ \
  const char            *mapped_min; \
  const char            *mapped_max; \
  const char            *mapped_val; \
  int                    i, sz, rp, tmp; \
  Pfloat64               track_pcnt; \
  Void_t                *velt; \
  int_type ## _dt_elt_t *elt; \
 \
  P_TRACE(pads->disc, PDCI_MacroArg2String(int_type) "_acc_map_report2xml_io called" ); \
  int_type ## _acc_fold_psum(a); \
  sz = dtsize(a->dict); \
  rp = (sz < a->max2rep) ? sz : a->max2rep; \
  if (sz == 0) { /* no values accumulated */ \
    return P_OK; \
  } \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<good>%" mfmt, a->good); \
  sfprintf(outstr, "</good>\n"); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<bad>%" mfmt, a->bad); \
  sfprintf(outstr, "</bad>\n"); \
 \
  dtdisc(a->dict,   &int_type ## _acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */ \
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */ \
 \
  mapped_min = fn(a->min); \
  mapped_max = fn(a->max); \
 \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<min>%s</min>\n", mapped_min); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<max>%s</max>\n", mapped_max); \
 \
  if (sz != 0) { \
     PDCI_indent(outstr, nst++); \
     sfprintf(outstr, "<distribution>\n"); \
     PDCI_indent(outstr, nst); \
     sfprintf(outstr, "<top>%d</top>", rp); \
     sfprintf(outstr, "<distinct>%d</distinct>\n", sz); \
     if (sz == a->max2track && a->good > a->tracked) { \
       track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); \
       PDCI_indent(outstr, nst); \
       sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); \
     } \
     sz = tmp = 0; \
     for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { \
       elt = (int_type ## _dt_elt_t*)velt; \
       sz = strlen(fn(elt->key.val)); \
       if (sz > tmp) { \
	 tmp = sz;  \
       } \
     } \
     dtnext(a->dict, 0); /* discard any iterator state */ \
    for (i = 0, velt = dtfirst(a->dict); \
	 velt && i < a->max2rep; \
	 velt = dtnext(a->dict, velt), i++) { \
      dtnext(a->dict, 0); /* discard any iterator state */ \
      elt = (int_type ## _dt_elt_t*)velt; \
      mapped_val = fn(elt->key.val); \
      PDCI_indent(outstr, nst); \
      sfprintf(outstr, "<item>"); \
      sfprintf(outstr, "<val>%s</val>", mapped_val); \
      sfprintf(outstr, "<count>%llu</count>", elt->key.cnt); \
      sfprintf(outstr, "</item>\n"); \
    } \
    nst--; \
    PDCI_indent(outstr, nst); \
    sfprintf(outstr, "</distribution>\n"); \
  } \
 \
  /* revert to unordered set in case more inserts will occur after this report */ \
  dtmethod(a->dict, Dtset); /* change to unordered set */ \
  dtdisc(a->dict,   &int_type ## _acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */ \
  return P_OK; \
} \
 \

#define PDCI_FPOINT_ACCUM_GEN(fpoint_type, fpoint_descr) \
 \
typedef struct fpoint_type ## _dt_key_s { \
  Pfloat64     val; \
  Puint64      cnt; \
} fpoint_type ## _dt_key_t; \
 \
typedef struct fpoint_type ## _dt_elt_s { \
  fpoint_type ## _dt_key_t key; \
  Dtlink_t link; \
} fpoint_type ## _dt_elt_t; \
 \
/* \
 * Order set comparison function: only used at the end to rehash \
 * the (formerly unordered) set.  Since same val only occurs \
 * once, ptr equivalence produces key equivalence. \
 *   different keys: sort keys by cnt field, break tie with vals \
 */ \
int \
fpoint_type ## _dt_elt_oset_cmp(Dt_t *dt, fpoint_type ## _dt_key_t *a, fpoint_type ## _dt_key_t *b, Dtdisc_t *disc) \
{ \
  NoP(dt); \
  NoP(disc); \
  if (a == b) { /* same key */ \
    return 0; \
  } \
  if (a->cnt == b->cnt) { /* same count, do val comparison */ \
    return (a->val < b->val) ? -1 : 1; \
  } \
  /* different counts */ \
  return (a->cnt > b->cnt) ? -1 : 1; \
} \
 \
/* \
 * Unordered set comparison function: all that matters is val equality \
 * (0 => equal, 1 => not equal) \
 */ \
int \
fpoint_type ## _dt_elt_set_cmp(Dt_t *dt, fpoint_type ## _dt_key_t *a, fpoint_type ## _dt_key_t *b, Dtdisc_t *disc) \
{ \
  NoP(dt); \
  NoP(disc); \
  if (a->val == b->val) { \
    return 0; \
  } \
  return 1; \
} \
 \
void* \
fpoint_type ## _dt_elt_make(Dt_t *dt, fpoint_type ## _dt_elt_t *a, Dtdisc_t *disc) \
{ \
  fpoint_type ## _dt_elt_t *b; \
  if ((b = oldof(0, fpoint_type ## _dt_elt_t, 1, 0))) { \
    b->key.val  = a->key.val; \
    b->key.cnt  = a->key.cnt; \
  } \
  return b; \
} \
 \
void \
fpoint_type ## _dt_elt_free(Dt_t *dt, fpoint_type ## _dt_elt_t *a, Dtdisc_t *disc) \
{ \
  free(a); \
} \
 \
static Dtdisc_t fpoint_type ## _acc_dt_set_disc = { \
  DTOFFSET(fpoint_type ## _dt_elt_t, key),     /* key     */ \
  sizeof(Pfloat64),                            /* size    */ \
  DTOFFSET(fpoint_type ## _dt_elt_t, link),    /* link    */ \
  (Dtmake_f)fpoint_type ## _dt_elt_make,       /* makef   */ \
  (Dtfree_f)fpoint_type ## _dt_elt_free,       /* freef   */ \
  (Dtcompar_f)fpoint_type ## _dt_elt_set_cmp,  /* comparf */ \
  NiL,                                         /* hashf   */ \
  NiL,                                         /* memoryf */ \
  NiL                                          /* eventf  */ \
}; \
 \
static Dtdisc_t fpoint_type ## _acc_dt_oset_disc = { \
  DTOFFSET(fpoint_type ## _dt_elt_t, key),     /* key     */ \
  sizeof(Pfloat64),                            /* size    */ \
  DTOFFSET(fpoint_type ## _dt_elt_t, link),    /* link    */ \
  (Dtmake_f)fpoint_type ## _dt_elt_make,       /* makef   */ \
  (Dtfree_f)fpoint_type ## _dt_elt_free,       /* freef   */ \
  (Dtcompar_f)fpoint_type ## _dt_elt_oset_cmp, /* comparf */ \
  NiL,                                         /* hashf   */ \
  NiL,                                         /* memoryf */ \
  NiL                                          /* eventf  */ \
}; \
 \
Perror_t \
fpoint_type ## _acc_init(P_t *pads, fpoint_type ## _acc *a) \
{ \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(fpoint_type) "_acc_init", a); \
  memset((void*)a, 0, sizeof(*a)); \
  if (!(a->dict = dtopen(&fpoint_type ## _acc_dt_set_disc, Dtset))) { \
    return P_ERR; \
  } \
  a->max2track  = pads->disc->acc_max2track; \
  a->max2rep    = pads->disc->acc_max2rep; \
  a->pcnt2rep   = pads->disc->acc_pcnt2rep; \
  return P_OK; \
} \
 \
Perror_t \
fpoint_type ## _acc_reset(P_t *pads, fpoint_type ## _acc *a) \
{ \
  Dt_t        *dict; \
 \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(fpoint_type) "_acc_reset", a); \
  if (!(dict = a->dict)) { \
    return P_ERR; \
  } \
  memset((void*)a, 0, sizeof(*a)); \
  dtclear(dict); \
  a->dict = dict; \
  return P_OK; \
} \
 \
Perror_t \
fpoint_type ## _acc_cleanup(P_t *pads, fpoint_type ## _acc *a) \
{ \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(fpoint_type) "_acc_cleanup", a); \
  if (a->dict) { \
    dtclose(a->dict); \
    a->dict = 0; \
  } \
  return P_OK; \
} \
 \
void \
fpoint_type ## _acc_fold_psum(fpoint_type ## _acc *a) { \
  Pfloat64 pavg, navg; \
  Puint64 recent = a->good - a->fold; \
  if (recent == 0) { \
    return; \
  } \
  pavg = a->psum / (Pfloat64)recent; \
  navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good; \
  /* could test for change between a->avg and navg */ \
  a->avg = navg; \
  a->psum = 0; \
  a->fold += recent; \
} \
 \
Pfloat64 \
fpoint_type ## _acc_avg(P_t *pads, fpoint_type ## _acc *a) { \
  fpoint_type ## _acc_fold_psum(a); \
  return a->avg; \
} \
 \
Perror_t \
fpoint_type ## _acc_add(P_t *pads, fpoint_type ## _acc *a, const Pbase_pd *pd, const fpoint_type *val) \
{ \
  Pfloat64                  v; \
  fpoint_type ## _dt_elt_t  insert_elt; \
  fpoint_type ## _dt_key_t  lookup_key; \
  fpoint_type ## _dt_elt_t  *tmp1; \
  PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(fpoint_type) "_acc_add", a, pd, val); \
  v = P_FPOINT2FLOAT64(*val); \
  if (!a->dict) { \
    return P_ERR; \
  } \
  if (pd->errCode != P_NO_ERR) { \
    (a->bad)++; \
    return P_OK; \
  } \
  if ( (v > 0 && a->psum > PDCI_LARGE_POS_DBL) || \
       (v < 0 && a->psum < PDCI_LARGE_NEG_DBL) ) { \
    fpoint_type ## _acc_fold_psum(a); \
  } \
  a->psum += v; \
  (a->good)++; \
  if (a->good == 1) { \
    a->min = a->max = v; \
  } else if (v < a->min) { \
    a->min = v; \
  } else if (v > a->max) { \
    a->max = v; \
  } \
  if (v == 0 || dtsize(a->dict) < a->max2track) { \
    insert_elt.key.val = v; \
    insert_elt.key.cnt = 0; \
    if (!(tmp1 = dtinsert(a->dict, &insert_elt))) { \
      P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **"); \
      return P_ERR; \
    } \
    (tmp1->key.cnt)++; \
    (a->tracked)++; \
  } else { \
    lookup_key.val = v; \
    lookup_key.cnt = 0; \
    if ((tmp1 = dtmatch(a->dict, &lookup_key))) { \
      (tmp1->key.cnt)++; \
      (a->tracked)++; \
    } \
  } \
  return P_OK; \
} \
 \
Perror_t \
fpoint_type ## _acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, \
			      fpoint_type ## _acc *a) \
{ \
  int                       i, sz, rp; \
  Puint64                   cnt_sum; \
  Pfloat64                  cnt_sum_pcnt; \
  Pfloat64                  bad_pcnt; \
  Pfloat64                  track_pcnt; \
  Pfloat64                  elt_pcnt; \
  Void_t                   *velt; \
  fpoint_type ## _dt_elt_t *elt; \
 \
  P_TRACE(pads->disc, PDCI_MacroArg2String(fpoint_type) "_acc_report2io called" ); \
  if (!prefix || *prefix == 0) { \
    prefix = "<top>"; \
  } \
  if (!what) { \
    what = fpoint_descr; \
  } \
  PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0); \
  fpoint_type ## _acc_fold_psum(a); \
  sz = dtsize(a->dict); \
  rp = (sz < a->max2rep) ? sz : a->max2rep; \
  if (sz == 0) { /* no values accumulated */ \
    sfprintf(outstr, "(No %s values.)\n", what); \
    return P_OK; \
  } \
  if (sz == 1 && a->bad == 0) { \
    elt = (fpoint_type ## _dt_elt_t*)dtfirst(a->dict); \
    sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10.5I8f\n", \
	     a->good, what, elt->key.val); \
    dtnext(a->dict, 0); /* discard any iterator state */ \
    return P_OK; \
  } \
  if (a->good == 0) { \
    bad_pcnt = (a->bad == 0) ? 0.0 : 100.0; \
  } else { \
    bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad)); \
  } \
  sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", \
	   a->good, a->bad, bad_pcnt); \
  if (a->good == 0) { \
    sfprintf(outstr, "(No good %s values.)\n", what); \
    return P_OK; \
  } \
  /* check for 100% identical values */ \
  if (sz == 1) { \
    elt = (fpoint_type ## _dt_elt_t*)dtfirst(a->dict); \
    sfprintf(outstr, "For good %s values, 100 pcnt identical: %10.5I8f\n", \
	     what, elt->key.val); \
    dtnext(a->dict, 0); /* discard any iterator state */ \
    return P_OK; \
  } \
  dtdisc(a->dict,   &fpoint_type ## _acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */ \
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */ \
  sfprintf(outstr, "  Characterizing %s values:  min %.5I8f", what, a->min); \
  sfprintf(outstr, " max %.5I8f", a->max); \
  sfprintf(outstr, " avg %.3I8f\n", a->avg); \
  sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz); \
  if (sz == a->max2track && a->good > a->tracked) { \
    track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); \
    sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt); \
  } \
  for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict); \
       velt && i < a->max2rep; \
       velt = dtnext(a->dict, velt), i++) { \
    if (cnt_sum_pcnt >= a->pcnt2rep) { \
      sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", \
	       rp-i, rp, a->pcnt2rep); \
      break; \
    } \
    elt = (fpoint_type ## _dt_elt_t*)velt; \
    elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good); \
    sfprintf(outstr, "        val: %10.5I8f", elt->key.val); \
    sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt); \
    cnt_sum += elt->key.cnt; \
    cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good); \
  } \
  dtnext(a->dict, 0); /* discard any iterator state */ \
  sfprintf(outstr,   ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n"); \
  sfprintf(outstr,   "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", \
	   cnt_sum, cnt_sum_pcnt); \
  /* revert to unordered set in case more inserts will occur after this report */ \
  dtmethod(a->dict, Dtset); /* change to unordered set */ \
  dtdisc(a->dict,   &fpoint_type ## _acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */ \
  return P_OK; \
} \
 \
Perror_t \
fpoint_type ## _acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst,fpoint_type ## _acc *a) \
{ \
  int                       i, sz, rp; \
  Pfloat64                  track_pcnt; \
  Void_t                   *velt; \
  fpoint_type ## _dt_elt_t *elt; \
 \
  P_TRACE(pads->disc, PDCI_MacroArg2String(fpoint_type) "_acc_report2xml_io called" ); \
  fpoint_type ## _acc_fold_psum(a); \
  sz = dtsize(a->dict); \
  rp = (sz < a->max2rep) ? sz : a->max2rep; \
  if (sz == 0) { /* no values accumulated */ \
    PDCI_indent(outstr, nst); \
    sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(fpoint_type), PDCI_MacroArg2String(fpoint_type)); \
    return P_OK; \
  } \
  PDCI_indent(outstr, nst++); \
  sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(fpoint_type)); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<good>%llu", a->good); \
  sfprintf(outstr, "</good>\n"); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<bad>%llu", a->bad); \
  sfprintf(outstr, "</bad>\n"); \
 \
  dtdisc(a->dict,   &fpoint_type ## _acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */ \
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */ \
 \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<min>%.5I8f", a->min); \
  sfprintf(outstr, "</min>\n"); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<max>%.5I8f", a->max); \
  sfprintf(outstr, "</max>\n"); \
 \
  if (sz!=0){ \
     PDCI_indent(outstr, nst++); \
     sfprintf(outstr, "<distribution>\n"); \
     PDCI_indent(outstr, nst); \
     sfprintf(outstr, "<top>%d</top>", rp); \
     sfprintf(outstr, "<distinct>%d</distinct>\n", sz); \
     if (sz == a->max2track && a->good > a->tracked) { \
       track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); \
       PDCI_indent(outstr, nst); \
       sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); \
     }; \
 \
     for (i = 0, velt = dtfirst(a->dict); \
	  velt && i < a->max2rep; \
	  velt = dtnext(a->dict, velt), i++) { \
            elt = (fpoint_type ## _dt_elt_t*)velt; \
            PDCI_indent(outstr, nst); \
            sfprintf(outstr, "<item>"); \
            sfprintf(outstr, "<val>%.5I8f", elt->key.val); \
            sfprintf(outstr, "</val>"); \
            sfprintf(outstr, "<count>%llu</count>", elt->key.cnt); \
            sfprintf(outstr, "</item>\n"); \
     } \
     PDCI_indent(outstr, --nst); \
     sfprintf(outstr, "</distribution>\n"); \
  } \
  PDCI_indent(outstr, --nst); \
  sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(fpoint_type)); \
 \
  dtnext(a->dict, 0); /* discard any iterator state */ \
  /* revert to unordered set in case more inserts will occur after this report */ \
  dtmethod(a->dict, Dtset); /* change to unordered set */ \
  dtdisc(a->dict,   &fpoint_type ## _acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */ \
  return P_OK; \
} \
 \
 \
Perror_t \
fpoint_type ## _acc_report(P_t *pads, const char *prefix, const char *what, int nst, \
			   fpoint_type ## _acc *a) \
{ \
  Sfio_t *tmpstr; \
  Perror_t res; \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(fpoint_type) "_acc_report", a); \
  if (!pads->disc->error_fn) { \
    return P_OK; \
  } \
  if (!(tmpstr = sfstropen ())) {  \
    return P_ERR; \
  } \
  res = fpoint_type ## _acc_report2io(pads, tmpstr, prefix, what, nst, a); \
  if (res == P_OK) { \
    pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr)); \
  } \
  sfstrclose (tmpstr); \
  return res; \
} \

#define PDCI_FLOAT_ACCUM_GEN(float_type, float_descr) \
 \
typedef struct float_type ## _dt_key_s { \
  Pfloat64     val; \
  Puint64      cnt; \
} float_type ## _dt_key_t; \
 \
typedef struct float_type ## _dt_elt_s { \
  float_type ## _dt_key_t key; \
  Dtlink_t link; \
} float_type ## _dt_elt_t; \
 \
/* \
 * Order set comparison function: only used at the end to rehash \
 * the (formerly unordered) set.  Since same val only occurs \
 * once, ptr equivalence produces key equivalence. \
 *   different keys: sort keys by cnt field, break tie with vals \
 */ \
int \
float_type ## _dt_elt_oset_cmp(Dt_t *dt, float_type ## _dt_key_t *a, float_type ## _dt_key_t *b, Dtdisc_t *disc) \
{ \
  NoP(dt); \
  NoP(disc); \
  if (a == b) { /* same key */ \
    return 0; \
  } \
  if (a->cnt == b->cnt) { /* same count, do val comparison */ \
    return (a->val < b->val) ? -1 : 1; \
  } \
  /* different counts */ \
  return (a->cnt > b->cnt) ? -1 : 1; \
} \
 \
/* \
 * Unordered set comparison function: all that matters is val equality \
 * (0 => equal, 1 => not equal) \
 */ \
int \
float_type ## _dt_elt_set_cmp(Dt_t *dt, float_type ## _dt_key_t *a, float_type ## _dt_key_t *b, Dtdisc_t *disc) \
{ \
  NoP(dt); \
  NoP(disc); \
  if (a->val == b->val) { \
    return 0; \
  } \
  return 1; \
} \
 \
void* \
float_type ## _dt_elt_make(Dt_t *dt, float_type ## _dt_elt_t *a, Dtdisc_t *disc) \
{ \
  float_type ## _dt_elt_t *b; \
  if ((b = oldof(0, float_type ## _dt_elt_t, 1, 0))) { \
    b->key.val  = a->key.val; \
    b->key.cnt  = a->key.cnt; \
  } \
  return b; \
} \
 \
void \
float_type ## _dt_elt_free(Dt_t *dt, float_type ## _dt_elt_t *a, Dtdisc_t *disc) \
{ \
  free(a); \
} \
 \
static Dtdisc_t float_type ## _acc_dt_set_disc = { \
  DTOFFSET(float_type ## _dt_elt_t, key),     /* key     */ \
  sizeof(Pfloat64),                           /* size    */ \
  DTOFFSET(float_type ## _dt_elt_t, link),    /* link    */ \
  (Dtmake_f)float_type ## _dt_elt_make,       /* makef   */ \
  (Dtfree_f)float_type ## _dt_elt_free,       /* freef   */ \
  (Dtcompar_f)float_type ## _dt_elt_set_cmp,  /* comparf */ \
  NiL,                                        /* hashf   */ \
  NiL,                                        /* memoryf */ \
  NiL                                         /* eventf  */ \
}; \
 \
static Dtdisc_t float_type ## _acc_dt_oset_disc = { \
  DTOFFSET(float_type ## _dt_elt_t, key),     /* key     */ \
  sizeof(Pfloat64),                           /* size    */ \
  DTOFFSET(float_type ## _dt_elt_t, link),    /* link    */ \
  (Dtmake_f)float_type ## _dt_elt_make,       /* makef   */ \
  (Dtfree_f)float_type ## _dt_elt_free,       /* freef   */ \
  (Dtcompar_f)float_type ## _dt_elt_oset_cmp, /* comparf */ \
  NiL,                                        /* hashf   */ \
  NiL,                                        /* memoryf */ \
  NiL                                         /* eventf  */ \
}; \
 \
Perror_t \
float_type ## _acc_init(P_t *pads, float_type ## _acc *a) \
{ \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(float_type) "_acc_init", a); \
  memset((void*)a, 0, sizeof(*a)); \
  if (!(a->dict = dtopen(&float_type ## _acc_dt_set_disc, Dtset))) { \
    return P_ERR; \
  } \
  a->max2track  = pads->disc->acc_max2track; \
  a->max2rep    = pads->disc->acc_max2rep; \
  a->pcnt2rep   = pads->disc->acc_pcnt2rep; \
  return P_OK; \
} \
 \
Perror_t \
float_type ## _acc_reset(P_t *pads, float_type ## _acc *a) \
{ \
  Dt_t        *dict; \
 \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(float_type) "_acc_reset", a); \
  if (!(dict = a->dict)) { \
    return P_ERR; \
  } \
  memset((void*)a, 0, sizeof(*a)); \
  dtclear(dict); \
  a->dict = dict; \
  return P_OK; \
} \
 \
Perror_t \
float_type ## _acc_cleanup(P_t *pads, float_type ## _acc *a) \
{ \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(float_type) "_acc_cleanup", a); \
  if (a->dict) { \
    dtclose(a->dict); \
    a->dict = 0; \
  } \
  return P_OK; \
} \
 \
void \
float_type ## _acc_fold_psum(float_type ## _acc *a) { \
  Pfloat64 pavg, navg; \
  Puint64 recent = a->good - a->fold; \
  if (recent == 0) { \
    return; \
  } \
  pavg = a->psum / (Pfloat64)recent; \
  navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good; \
  /* could test for change between a->avg and navg */ \
  a->avg = navg; \
  a->psum = 0; \
  a->fold += recent; \
} \
 \
Pfloat64 \
float_type ## _acc_avg(P_t *pads, float_type ## _acc *a) { \
  float_type ## _acc_fold_psum(a); \
  return a->avg; \
} \
 \
Perror_t \
float_type ## _acc_add(P_t *pads, float_type ## _acc *a, const Pbase_pd *pd, const float_type *val) \
{ \
  Pfloat64                 v; \
  float_type ## _dt_elt_t  insert_elt; \
  float_type ## _dt_key_t  lookup_key; \
  float_type ## _dt_elt_t  *tmp1; \
  PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(float_type) "_acc_add", a, pd, val); \
  v = (*val); \
  if (!a->dict) { \
    return P_ERR; \
  } \
  if (pd->errCode != P_NO_ERR) { \
    (a->bad)++; \
    return P_OK; \
  } \
  if ( (v > 0 && (v > PDCI_LARGE_POS_DBL || a->psum > PDCI_LARGE_POS_DBL)) || \
       (v < 0 && (v < PDCI_LARGE_NEG_DBL || a->psum < PDCI_LARGE_NEG_DBL)) ) { \
    float_type ## _acc_fold_psum(a); \
  } \
  a->psum += v; \
  (a->good)++; \
  if (a->good == 1) { \
    a->min = a->max = v; \
  } else if (v < a->min) { \
    a->min = v; \
  } else if (v > a->max) { \
    a->max = v; \
  } \
  if (v == 0 || dtsize(a->dict) < a->max2track) { \
    insert_elt.key.val = v; \
    insert_elt.key.cnt = 0; \
    if (!(tmp1 = dtinsert(a->dict, &insert_elt))) { \
      P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **"); \
      return P_ERR; \
    } \
    (tmp1->key.cnt)++; \
    (a->tracked)++; \
  } else { \
    lookup_key.val = v; \
    lookup_key.cnt = 0; \
    if ((tmp1 = dtmatch(a->dict, &lookup_key))) { \
      (tmp1->key.cnt)++; \
      (a->tracked)++; \
    } \
  } \
  return P_OK; \
} \
 \
Perror_t \
float_type ## _acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, \
			     float_type ## _acc *a) \
{ \
  int                      i, sz, rp; \
  Puint64                  cnt_sum; \
  Pfloat64                 cnt_sum_pcnt; \
  Pfloat64                 bad_pcnt; \
  Pfloat64                 track_pcnt; \
  Pfloat64                 elt_pcnt; \
  Void_t                  *velt; \
  float_type ## _dt_elt_t *elt; \
 \
  P_TRACE(pads->disc, PDCI_MacroArg2String(float_type) "_acc_report2io called" ); \
  if (!prefix || *prefix == 0) { \
    prefix = "<top>"; \
  } \
  if (!what) { \
    what = float_descr; \
  } \
  PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0); \
  float_type ## _acc_fold_psum(a); \
  sz = dtsize(a->dict); \
  rp = (sz < a->max2rep) ? sz : a->max2rep; \
  if (sz == 0) { /* no values accumulated */ \
    sfprintf(outstr, "(No %s values.)\n", what); \
    return P_OK; \
  } \
  if (sz == 1 && a->bad == 0) { \
    elt = (float_type ## _dt_elt_t*)dtfirst(a->dict); \
    sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %I810.5f\n", \
	     a->good, what, elt->key.val); \
    dtnext(a->dict, 0); /* discard any iterator state */ \
    return P_OK; \
  } \
  if (a->good == 0) { \
    bad_pcnt = (a->bad == 0) ? 0.0 : 100.0; \
  } else { \
    bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad)); \
  } \
  sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %I88.3f\n", \
	   a->good, a->bad, bad_pcnt); \
  if (a->good == 0) { \
    sfprintf(outstr, "(No good %s values.)\n", what); \
    return P_OK; \
  } \
  /* check for 100% identical values */ \
  if (sz == 1) { \
    elt = (float_type ## _dt_elt_t*)dtfirst(a->dict); \
    sfprintf(outstr, "For good %s values, 100 pcnt identical: %I810.5f\n", \
	     what, elt->key.val); \
    dtnext(a->dict, 0); /* discard any iterator state */ \
    return P_OK; \
  } \
  dtdisc(a->dict,   &float_type ## _acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */ \
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */ \
  sfprintf(outstr, "  Characterizing %s values:  min %I8.5f", what, a->min); \
  sfprintf(outstr, " max %I8.5f", a->max); \
  sfprintf(outstr, " avg %I8.3f\n", a->avg); \
  sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz); \
  if (sz == a->max2track && a->good > a->tracked) { \
    track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); \
    sfprintf(outstr, "        (* hit tracking limit, tracked %I8.3f pcnt of all values *) \n", track_pcnt); \
  } \
  for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict); \
       velt && i < a->max2rep; \
       velt = dtnext(a->dict, velt), i++) { \
    if (cnt_sum_pcnt >= a->pcnt2rep) { \
      sfprintf(outstr, " [... %d of top %d values not reported due to %I8.2f pcnt limit on reported values ...]\n", \
	       rp-i, rp, a->pcnt2rep); \
      break; \
    } \
    elt = (float_type ## _dt_elt_t*)velt; \
    elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good); \
    sfprintf(outstr, "        val: %I810.5f", elt->key.val); \
    sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %I88.3f\n", elt->key.cnt, elt_pcnt); \
    cnt_sum += elt->key.cnt; \
    cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good); \
  } \
  dtnext(a->dict, 0); /* discard any iterator state */ \
  sfprintf(outstr,   ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n"); \
  sfprintf(outstr,   "        SUMMING         count: %10llu  pcnt-of-good-vals: %I88.3f\n", \
	   cnt_sum, cnt_sum_pcnt); \
  /* revert to unordered set in case more inserts will occur after this report */ \
  dtmethod(a->dict, Dtset); /* change to unordered set */ \
  dtdisc(a->dict,   &float_type ## _acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */ \
  return P_OK; \
} \
 \
 \
Perror_t \
float_type ## _acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, float_type ## _acc *a) \
{ \
  int                      i, sz, rp; \
  Pfloat64                 track_pcnt; \
  Void_t                  *velt; \
  float_type ## _dt_elt_t *elt; \
 \
  P_TRACE(pads->disc, PDCI_MacroArg2String(float_type) "_acc_report2xml_io called" ); \
  float_type ## _acc_fold_psum(a); \
  sz = dtsize(a->dict); \
  rp = (sz < a->max2rep) ? sz : a->max2rep; \
  if (sz == 0) { /* no values accumulated */ \
    PDCI_indent(outstr, nst); \
    sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(float_type), PDCI_MacroArg2String(float_type)); \
    return P_OK; \
  } \
 \
  PDCI_indent(outstr, nst++); \
  sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(float_type)); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<good>%llu", a->good); \
  sfprintf(outstr, "</good>\n"); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<bad>%llu", a->bad); \
  sfprintf(outstr, "</bad>\n"); \
 \
  dtdisc(a->dict,   &float_type ## _acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */ \
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */ \
 \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<min>%.5I8f", a->min); \
  sfprintf(outstr, "</min>\n"); \
  PDCI_indent(outstr, nst); \
  sfprintf(outstr, "<max>%.5I8f", a->max); \
  sfprintf(outstr, "</max>\n"); \
 \
  if (sz!=0){ \
     PDCI_indent(outstr, nst++); \
     sfprintf(outstr, "<distribution>\n"); \
     PDCI_indent(outstr, nst); \
     sfprintf(outstr, "<top>%d</top>", rp); \
     sfprintf(outstr, "<distinct>%d</distinct>\n", sz); \
 \
     if (sz == a->max2track && a->good > a->tracked) { \
       track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); \
       PDCI_indent(outstr, nst); \
       sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); \
     }; \
 \
     for (i = 0, velt = dtfirst(a->dict); \
          velt && i < a->max2rep; \
          velt = dtnext(a->dict, velt), i++) { \
       elt = (float_type ## _dt_elt_t*)velt; \
       PDCI_indent(outstr, nst); \
       sfprintf(outstr, "<item>"); \
       sfprintf(outstr, "<val>%I810.5f", elt->key.val); \
       sfprintf(outstr, "</val>"); \
       sfprintf(outstr, "<count>%llu</count>", elt->key.cnt); \
       sfprintf(outstr, "</item>\n"); \
     } \
     PDCI_indent(outstr, --nst); \
     sfprintf(outstr, "</distribution>\n"); \
  } \
  PDCI_indent(outstr, --nst); \
  sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(float_type)); \
 \
  dtnext(a->dict, 0); /* discard any iterator state */ \
  /* revert to unordered set in case more inserts will occur after this report */ \
  dtmethod(a->dict, Dtset); /* change to unordered set */ \
  dtdisc(a->dict,   &float_type ## _acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */ \
  return P_OK; \
} \
 \
Perror_t \
float_type ## _acc_report(P_t *pads, const char *prefix, const char *what, int nst, \
			  float_type ## _acc *a) \
{ \
  Sfio_t *tmpstr; \
  Perror_t res; \
  PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(float_type) "_acc_report", a); \
  if (!pads->disc->error_fn) { \
    return P_OK; \
  } \
  if (!(tmpstr = sfstropen ())) {  \
    return P_ERR; \
  } \
  res = float_type ## _acc_report2io(pads, tmpstr, prefix, what, nst, a); \
  if (res == P_OK) { \
    pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr)); \
  } \
  sfstrclose (tmpstr); \
  return res; \
} \

#if P_CONFIG_ACCUM_FUNCTIONS > 0
#  define PDCI_INT_ACCUM(int_type, int_descr, num_bytes, fmt, mfmt, fold_test) \
            PDCI_INT_ACCUM_GEN(int_type, int_descr, num_bytes, fmt, mfmt, fold_test)
#  define PDCI_INT_ACCUM_MAP_REPORT(int_type, int_descr, fmt, mfmt) \
            PDCI_INT_ACCUM_MAP_REPORT_GEN(int_type, int_descr, fmt, mfmt)
#  define PDCI_FPOINT_ACCUM(fpoint_type, fpoint_descr) \
            PDCI_FPOINT_ACCUM_GEN(fpoint_type, fpoint_descr)
#  define PDCI_FLOAT_ACCUM(float_type, float_descr) \
            PDCI_FLOAT_ACCUM_GEN(float_type, float_descr)
#else
#  define PDCI_INT_ACCUM(int_type, int_descr, num_bytes, fmt, mfmt, fold_test)
#  define PDCI_INT_ACCUM_MAP_REPORT(int_type, int_descr, fmt, mfmt)
#  define PDCI_FPOINT_ACCUM(fpoint_type, fpoint_descr)
#  define PDCI_FLOAT_ACCUM(float_type, float_descr)
#endif

#endif  /*  __PADS_ACC_MACROS_GEN_H__  */

