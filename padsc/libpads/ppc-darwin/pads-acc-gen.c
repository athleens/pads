/*
 * WARNING: GENERATED FILE.  Do not edit this file, edit /Users/kfisher/pads/padsc/libpads/pads.c instead. 
 */

/*
 * Generated accumulator functions
 * 
 * Kathleen Fisher, Robert Gruber
 * AT&T Labs Research
 */

#include "pads-internal.h"
#include "pads-macros-gen.h"

int Puint8_dt_elt_oset_cmp(Dt_t *dt, Puint8_dt_key_t *a, Puint8_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Puint8_dt_elt_set_cmp(Dt_t *dt, Puint8_dt_key_t *a, Puint8_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Puint8_dt_elt_make(Dt_t *dt, Puint8_dt_elt_t *a, Dtdisc_t *disc) {
 Puint8_dt_elt_t *b;
 if ((b = oldof(0, Puint8_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Puint8_dt_elt_free(Dt_t *dt, Puint8_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Puint8_acc_dt_set_disc = {
 DTOFFSET(Puint8_dt_elt_t, key), 1, DTOFFSET(Puint8_dt_elt_t, link), (Dtmake_f)Puint8_dt_elt_make, (Dtfree_f)Puint8_dt_elt_free, (Dtcompar_f)Puint8_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Puint8_acc_dt_oset_disc = {
 DTOFFSET(Puint8_dt_elt_t, key), 1, DTOFFSET(Puint8_dt_elt_t, link), (Dtmake_f)Puint8_dt_elt_make, (Dtfree_f)Puint8_dt_elt_free, (Dtcompar_f)Puint8_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Puint8_acc_init(P_t *pads, Puint8_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint8) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Puint8_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Puint8_acc_reset(P_t *pads, Puint8_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint8) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Puint8_acc_cleanup(P_t *pads, Puint8_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint8) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Puint8_acc_fold_psum(Puint8_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Puint8_acc_avg(P_t *pads, Puint8_acc *a) {
 Puint8_acc_fold_psum(a);
 return a->avg;
 }
 Puint8 Puint8_acc_ravg(P_t *pads, Puint8_acc *a) {
 Puint8 res;
 Puint8_acc_fold_psum(a);
 if (a->avg >= 0) {
 res = (a->avg + 0.5);
 }
 else {
 res = (a->avg - 0.5);
 }
 return res;
 }
 Perror_t Puint8_acc_add(P_t *pads, Puint8_acc *a, const Pbase_pd *pd, const Puint8 *val) {
 Puint8 v;
 Puint8_dt_elt_t insert_elt;
 Puint8_dt_key_t lookup_key;
 Puint8_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Puint8) "_acc_add", a, pd, val);
 v = (*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if (PDCI_FOLDTEST_UINT8(v, a->psum)) {
 Puint8_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Puint8_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Puint8_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Puint8_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Puint8) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "uint8";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Puint8_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Puint8_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10" "I1u" "\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Puint8_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10" "I1u" "\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Puint8_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %" "llu", what, a->min);
 sfprintf(outstr, " max %" "llu", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Puint8_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10" "I1u", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Puint8_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Puint8_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Puint8_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Puint8_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Puint8) "_acc_report2xml_io called" ); Puint8_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Puint8), PDCI_MacroArg2String(Puint8)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Puint8)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%" "llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%" "llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Puint8_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%" "llu", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%" "llu", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Puint8_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%" "I1u", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Puint8));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Puint8_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Puint8_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Puint8_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint8) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Puint8_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
int Pint32_dt_elt_oset_cmp(Dt_t *dt, Pint32_dt_key_t *a, Pint32_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pint32_dt_elt_set_cmp(Dt_t *dt, Pint32_dt_key_t *a, Pint32_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pint32_dt_elt_make(Dt_t *dt, Pint32_dt_elt_t *a, Dtdisc_t *disc) {
 Pint32_dt_elt_t *b;
 if ((b = oldof(0, Pint32_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pint32_dt_elt_free(Dt_t *dt, Pint32_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pint32_acc_dt_set_disc = {
 DTOFFSET(Pint32_dt_elt_t, key), 4, DTOFFSET(Pint32_dt_elt_t, link), (Dtmake_f)Pint32_dt_elt_make, (Dtfree_f)Pint32_dt_elt_free, (Dtcompar_f)Pint32_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pint32_acc_dt_oset_disc = {
 DTOFFSET(Pint32_dt_elt_t, key), 4, DTOFFSET(Pint32_dt_elt_t, link), (Dtmake_f)Pint32_dt_elt_make, (Dtfree_f)Pint32_dt_elt_free, (Dtcompar_f)Pint32_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pint32_acc_init(P_t *pads, Pint32_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint32) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pint32_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pint32_acc_reset(P_t *pads, Pint32_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint32) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pint32_acc_cleanup(P_t *pads, Pint32_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint32) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pint32_acc_fold_psum(Pint32_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pint32_acc_avg(P_t *pads, Pint32_acc *a) {
 Pint32_acc_fold_psum(a);
 return a->avg;
 }
 Pint32 Pint32_acc_ravg(P_t *pads, Pint32_acc *a) {
 Pint32 res;
 Pint32_acc_fold_psum(a);
 if (a->avg >= 0) {
 res = (a->avg + 0.5);
 }
 else {
 res = (a->avg - 0.5);
 }
 return res;
 }
 Perror_t Pint32_acc_add(P_t *pads, Pint32_acc *a, const Pbase_pd *pd, const Pint32 *val) {
 Pint32 v;
 Pint32_dt_elt_t insert_elt;
 Pint32_dt_key_t lookup_key;
 Pint32_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pint32) "_acc_add", a, pd, val);
 v = (*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if (PDCI_FOLDTEST_INT32(v, a->psum)) {
 Pint32_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pint32_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pint32_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pint32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pint32) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "int32";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pint32_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pint32_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10" "I4d" "\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pint32_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10" "I4d" "\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pint32_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %" "lld", what, a->min);
 sfprintf(outstr, " max %" "lld", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pint32_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10" "I4d", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pint32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pint32_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Pint32_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pint32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pint32) "_acc_report2xml_io called" ); Pint32_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pint32), PDCI_MacroArg2String(Pint32)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pint32)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%" "lld", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%" "lld", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pint32_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%" "lld", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%" "lld", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pint32_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%" "I4d", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pint32));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pint32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pint32_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pint32_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint32) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pint32_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
int Puint32_dt_elt_oset_cmp(Dt_t *dt, Puint32_dt_key_t *a, Puint32_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Puint32_dt_elt_set_cmp(Dt_t *dt, Puint32_dt_key_t *a, Puint32_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Puint32_dt_elt_make(Dt_t *dt, Puint32_dt_elt_t *a, Dtdisc_t *disc) {
 Puint32_dt_elt_t *b;
 if ((b = oldof(0, Puint32_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Puint32_dt_elt_free(Dt_t *dt, Puint32_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Puint32_acc_dt_set_disc = {
 DTOFFSET(Puint32_dt_elt_t, key), 4, DTOFFSET(Puint32_dt_elt_t, link), (Dtmake_f)Puint32_dt_elt_make, (Dtfree_f)Puint32_dt_elt_free, (Dtcompar_f)Puint32_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Puint32_acc_dt_oset_disc = {
 DTOFFSET(Puint32_dt_elt_t, key), 4, DTOFFSET(Puint32_dt_elt_t, link), (Dtmake_f)Puint32_dt_elt_make, (Dtfree_f)Puint32_dt_elt_free, (Dtcompar_f)Puint32_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Puint32_acc_init(P_t *pads, Puint32_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint32) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Puint32_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Puint32_acc_reset(P_t *pads, Puint32_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint32) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Puint32_acc_cleanup(P_t *pads, Puint32_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint32) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Puint32_acc_fold_psum(Puint32_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Puint32_acc_avg(P_t *pads, Puint32_acc *a) {
 Puint32_acc_fold_psum(a);
 return a->avg;
 }
 Puint32 Puint32_acc_ravg(P_t *pads, Puint32_acc *a) {
 Puint32 res;
 Puint32_acc_fold_psum(a);
 if (a->avg >= 0) {
 res = (a->avg + 0.5);
 }
 else {
 res = (a->avg - 0.5);
 }
 return res;
 }
 Perror_t Puint32_acc_add(P_t *pads, Puint32_acc *a, const Pbase_pd *pd, const Puint32 *val) {
 Puint32 v;
 Puint32_dt_elt_t insert_elt;
 Puint32_dt_key_t lookup_key;
 Puint32_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Puint32) "_acc_add", a, pd, val);
 v = (*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if (PDCI_FOLDTEST_UINT32(v, a->psum)) {
 Puint32_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Puint32_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Puint32_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Puint32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Puint32) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "uint32";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Puint32_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Puint32_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10" "I4u" "\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Puint32_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10" "I4u" "\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Puint32_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %" "llu", what, a->min);
 sfprintf(outstr, " max %" "llu", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Puint32_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10" "I4u", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Puint32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Puint32_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Puint32_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Puint32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Puint32) "_acc_report2xml_io called" ); Puint32_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Puint32), PDCI_MacroArg2String(Puint32)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Puint32)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%" "llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%" "llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Puint32_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%" "llu", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%" "llu", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Puint32_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%" "I4u", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Puint32));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Puint32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Puint32_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Puint32_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint32) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Puint32_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }

int Pint8_dt_elt_oset_cmp(Dt_t *dt, Pint8_dt_key_t *a, Pint8_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pint8_dt_elt_set_cmp(Dt_t *dt, Pint8_dt_key_t *a, Pint8_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pint8_dt_elt_make(Dt_t *dt, Pint8_dt_elt_t *a, Dtdisc_t *disc) {
 Pint8_dt_elt_t *b;
 if ((b = oldof(0, Pint8_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pint8_dt_elt_free(Dt_t *dt, Pint8_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pint8_acc_dt_set_disc = {
 DTOFFSET(Pint8_dt_elt_t, key), 1, DTOFFSET(Pint8_dt_elt_t, link), (Dtmake_f)Pint8_dt_elt_make, (Dtfree_f)Pint8_dt_elt_free, (Dtcompar_f)Pint8_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pint8_acc_dt_oset_disc = {
 DTOFFSET(Pint8_dt_elt_t, key), 1, DTOFFSET(Pint8_dt_elt_t, link), (Dtmake_f)Pint8_dt_elt_make, (Dtfree_f)Pint8_dt_elt_free, (Dtcompar_f)Pint8_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pint8_acc_init(P_t *pads, Pint8_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint8) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pint8_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pint8_acc_reset(P_t *pads, Pint8_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint8) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pint8_acc_cleanup(P_t *pads, Pint8_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint8) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pint8_acc_fold_psum(Pint8_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pint8_acc_avg(P_t *pads, Pint8_acc *a) {
 Pint8_acc_fold_psum(a);
 return a->avg;
 }
 Pint8 Pint8_acc_ravg(P_t *pads, Pint8_acc *a) {
 Pint8 res;
 Pint8_acc_fold_psum(a);
 if (a->avg >= 0) {
 res = (a->avg + 0.5);
 }
 else {
 res = (a->avg - 0.5);
 }
 return res;
 }
 Perror_t Pint8_acc_add(P_t *pads, Pint8_acc *a, const Pbase_pd *pd, const Pint8 *val) {
 Pint8 v;
 Pint8_dt_elt_t insert_elt;
 Pint8_dt_key_t lookup_key;
 Pint8_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pint8) "_acc_add", a, pd, val);
 v = (*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if (PDCI_FOLDTEST_INT8(v, a->psum)) {
 Pint8_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pint8_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pint8_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pint8_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pint8) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "int8";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pint8_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pint8_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10" "I1d" "\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pint8_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10" "I1d" "\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pint8_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %" "lld", what, a->min);
 sfprintf(outstr, " max %" "lld", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pint8_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10" "I1d", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pint8_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pint8_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Pint8_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pint8_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pint8) "_acc_report2xml_io called" ); Pint8_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pint8), PDCI_MacroArg2String(Pint8)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pint8)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%" "lld", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%" "lld", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pint8_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%" "lld", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%" "lld", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pint8_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%" "I1d", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pint8));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pint8_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pint8_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pint8_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint8) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pint8_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
int Pint16_dt_elt_oset_cmp(Dt_t *dt, Pint16_dt_key_t *a, Pint16_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pint16_dt_elt_set_cmp(Dt_t *dt, Pint16_dt_key_t *a, Pint16_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pint16_dt_elt_make(Dt_t *dt, Pint16_dt_elt_t *a, Dtdisc_t *disc) {
 Pint16_dt_elt_t *b;
 if ((b = oldof(0, Pint16_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pint16_dt_elt_free(Dt_t *dt, Pint16_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pint16_acc_dt_set_disc = {
 DTOFFSET(Pint16_dt_elt_t, key), 2, DTOFFSET(Pint16_dt_elt_t, link), (Dtmake_f)Pint16_dt_elt_make, (Dtfree_f)Pint16_dt_elt_free, (Dtcompar_f)Pint16_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pint16_acc_dt_oset_disc = {
 DTOFFSET(Pint16_dt_elt_t, key), 2, DTOFFSET(Pint16_dt_elt_t, link), (Dtmake_f)Pint16_dt_elt_make, (Dtfree_f)Pint16_dt_elt_free, (Dtcompar_f)Pint16_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pint16_acc_init(P_t *pads, Pint16_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint16) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pint16_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pint16_acc_reset(P_t *pads, Pint16_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint16) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pint16_acc_cleanup(P_t *pads, Pint16_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint16) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pint16_acc_fold_psum(Pint16_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pint16_acc_avg(P_t *pads, Pint16_acc *a) {
 Pint16_acc_fold_psum(a);
 return a->avg;
 }
 Pint16 Pint16_acc_ravg(P_t *pads, Pint16_acc *a) {
 Pint16 res;
 Pint16_acc_fold_psum(a);
 if (a->avg >= 0) {
 res = (a->avg + 0.5);
 }
 else {
 res = (a->avg - 0.5);
 }
 return res;
 }
 Perror_t Pint16_acc_add(P_t *pads, Pint16_acc *a, const Pbase_pd *pd, const Pint16 *val) {
 Pint16 v;
 Pint16_dt_elt_t insert_elt;
 Pint16_dt_key_t lookup_key;
 Pint16_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pint16) "_acc_add", a, pd, val);
 v = (*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if (PDCI_FOLDTEST_INT16(v, a->psum)) {
 Pint16_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pint16_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pint16_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pint16_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pint16) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "int16";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pint16_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pint16_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10" "I2d" "\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pint16_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10" "I2d" "\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pint16_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %" "lld", what, a->min);
 sfprintf(outstr, " max %" "lld", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pint16_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10" "I2d", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pint16_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pint16_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Pint16_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pint16_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pint16) "_acc_report2xml_io called" ); Pint16_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pint16), PDCI_MacroArg2String(Pint16)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pint16)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%" "lld", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%" "lld", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pint16_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%" "lld", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%" "lld", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pint16_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%" "I2d", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pint16));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pint16_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pint16_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pint16_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint16) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pint16_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
int Puint16_dt_elt_oset_cmp(Dt_t *dt, Puint16_dt_key_t *a, Puint16_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Puint16_dt_elt_set_cmp(Dt_t *dt, Puint16_dt_key_t *a, Puint16_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Puint16_dt_elt_make(Dt_t *dt, Puint16_dt_elt_t *a, Dtdisc_t *disc) {
 Puint16_dt_elt_t *b;
 if ((b = oldof(0, Puint16_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Puint16_dt_elt_free(Dt_t *dt, Puint16_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Puint16_acc_dt_set_disc = {
 DTOFFSET(Puint16_dt_elt_t, key), 2, DTOFFSET(Puint16_dt_elt_t, link), (Dtmake_f)Puint16_dt_elt_make, (Dtfree_f)Puint16_dt_elt_free, (Dtcompar_f)Puint16_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Puint16_acc_dt_oset_disc = {
 DTOFFSET(Puint16_dt_elt_t, key), 2, DTOFFSET(Puint16_dt_elt_t, link), (Dtmake_f)Puint16_dt_elt_make, (Dtfree_f)Puint16_dt_elt_free, (Dtcompar_f)Puint16_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Puint16_acc_init(P_t *pads, Puint16_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint16) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Puint16_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Puint16_acc_reset(P_t *pads, Puint16_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint16) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Puint16_acc_cleanup(P_t *pads, Puint16_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint16) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Puint16_acc_fold_psum(Puint16_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Puint16_acc_avg(P_t *pads, Puint16_acc *a) {
 Puint16_acc_fold_psum(a);
 return a->avg;
 }
 Puint16 Puint16_acc_ravg(P_t *pads, Puint16_acc *a) {
 Puint16 res;
 Puint16_acc_fold_psum(a);
 if (a->avg >= 0) {
 res = (a->avg + 0.5);
 }
 else {
 res = (a->avg - 0.5);
 }
 return res;
 }
 Perror_t Puint16_acc_add(P_t *pads, Puint16_acc *a, const Pbase_pd *pd, const Puint16 *val) {
 Puint16 v;
 Puint16_dt_elt_t insert_elt;
 Puint16_dt_key_t lookup_key;
 Puint16_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Puint16) "_acc_add", a, pd, val);
 v = (*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if (PDCI_FOLDTEST_UINT16(v, a->psum)) {
 Puint16_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Puint16_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Puint16_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Puint16_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Puint16) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "uint16";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Puint16_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Puint16_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10" "I2u" "\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Puint16_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10" "I2u" "\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Puint16_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %" "llu", what, a->min);
 sfprintf(outstr, " max %" "llu", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Puint16_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10" "I2u", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Puint16_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Puint16_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Puint16_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Puint16_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Puint16) "_acc_report2xml_io called" ); Puint16_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Puint16), PDCI_MacroArg2String(Puint16)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Puint16)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%" "llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%" "llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Puint16_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%" "llu", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%" "llu", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Puint16_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%" "I2u", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Puint16));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Puint16_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Puint16_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Puint16_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint16) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Puint16_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
int Pint64_dt_elt_oset_cmp(Dt_t *dt, Pint64_dt_key_t *a, Pint64_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pint64_dt_elt_set_cmp(Dt_t *dt, Pint64_dt_key_t *a, Pint64_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pint64_dt_elt_make(Dt_t *dt, Pint64_dt_elt_t *a, Dtdisc_t *disc) {
 Pint64_dt_elt_t *b;
 if ((b = oldof(0, Pint64_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pint64_dt_elt_free(Dt_t *dt, Pint64_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pint64_acc_dt_set_disc = {
 DTOFFSET(Pint64_dt_elt_t, key), 8, DTOFFSET(Pint64_dt_elt_t, link), (Dtmake_f)Pint64_dt_elt_make, (Dtfree_f)Pint64_dt_elt_free, (Dtcompar_f)Pint64_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pint64_acc_dt_oset_disc = {
 DTOFFSET(Pint64_dt_elt_t, key), 8, DTOFFSET(Pint64_dt_elt_t, link), (Dtmake_f)Pint64_dt_elt_make, (Dtfree_f)Pint64_dt_elt_free, (Dtcompar_f)Pint64_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pint64_acc_init(P_t *pads, Pint64_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint64) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pint64_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pint64_acc_reset(P_t *pads, Pint64_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint64) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pint64_acc_cleanup(P_t *pads, Pint64_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint64) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pint64_acc_fold_psum(Pint64_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pint64_acc_avg(P_t *pads, Pint64_acc *a) {
 Pint64_acc_fold_psum(a);
 return a->avg;
 }
 Pint64 Pint64_acc_ravg(P_t *pads, Pint64_acc *a) {
 Pint64 res;
 Pint64_acc_fold_psum(a);
 if (a->avg >= 0) {
 res = (a->avg + 0.5);
 }
 else {
 res = (a->avg - 0.5);
 }
 return res;
 }
 Perror_t Pint64_acc_add(P_t *pads, Pint64_acc *a, const Pbase_pd *pd, const Pint64 *val) {
 Pint64 v;
 Pint64_dt_elt_t insert_elt;
 Pint64_dt_key_t lookup_key;
 Pint64_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pint64) "_acc_add", a, pd, val);
 v = (*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if (PDCI_FOLDTEST_INT64(v, a->psum)) {
 Pint64_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pint64_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pint64_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pint64_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pint64) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "int64";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pint64_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pint64_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10" "lld" "\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pint64_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10" "lld" "\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pint64_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %" "lld", what, a->min);
 sfprintf(outstr, " max %" "lld", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pint64_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10" "lld", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pint64_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pint64_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Pint64_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pint64_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pint64) "_acc_report2xml_io called" ); Pint64_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pint64), PDCI_MacroArg2String(Pint64)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pint64)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%" "lld", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%" "lld", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pint64_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%" "lld", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%" "lld", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pint64_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%" "lld", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pint64));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pint64_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pint64_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pint64_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint64) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pint64_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
int Puint64_dt_elt_oset_cmp(Dt_t *dt, Puint64_dt_key_t *a, Puint64_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Puint64_dt_elt_set_cmp(Dt_t *dt, Puint64_dt_key_t *a, Puint64_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Puint64_dt_elt_make(Dt_t *dt, Puint64_dt_elt_t *a, Dtdisc_t *disc) {
 Puint64_dt_elt_t *b;
 if ((b = oldof(0, Puint64_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Puint64_dt_elt_free(Dt_t *dt, Puint64_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Puint64_acc_dt_set_disc = {
 DTOFFSET(Puint64_dt_elt_t, key), 8, DTOFFSET(Puint64_dt_elt_t, link), (Dtmake_f)Puint64_dt_elt_make, (Dtfree_f)Puint64_dt_elt_free, (Dtcompar_f)Puint64_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Puint64_acc_dt_oset_disc = {
 DTOFFSET(Puint64_dt_elt_t, key), 8, DTOFFSET(Puint64_dt_elt_t, link), (Dtmake_f)Puint64_dt_elt_make, (Dtfree_f)Puint64_dt_elt_free, (Dtcompar_f)Puint64_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Puint64_acc_init(P_t *pads, Puint64_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint64) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Puint64_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Puint64_acc_reset(P_t *pads, Puint64_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint64) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Puint64_acc_cleanup(P_t *pads, Puint64_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint64) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Puint64_acc_fold_psum(Puint64_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Puint64_acc_avg(P_t *pads, Puint64_acc *a) {
 Puint64_acc_fold_psum(a);
 return a->avg;
 }
 Puint64 Puint64_acc_ravg(P_t *pads, Puint64_acc *a) {
 Puint64 res;
 Puint64_acc_fold_psum(a);
 if (a->avg >= 0) {
 res = (a->avg + 0.5);
 }
 else {
 res = (a->avg - 0.5);
 }
 return res;
 }
 Perror_t Puint64_acc_add(P_t *pads, Puint64_acc *a, const Pbase_pd *pd, const Puint64 *val) {
 Puint64 v;
 Puint64_dt_elt_t insert_elt;
 Puint64_dt_key_t lookup_key;
 Puint64_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Puint64) "_acc_add", a, pd, val);
 v = (*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if (PDCI_FOLDTEST_UINT64(v, a->psum)) {
 Puint64_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Puint64_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Puint64_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Puint64_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Puint64) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "uint64";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Puint64_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Puint64_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10" "llu" "\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Puint64_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10" "llu" "\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Puint64_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %" "llu", what, a->min);
 sfprintf(outstr, " max %" "llu", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Puint64_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10" "llu", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Puint64_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Puint64_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Puint64_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Puint64_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Puint64) "_acc_report2xml_io called" ); Puint64_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Puint64), PDCI_MacroArg2String(Puint64)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Puint64)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%" "llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%" "llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Puint64_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%" "llu", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%" "llu", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Puint64_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%" "llu", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Puint64));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Puint64_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Puint64_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Puint64_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Puint64) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Puint64_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }

Perror_t Pint32_acc_map_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pint32_map_fn fn, Pint32_acc *a) {
 size_t pad;
 const char *mapped_min;
 const char *mapped_max;
 const char *mapped_val;
 int i, sz, rp, tmp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pint32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pint32) "_acc_map_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "int32";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pint32_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pint32_dt_elt_t*)dtfirst(a->dict);
 mapped_val = fn(elt->key.val);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %s (%5" "I4d" ")\n", a->good, what, mapped_val, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pint32_dt_elt_t*)dtfirst(a->dict);
 mapped_val = fn(elt->key.val);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %s (%5" "I4d" ")\n", what, mapped_val, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pint32_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 mapped_min = fn(a->min);
 mapped_max = fn(a->max);
 sfprintf(outstr, "  Characterizing %s values:  min %s (%5" "lld", what, mapped_min, a->min);
 sfprintf(outstr, ")  max %s (%5" "lld", mapped_max, a->max);
 sfprintf(outstr, ")\n");
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 sz = tmp = 0;
 for (i = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 elt = (Pint32_dt_elt_t*)velt;
 sz = strlen(fn(elt->key.val));
 if (sz > tmp) {
 tmp = sz;
 }
 }
 dtnext(a->dict, 0);
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep); break; } dtnext(a->dict, 0); elt = (Pint32_dt_elt_t*)velt; elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good); mapped_val = fn(elt->key.val);
 sfprintf(outstr, "        val: %s (%5" "I4d", mapped_val, elt->key.val);
 sfprintf(outstr, ") "); pad = tmp-strlen(mapped_val);
 sfprintf(outstr, "%-.*s", pad, PDCI_spaces);
 sfprintf(outstr, "  count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 sfprintf(outstr, "%-.*s", tmp, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .");
 sfprintf(outstr, " . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n        SUMMING");
 sfprintf(outstr, "%-.*s", tmp, PDCI_spaces);
 sfprintf(outstr, "         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pint32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pint32_acc_map_report(P_t *pads, const char *prefix, const char *what, int nst, Pint32_map_fn fn, Pint32_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pint32) "_acc_map_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pint32_acc_map_report2io(pads, tmpstr, prefix, what, nst, fn, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
 Perror_t Pint32_acc_map_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Pint32_map_fn fn, Pint32_acc *a) {
 const char *mapped_min;
 const char *mapped_max;
 const char *mapped_val;
 int i, sz, rp, tmp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pint32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pint32) "_acc_map_report2xml_io called" ); Pint32_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { return P_OK; } PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%" "lld", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%" "lld", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pint32_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); mapped_min = fn(a->min); mapped_max = fn(a->max); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%s</min>\n", mapped_min); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%s</max>\n", mapped_max); if (sz != 0) { PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); } sz = tmp = 0; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pint32_dt_elt_t*)velt; sz = strlen(fn(elt->key.val)); if (sz > tmp) { tmp = sz; } } dtnext(a->dict, 0); for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { dtnext(a->dict, 0); elt = (Pint32_dt_elt_t*)velt; mapped_val = fn(elt->key.val); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%s</val>", mapped_val);
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } nst--; PDCI_indent(outstr, nst);
 sfprintf(outstr, "</distribution>\n");
 }
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pint32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }

typedef struct Pfpoint8_dt_key_s {
 Pfloat64 val;
 Puint64 cnt;
 }
 Pfpoint8_dt_key_t;
 typedef struct Pfpoint8_dt_elt_s {
 Pfpoint8_dt_key_t key;
 Dtlink_t link;
 }
 Pfpoint8_dt_elt_t;
 int Pfpoint8_dt_elt_oset_cmp(Dt_t *dt, Pfpoint8_dt_key_t *a, Pfpoint8_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pfpoint8_dt_elt_set_cmp(Dt_t *dt, Pfpoint8_dt_key_t *a, Pfpoint8_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pfpoint8_dt_elt_make(Dt_t *dt, Pfpoint8_dt_elt_t *a, Dtdisc_t *disc) {
 Pfpoint8_dt_elt_t *b;
 if ((b = oldof(0, Pfpoint8_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pfpoint8_dt_elt_free(Dt_t *dt, Pfpoint8_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pfpoint8_acc_dt_set_disc = {
 DTOFFSET(Pfpoint8_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfpoint8_dt_elt_t, link), (Dtmake_f)Pfpoint8_dt_elt_make, (Dtfree_f)Pfpoint8_dt_elt_free, (Dtcompar_f)Pfpoint8_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pfpoint8_acc_dt_oset_disc = {
 DTOFFSET(Pfpoint8_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfpoint8_dt_elt_t, link), (Dtmake_f)Pfpoint8_dt_elt_make, (Dtfree_f)Pfpoint8_dt_elt_free, (Dtcompar_f)Pfpoint8_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pfpoint8_acc_init(P_t *pads, Pfpoint8_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint8) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pfpoint8_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pfpoint8_acc_reset(P_t *pads, Pfpoint8_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint8) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pfpoint8_acc_cleanup(P_t *pads, Pfpoint8_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint8) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pfpoint8_acc_fold_psum(Pfpoint8_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pfpoint8_acc_avg(P_t *pads, Pfpoint8_acc *a) {
 Pfpoint8_acc_fold_psum(a);
 return a->avg;
 }
 Perror_t Pfpoint8_acc_add(P_t *pads, Pfpoint8_acc *a, const Pbase_pd *pd, const Pfpoint8 *val) {
 Pfloat64 v;
 Pfpoint8_dt_elt_t insert_elt;
 Pfpoint8_dt_key_t lookup_key;
 Pfpoint8_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pfpoint8) "_acc_add", a, pd, val);
 v = P_FPOINT2FLOAT64(*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if ( (v > 0 && a->psum > PDCI_LARGE_POS_DBL) || (v < 0 && a->psum < PDCI_LARGE_NEG_DBL) ) {
 Pfpoint8_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pfpoint8_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pfpoint8_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pfpoint8_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfpoint8) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "fpoint8";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pfpoint8_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pfpoint8_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10.5I8f\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pfpoint8_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10.5I8f\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pfpoint8_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %.5I8f", what, a->min);
 sfprintf(outstr, " max %.5I8f", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pfpoint8_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10.5I8f", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfpoint8_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfpoint8_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst,Pfpoint8_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pfpoint8_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfpoint8) "_acc_report2xml_io called" ); Pfpoint8_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pfpoint8), PDCI_MacroArg2String(Pfpoint8)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pfpoint8)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pfpoint8_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%.5I8f", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%.5I8f", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pfpoint8_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%.5I8f", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pfpoint8));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfpoint8_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfpoint8_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pfpoint8_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint8) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pfpoint8_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
typedef struct Pufpoint8_dt_key_s {
 Pfloat64 val;
 Puint64 cnt;
 }
 Pufpoint8_dt_key_t;
 typedef struct Pufpoint8_dt_elt_s {
 Pufpoint8_dt_key_t key;
 Dtlink_t link;
 }
 Pufpoint8_dt_elt_t;
 int Pufpoint8_dt_elt_oset_cmp(Dt_t *dt, Pufpoint8_dt_key_t *a, Pufpoint8_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pufpoint8_dt_elt_set_cmp(Dt_t *dt, Pufpoint8_dt_key_t *a, Pufpoint8_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pufpoint8_dt_elt_make(Dt_t *dt, Pufpoint8_dt_elt_t *a, Dtdisc_t *disc) {
 Pufpoint8_dt_elt_t *b;
 if ((b = oldof(0, Pufpoint8_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pufpoint8_dt_elt_free(Dt_t *dt, Pufpoint8_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pufpoint8_acc_dt_set_disc = {
 DTOFFSET(Pufpoint8_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pufpoint8_dt_elt_t, link), (Dtmake_f)Pufpoint8_dt_elt_make, (Dtfree_f)Pufpoint8_dt_elt_free, (Dtcompar_f)Pufpoint8_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pufpoint8_acc_dt_oset_disc = {
 DTOFFSET(Pufpoint8_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pufpoint8_dt_elt_t, link), (Dtmake_f)Pufpoint8_dt_elt_make, (Dtfree_f)Pufpoint8_dt_elt_free, (Dtcompar_f)Pufpoint8_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pufpoint8_acc_init(P_t *pads, Pufpoint8_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint8) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pufpoint8_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pufpoint8_acc_reset(P_t *pads, Pufpoint8_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint8) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pufpoint8_acc_cleanup(P_t *pads, Pufpoint8_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint8) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pufpoint8_acc_fold_psum(Pufpoint8_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pufpoint8_acc_avg(P_t *pads, Pufpoint8_acc *a) {
 Pufpoint8_acc_fold_psum(a);
 return a->avg;
 }
 Perror_t Pufpoint8_acc_add(P_t *pads, Pufpoint8_acc *a, const Pbase_pd *pd, const Pufpoint8 *val) {
 Pfloat64 v;
 Pufpoint8_dt_elt_t insert_elt;
 Pufpoint8_dt_key_t lookup_key;
 Pufpoint8_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pufpoint8) "_acc_add", a, pd, val);
 v = P_FPOINT2FLOAT64(*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if ( (v > 0 && a->psum > PDCI_LARGE_POS_DBL) || (v < 0 && a->psum < PDCI_LARGE_NEG_DBL) ) {
 Pufpoint8_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pufpoint8_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pufpoint8_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pufpoint8_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pufpoint8) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "ufpoint8";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pufpoint8_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pufpoint8_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10.5I8f\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pufpoint8_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10.5I8f\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pufpoint8_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %.5I8f", what, a->min);
 sfprintf(outstr, " max %.5I8f", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pufpoint8_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10.5I8f", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pufpoint8_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pufpoint8_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst,Pufpoint8_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pufpoint8_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pufpoint8) "_acc_report2xml_io called" ); Pufpoint8_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pufpoint8), PDCI_MacroArg2String(Pufpoint8)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pufpoint8)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pufpoint8_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%.5I8f", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%.5I8f", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pufpoint8_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%.5I8f", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pufpoint8));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pufpoint8_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pufpoint8_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pufpoint8_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint8) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pufpoint8_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
typedef struct Pfpoint16_dt_key_s {
 Pfloat64 val;
 Puint64 cnt;
 }
 Pfpoint16_dt_key_t;
 typedef struct Pfpoint16_dt_elt_s {
 Pfpoint16_dt_key_t key;
 Dtlink_t link;
 }
 Pfpoint16_dt_elt_t;
 int Pfpoint16_dt_elt_oset_cmp(Dt_t *dt, Pfpoint16_dt_key_t *a, Pfpoint16_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pfpoint16_dt_elt_set_cmp(Dt_t *dt, Pfpoint16_dt_key_t *a, Pfpoint16_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pfpoint16_dt_elt_make(Dt_t *dt, Pfpoint16_dt_elt_t *a, Dtdisc_t *disc) {
 Pfpoint16_dt_elt_t *b;
 if ((b = oldof(0, Pfpoint16_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pfpoint16_dt_elt_free(Dt_t *dt, Pfpoint16_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pfpoint16_acc_dt_set_disc = {
 DTOFFSET(Pfpoint16_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfpoint16_dt_elt_t, link), (Dtmake_f)Pfpoint16_dt_elt_make, (Dtfree_f)Pfpoint16_dt_elt_free, (Dtcompar_f)Pfpoint16_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pfpoint16_acc_dt_oset_disc = {
 DTOFFSET(Pfpoint16_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfpoint16_dt_elt_t, link), (Dtmake_f)Pfpoint16_dt_elt_make, (Dtfree_f)Pfpoint16_dt_elt_free, (Dtcompar_f)Pfpoint16_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pfpoint16_acc_init(P_t *pads, Pfpoint16_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint16) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pfpoint16_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pfpoint16_acc_reset(P_t *pads, Pfpoint16_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint16) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pfpoint16_acc_cleanup(P_t *pads, Pfpoint16_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint16) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pfpoint16_acc_fold_psum(Pfpoint16_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pfpoint16_acc_avg(P_t *pads, Pfpoint16_acc *a) {
 Pfpoint16_acc_fold_psum(a);
 return a->avg;
 }
 Perror_t Pfpoint16_acc_add(P_t *pads, Pfpoint16_acc *a, const Pbase_pd *pd, const Pfpoint16 *val) {
 Pfloat64 v;
 Pfpoint16_dt_elt_t insert_elt;
 Pfpoint16_dt_key_t lookup_key;
 Pfpoint16_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pfpoint16) "_acc_add", a, pd, val);
 v = P_FPOINT2FLOAT64(*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if ( (v > 0 && a->psum > PDCI_LARGE_POS_DBL) || (v < 0 && a->psum < PDCI_LARGE_NEG_DBL) ) {
 Pfpoint16_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pfpoint16_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pfpoint16_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pfpoint16_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfpoint16) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "fpoint16";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pfpoint16_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pfpoint16_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10.5I8f\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pfpoint16_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10.5I8f\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pfpoint16_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %.5I8f", what, a->min);
 sfprintf(outstr, " max %.5I8f", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pfpoint16_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10.5I8f", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfpoint16_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfpoint16_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst,Pfpoint16_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pfpoint16_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfpoint16) "_acc_report2xml_io called" ); Pfpoint16_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pfpoint16), PDCI_MacroArg2String(Pfpoint16)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pfpoint16)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pfpoint16_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%.5I8f", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%.5I8f", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pfpoint16_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%.5I8f", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pfpoint16));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfpoint16_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfpoint16_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pfpoint16_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint16) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pfpoint16_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
typedef struct Pufpoint16_dt_key_s {
 Pfloat64 val;
 Puint64 cnt;
 }
 Pufpoint16_dt_key_t;
 typedef struct Pufpoint16_dt_elt_s {
 Pufpoint16_dt_key_t key;
 Dtlink_t link;
 }
 Pufpoint16_dt_elt_t;
 int Pufpoint16_dt_elt_oset_cmp(Dt_t *dt, Pufpoint16_dt_key_t *a, Pufpoint16_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pufpoint16_dt_elt_set_cmp(Dt_t *dt, Pufpoint16_dt_key_t *a, Pufpoint16_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pufpoint16_dt_elt_make(Dt_t *dt, Pufpoint16_dt_elt_t *a, Dtdisc_t *disc) {
 Pufpoint16_dt_elt_t *b;
 if ((b = oldof(0, Pufpoint16_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pufpoint16_dt_elt_free(Dt_t *dt, Pufpoint16_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pufpoint16_acc_dt_set_disc = {
 DTOFFSET(Pufpoint16_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pufpoint16_dt_elt_t, link), (Dtmake_f)Pufpoint16_dt_elt_make, (Dtfree_f)Pufpoint16_dt_elt_free, (Dtcompar_f)Pufpoint16_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pufpoint16_acc_dt_oset_disc = {
 DTOFFSET(Pufpoint16_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pufpoint16_dt_elt_t, link), (Dtmake_f)Pufpoint16_dt_elt_make, (Dtfree_f)Pufpoint16_dt_elt_free, (Dtcompar_f)Pufpoint16_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pufpoint16_acc_init(P_t *pads, Pufpoint16_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint16) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pufpoint16_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pufpoint16_acc_reset(P_t *pads, Pufpoint16_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint16) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pufpoint16_acc_cleanup(P_t *pads, Pufpoint16_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint16) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pufpoint16_acc_fold_psum(Pufpoint16_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pufpoint16_acc_avg(P_t *pads, Pufpoint16_acc *a) {
 Pufpoint16_acc_fold_psum(a);
 return a->avg;
 }
 Perror_t Pufpoint16_acc_add(P_t *pads, Pufpoint16_acc *a, const Pbase_pd *pd, const Pufpoint16 *val) {
 Pfloat64 v;
 Pufpoint16_dt_elt_t insert_elt;
 Pufpoint16_dt_key_t lookup_key;
 Pufpoint16_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pufpoint16) "_acc_add", a, pd, val);
 v = P_FPOINT2FLOAT64(*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if ( (v > 0 && a->psum > PDCI_LARGE_POS_DBL) || (v < 0 && a->psum < PDCI_LARGE_NEG_DBL) ) {
 Pufpoint16_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pufpoint16_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pufpoint16_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pufpoint16_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pufpoint16) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "ufpoint16";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pufpoint16_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pufpoint16_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10.5I8f\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pufpoint16_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10.5I8f\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pufpoint16_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %.5I8f", what, a->min);
 sfprintf(outstr, " max %.5I8f", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pufpoint16_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10.5I8f", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pufpoint16_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pufpoint16_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst,Pufpoint16_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pufpoint16_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pufpoint16) "_acc_report2xml_io called" ); Pufpoint16_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pufpoint16), PDCI_MacroArg2String(Pufpoint16)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pufpoint16)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pufpoint16_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%.5I8f", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%.5I8f", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pufpoint16_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%.5I8f", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pufpoint16));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pufpoint16_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pufpoint16_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pufpoint16_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint16) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pufpoint16_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
typedef struct Pfpoint32_dt_key_s {
 Pfloat64 val;
 Puint64 cnt;
 }
 Pfpoint32_dt_key_t;
 typedef struct Pfpoint32_dt_elt_s {
 Pfpoint32_dt_key_t key;
 Dtlink_t link;
 }
 Pfpoint32_dt_elt_t;
 int Pfpoint32_dt_elt_oset_cmp(Dt_t *dt, Pfpoint32_dt_key_t *a, Pfpoint32_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pfpoint32_dt_elt_set_cmp(Dt_t *dt, Pfpoint32_dt_key_t *a, Pfpoint32_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pfpoint32_dt_elt_make(Dt_t *dt, Pfpoint32_dt_elt_t *a, Dtdisc_t *disc) {
 Pfpoint32_dt_elt_t *b;
 if ((b = oldof(0, Pfpoint32_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pfpoint32_dt_elt_free(Dt_t *dt, Pfpoint32_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pfpoint32_acc_dt_set_disc = {
 DTOFFSET(Pfpoint32_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfpoint32_dt_elt_t, link), (Dtmake_f)Pfpoint32_dt_elt_make, (Dtfree_f)Pfpoint32_dt_elt_free, (Dtcompar_f)Pfpoint32_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pfpoint32_acc_dt_oset_disc = {
 DTOFFSET(Pfpoint32_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfpoint32_dt_elt_t, link), (Dtmake_f)Pfpoint32_dt_elt_make, (Dtfree_f)Pfpoint32_dt_elt_free, (Dtcompar_f)Pfpoint32_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pfpoint32_acc_init(P_t *pads, Pfpoint32_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint32) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pfpoint32_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pfpoint32_acc_reset(P_t *pads, Pfpoint32_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint32) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pfpoint32_acc_cleanup(P_t *pads, Pfpoint32_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint32) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pfpoint32_acc_fold_psum(Pfpoint32_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pfpoint32_acc_avg(P_t *pads, Pfpoint32_acc *a) {
 Pfpoint32_acc_fold_psum(a);
 return a->avg;
 }
 Perror_t Pfpoint32_acc_add(P_t *pads, Pfpoint32_acc *a, const Pbase_pd *pd, const Pfpoint32 *val) {
 Pfloat64 v;
 Pfpoint32_dt_elt_t insert_elt;
 Pfpoint32_dt_key_t lookup_key;
 Pfpoint32_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pfpoint32) "_acc_add", a, pd, val);
 v = P_FPOINT2FLOAT64(*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if ( (v > 0 && a->psum > PDCI_LARGE_POS_DBL) || (v < 0 && a->psum < PDCI_LARGE_NEG_DBL) ) {
 Pfpoint32_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pfpoint32_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pfpoint32_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pfpoint32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfpoint32) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "fpoint32";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pfpoint32_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pfpoint32_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10.5I8f\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pfpoint32_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10.5I8f\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pfpoint32_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %.5I8f", what, a->min);
 sfprintf(outstr, " max %.5I8f", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pfpoint32_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10.5I8f", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfpoint32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfpoint32_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst,Pfpoint32_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pfpoint32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfpoint32) "_acc_report2xml_io called" ); Pfpoint32_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pfpoint32), PDCI_MacroArg2String(Pfpoint32)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pfpoint32)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pfpoint32_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%.5I8f", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%.5I8f", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pfpoint32_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%.5I8f", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pfpoint32));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfpoint32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfpoint32_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pfpoint32_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint32) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pfpoint32_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
typedef struct Pufpoint32_dt_key_s {
 Pfloat64 val;
 Puint64 cnt;
 }
 Pufpoint32_dt_key_t;
 typedef struct Pufpoint32_dt_elt_s {
 Pufpoint32_dt_key_t key;
 Dtlink_t link;
 }
 Pufpoint32_dt_elt_t;
 int Pufpoint32_dt_elt_oset_cmp(Dt_t *dt, Pufpoint32_dt_key_t *a, Pufpoint32_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pufpoint32_dt_elt_set_cmp(Dt_t *dt, Pufpoint32_dt_key_t *a, Pufpoint32_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pufpoint32_dt_elt_make(Dt_t *dt, Pufpoint32_dt_elt_t *a, Dtdisc_t *disc) {
 Pufpoint32_dt_elt_t *b;
 if ((b = oldof(0, Pufpoint32_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pufpoint32_dt_elt_free(Dt_t *dt, Pufpoint32_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pufpoint32_acc_dt_set_disc = {
 DTOFFSET(Pufpoint32_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pufpoint32_dt_elt_t, link), (Dtmake_f)Pufpoint32_dt_elt_make, (Dtfree_f)Pufpoint32_dt_elt_free, (Dtcompar_f)Pufpoint32_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pufpoint32_acc_dt_oset_disc = {
 DTOFFSET(Pufpoint32_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pufpoint32_dt_elt_t, link), (Dtmake_f)Pufpoint32_dt_elt_make, (Dtfree_f)Pufpoint32_dt_elt_free, (Dtcompar_f)Pufpoint32_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pufpoint32_acc_init(P_t *pads, Pufpoint32_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint32) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pufpoint32_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pufpoint32_acc_reset(P_t *pads, Pufpoint32_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint32) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pufpoint32_acc_cleanup(P_t *pads, Pufpoint32_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint32) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pufpoint32_acc_fold_psum(Pufpoint32_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pufpoint32_acc_avg(P_t *pads, Pufpoint32_acc *a) {
 Pufpoint32_acc_fold_psum(a);
 return a->avg;
 }
 Perror_t Pufpoint32_acc_add(P_t *pads, Pufpoint32_acc *a, const Pbase_pd *pd, const Pufpoint32 *val) {
 Pfloat64 v;
 Pufpoint32_dt_elt_t insert_elt;
 Pufpoint32_dt_key_t lookup_key;
 Pufpoint32_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pufpoint32) "_acc_add", a, pd, val);
 v = P_FPOINT2FLOAT64(*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if ( (v > 0 && a->psum > PDCI_LARGE_POS_DBL) || (v < 0 && a->psum < PDCI_LARGE_NEG_DBL) ) {
 Pufpoint32_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pufpoint32_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pufpoint32_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pufpoint32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pufpoint32) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "ufpoint32";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pufpoint32_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pufpoint32_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10.5I8f\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pufpoint32_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10.5I8f\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pufpoint32_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %.5I8f", what, a->min);
 sfprintf(outstr, " max %.5I8f", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pufpoint32_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10.5I8f", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pufpoint32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pufpoint32_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst,Pufpoint32_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pufpoint32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pufpoint32) "_acc_report2xml_io called" ); Pufpoint32_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pufpoint32), PDCI_MacroArg2String(Pufpoint32)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pufpoint32)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pufpoint32_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%.5I8f", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%.5I8f", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pufpoint32_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%.5I8f", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pufpoint32));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pufpoint32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pufpoint32_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pufpoint32_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint32) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pufpoint32_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
typedef struct Pfpoint64_dt_key_s {
 Pfloat64 val;
 Puint64 cnt;
 }
 Pfpoint64_dt_key_t;
 typedef struct Pfpoint64_dt_elt_s {
 Pfpoint64_dt_key_t key;
 Dtlink_t link;
 }
 Pfpoint64_dt_elt_t;
 int Pfpoint64_dt_elt_oset_cmp(Dt_t *dt, Pfpoint64_dt_key_t *a, Pfpoint64_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pfpoint64_dt_elt_set_cmp(Dt_t *dt, Pfpoint64_dt_key_t *a, Pfpoint64_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pfpoint64_dt_elt_make(Dt_t *dt, Pfpoint64_dt_elt_t *a, Dtdisc_t *disc) {
 Pfpoint64_dt_elt_t *b;
 if ((b = oldof(0, Pfpoint64_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pfpoint64_dt_elt_free(Dt_t *dt, Pfpoint64_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pfpoint64_acc_dt_set_disc = {
 DTOFFSET(Pfpoint64_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfpoint64_dt_elt_t, link), (Dtmake_f)Pfpoint64_dt_elt_make, (Dtfree_f)Pfpoint64_dt_elt_free, (Dtcompar_f)Pfpoint64_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pfpoint64_acc_dt_oset_disc = {
 DTOFFSET(Pfpoint64_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfpoint64_dt_elt_t, link), (Dtmake_f)Pfpoint64_dt_elt_make, (Dtfree_f)Pfpoint64_dt_elt_free, (Dtcompar_f)Pfpoint64_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pfpoint64_acc_init(P_t *pads, Pfpoint64_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint64) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pfpoint64_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pfpoint64_acc_reset(P_t *pads, Pfpoint64_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint64) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pfpoint64_acc_cleanup(P_t *pads, Pfpoint64_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint64) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pfpoint64_acc_fold_psum(Pfpoint64_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pfpoint64_acc_avg(P_t *pads, Pfpoint64_acc *a) {
 Pfpoint64_acc_fold_psum(a);
 return a->avg;
 }
 Perror_t Pfpoint64_acc_add(P_t *pads, Pfpoint64_acc *a, const Pbase_pd *pd, const Pfpoint64 *val) {
 Pfloat64 v;
 Pfpoint64_dt_elt_t insert_elt;
 Pfpoint64_dt_key_t lookup_key;
 Pfpoint64_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pfpoint64) "_acc_add", a, pd, val);
 v = P_FPOINT2FLOAT64(*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if ( (v > 0 && a->psum > PDCI_LARGE_POS_DBL) || (v < 0 && a->psum < PDCI_LARGE_NEG_DBL) ) {
 Pfpoint64_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pfpoint64_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pfpoint64_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pfpoint64_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfpoint64) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "fpoint64";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pfpoint64_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pfpoint64_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10.5I8f\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pfpoint64_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10.5I8f\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pfpoint64_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %.5I8f", what, a->min);
 sfprintf(outstr, " max %.5I8f", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pfpoint64_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10.5I8f", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfpoint64_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfpoint64_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst,Pfpoint64_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pfpoint64_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfpoint64) "_acc_report2xml_io called" ); Pfpoint64_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pfpoint64), PDCI_MacroArg2String(Pfpoint64)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pfpoint64)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pfpoint64_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%.5I8f", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%.5I8f", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pfpoint64_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%.5I8f", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pfpoint64));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfpoint64_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfpoint64_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pfpoint64_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfpoint64) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pfpoint64_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
typedef struct Pufpoint64_dt_key_s {
 Pfloat64 val;
 Puint64 cnt;
 }
 Pufpoint64_dt_key_t;
 typedef struct Pufpoint64_dt_elt_s {
 Pufpoint64_dt_key_t key;
 Dtlink_t link;
 }
 Pufpoint64_dt_elt_t;
 int Pufpoint64_dt_elt_oset_cmp(Dt_t *dt, Pufpoint64_dt_key_t *a, Pufpoint64_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pufpoint64_dt_elt_set_cmp(Dt_t *dt, Pufpoint64_dt_key_t *a, Pufpoint64_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pufpoint64_dt_elt_make(Dt_t *dt, Pufpoint64_dt_elt_t *a, Dtdisc_t *disc) {
 Pufpoint64_dt_elt_t *b;
 if ((b = oldof(0, Pufpoint64_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pufpoint64_dt_elt_free(Dt_t *dt, Pufpoint64_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pufpoint64_acc_dt_set_disc = {
 DTOFFSET(Pufpoint64_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pufpoint64_dt_elt_t, link), (Dtmake_f)Pufpoint64_dt_elt_make, (Dtfree_f)Pufpoint64_dt_elt_free, (Dtcompar_f)Pufpoint64_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pufpoint64_acc_dt_oset_disc = {
 DTOFFSET(Pufpoint64_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pufpoint64_dt_elt_t, link), (Dtmake_f)Pufpoint64_dt_elt_make, (Dtfree_f)Pufpoint64_dt_elt_free, (Dtcompar_f)Pufpoint64_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pufpoint64_acc_init(P_t *pads, Pufpoint64_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint64) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pufpoint64_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pufpoint64_acc_reset(P_t *pads, Pufpoint64_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint64) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pufpoint64_acc_cleanup(P_t *pads, Pufpoint64_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint64) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pufpoint64_acc_fold_psum(Pufpoint64_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pufpoint64_acc_avg(P_t *pads, Pufpoint64_acc *a) {
 Pufpoint64_acc_fold_psum(a);
 return a->avg;
 }
 Perror_t Pufpoint64_acc_add(P_t *pads, Pufpoint64_acc *a, const Pbase_pd *pd, const Pufpoint64 *val) {
 Pfloat64 v;
 Pufpoint64_dt_elt_t insert_elt;
 Pufpoint64_dt_key_t lookup_key;
 Pufpoint64_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pufpoint64) "_acc_add", a, pd, val);
 v = P_FPOINT2FLOAT64(*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if ( (v > 0 && a->psum > PDCI_LARGE_POS_DBL) || (v < 0 && a->psum < PDCI_LARGE_NEG_DBL) ) {
 Pufpoint64_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pufpoint64_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pufpoint64_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pufpoint64_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pufpoint64) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "ufpoint64";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pufpoint64_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pufpoint64_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10.5I8f\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pufpoint64_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %10.5I8f\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pufpoint64_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %.5I8f", what, a->min);
 sfprintf(outstr, " max %.5I8f", a->max);
 sfprintf(outstr, " avg %.3I8f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pufpoint64_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %10.5I8f", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pufpoint64_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pufpoint64_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst,Pufpoint64_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pufpoint64_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pufpoint64) "_acc_report2xml_io called" ); Pufpoint64_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pufpoint64), PDCI_MacroArg2String(Pufpoint64)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pufpoint64)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pufpoint64_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%.5I8f", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%.5I8f", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pufpoint64_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%.5I8f", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pufpoint64));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pufpoint64_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pufpoint64_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pufpoint64_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pufpoint64) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pufpoint64_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }

typedef struct Pfloat32_dt_key_s {
 Pfloat64 val;
 Puint64 cnt;
 }
 Pfloat32_dt_key_t;
 typedef struct Pfloat32_dt_elt_s {
 Pfloat32_dt_key_t key;
 Dtlink_t link;
 }
 Pfloat32_dt_elt_t;
 int Pfloat32_dt_elt_oset_cmp(Dt_t *dt, Pfloat32_dt_key_t *a, Pfloat32_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pfloat32_dt_elt_set_cmp(Dt_t *dt, Pfloat32_dt_key_t *a, Pfloat32_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pfloat32_dt_elt_make(Dt_t *dt, Pfloat32_dt_elt_t *a, Dtdisc_t *disc) {
 Pfloat32_dt_elt_t *b;
 if ((b = oldof(0, Pfloat32_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pfloat32_dt_elt_free(Dt_t *dt, Pfloat32_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pfloat32_acc_dt_set_disc = {
 DTOFFSET(Pfloat32_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfloat32_dt_elt_t, link), (Dtmake_f)Pfloat32_dt_elt_make, (Dtfree_f)Pfloat32_dt_elt_free, (Dtcompar_f)Pfloat32_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pfloat32_acc_dt_oset_disc = {
 DTOFFSET(Pfloat32_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfloat32_dt_elt_t, link), (Dtmake_f)Pfloat32_dt_elt_make, (Dtfree_f)Pfloat32_dt_elt_free, (Dtcompar_f)Pfloat32_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pfloat32_acc_init(P_t *pads, Pfloat32_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfloat32) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pfloat32_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pfloat32_acc_reset(P_t *pads, Pfloat32_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfloat32) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pfloat32_acc_cleanup(P_t *pads, Pfloat32_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfloat32) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pfloat32_acc_fold_psum(Pfloat32_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pfloat32_acc_avg(P_t *pads, Pfloat32_acc *a) {
 Pfloat32_acc_fold_psum(a);
 return a->avg;
 }
 Perror_t Pfloat32_acc_add(P_t *pads, Pfloat32_acc *a, const Pbase_pd *pd, const Pfloat32 *val) {
 Pfloat64 v;
 Pfloat32_dt_elt_t insert_elt;
 Pfloat32_dt_key_t lookup_key;
 Pfloat32_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pfloat32) "_acc_add", a, pd, val);
 v = (*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if ( (v > 0 && (v > PDCI_LARGE_POS_DBL || a->psum > PDCI_LARGE_POS_DBL)) || (v < 0 && (v < PDCI_LARGE_NEG_DBL || a->psum < PDCI_LARGE_NEG_DBL)) ) {
 Pfloat32_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pfloat32_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pfloat32_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pfloat32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfloat32) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "float32";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pfloat32_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pfloat32_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %I810.5f\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %I88.3f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pfloat32_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %I810.5f\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pfloat32_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %I8.5f", what, a->min);
 sfprintf(outstr, " max %I8.5f", a->max);
 sfprintf(outstr, " avg %I8.3f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %I8.3f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %I8.2f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pfloat32_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %I810.5f", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %I88.3f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %I88.3f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfloat32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfloat32_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Pfloat32_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pfloat32_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfloat32) "_acc_report2xml_io called" ); Pfloat32_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pfloat32), PDCI_MacroArg2String(Pfloat32)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pfloat32)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pfloat32_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%.5I8f", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%.5I8f", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pfloat32_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%I810.5f", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pfloat32));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfloat32_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfloat32_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pfloat32_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfloat32) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pfloat32_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }
typedef struct Pfloat64_dt_key_s {
 Pfloat64 val;
 Puint64 cnt;
 }
 Pfloat64_dt_key_t;
 typedef struct Pfloat64_dt_elt_s {
 Pfloat64_dt_key_t key;
 Dtlink_t link;
 }
 Pfloat64_dt_elt_t;
 int Pfloat64_dt_elt_oset_cmp(Dt_t *dt, Pfloat64_dt_key_t *a, Pfloat64_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a == b) {
 return 0;
 }
 if (a->cnt == b->cnt) {
 return (a->val < b->val) ? -1 : 1;
 }
 return (a->cnt > b->cnt) ? -1 : 1;
 }
 int Pfloat64_dt_elt_set_cmp(Dt_t *dt, Pfloat64_dt_key_t *a, Pfloat64_dt_key_t *b, Dtdisc_t *disc) {
 NoP(dt);
 NoP(disc);
 if (a->val == b->val) {
 return 0;
 }
 return 1;
 }
 void* Pfloat64_dt_elt_make(Dt_t *dt, Pfloat64_dt_elt_t *a, Dtdisc_t *disc) {
 Pfloat64_dt_elt_t *b;
 if ((b = oldof(0, Pfloat64_dt_elt_t, 1, 0))) {
 b->key.val = a->key.val;
 b->key.cnt = a->key.cnt;
 }
 return b;
 }
 void Pfloat64_dt_elt_free(Dt_t *dt, Pfloat64_dt_elt_t *a, Dtdisc_t *disc) {
 free(a);
 }
 static Dtdisc_t Pfloat64_acc_dt_set_disc = {
 DTOFFSET(Pfloat64_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfloat64_dt_elt_t, link), (Dtmake_f)Pfloat64_dt_elt_make, (Dtfree_f)Pfloat64_dt_elt_free, (Dtcompar_f)Pfloat64_dt_elt_set_cmp, NiL, NiL, NiL };
 static Dtdisc_t Pfloat64_acc_dt_oset_disc = {
 DTOFFSET(Pfloat64_dt_elt_t, key), sizeof(Pfloat64), DTOFFSET(Pfloat64_dt_elt_t, link), (Dtmake_f)Pfloat64_dt_elt_make, (Dtfree_f)Pfloat64_dt_elt_free, (Dtcompar_f)Pfloat64_dt_elt_oset_cmp, NiL, NiL, NiL };
 Perror_t Pfloat64_acc_init(P_t *pads, Pfloat64_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfloat64) "_acc_init", a);
 memset((void*)a, 0, sizeof(*a));
 if (!(a->dict = dtopen(&Pfloat64_acc_dt_set_disc, Dtset))) {
 return P_ERR;
 }
 a->max2track = pads->disc->acc_max2track;
 a->max2rep = pads->disc->acc_max2rep;
 a->pcnt2rep = pads->disc->acc_pcnt2rep;
 return P_OK;
 }
 Perror_t Pfloat64_acc_reset(P_t *pads, Pfloat64_acc *a) {
 Dt_t *dict;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfloat64) "_acc_reset", a);
 if (!(dict = a->dict)) {
 return P_ERR;
 }
 memset((void*)a, 0, sizeof(*a));
 dtclear(dict);
 a->dict = dict;
 return P_OK;
 }
 Perror_t Pfloat64_acc_cleanup(P_t *pads, Pfloat64_acc *a) {
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfloat64) "_acc_cleanup", a);
 if (a->dict) {
 dtclose(a->dict);
 a->dict = 0;
 }
 return P_OK;
 }
 void Pfloat64_acc_fold_psum(Pfloat64_acc *a) {
 Pfloat64 pavg, navg;
 Puint64 recent = a->good - a->fold;
 if (recent == 0) {
 return;
 }
 pavg = a->psum / (Pfloat64)recent;
 navg = ((a->avg * a->fold) + (pavg * recent))/(Pfloat64)a->good;
 a->avg = navg;
 a->psum = 0;
 a->fold += recent;
 }
 Pfloat64 Pfloat64_acc_avg(P_t *pads, Pfloat64_acc *a) {
 Pfloat64_acc_fold_psum(a);
 return a->avg;
 }
 Perror_t Pfloat64_acc_add(P_t *pads, Pfloat64_acc *a, const Pbase_pd *pd, const Pfloat64 *val) {
 Pfloat64 v;
 Pfloat64_dt_elt_t insert_elt;
 Pfloat64_dt_key_t lookup_key;
 Pfloat64_dt_elt_t *tmp1;
 PDCI_DISC_3P_CHECKS( PDCI_MacroArg2String(Pfloat64) "_acc_add", a, pd, val);
 v = (*val);
 if (!a->dict) {
 return P_ERR;
 }
 if (pd->errCode != P_NO_ERR) {
 (a->bad)++;
 return P_OK;
 }
 if ( (v > 0 && (v > PDCI_LARGE_POS_DBL || a->psum > PDCI_LARGE_POS_DBL)) || (v < 0 && (v < PDCI_LARGE_NEG_DBL || a->psum < PDCI_LARGE_NEG_DBL)) ) {
 Pfloat64_acc_fold_psum(a);
 }
 a->psum += v;
 (a->good)++;
 if (a->good == 1) {
 a->min = a->max = v;
 }
 else if (v < a->min) {
 a->min = v;
 }
 else if (v > a->max) {
 a->max = v;
 }
 if (v == 0 || dtsize(a->dict) < a->max2track) {
 insert_elt.key.val = v;
 insert_elt.key.cnt = 0;
 if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
 P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
 return P_ERR;
 }
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 else {
 lookup_key.val = v;
 lookup_key.cnt = 0;
 if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
 (tmp1->key.cnt)++;
 (a->tracked)++;
 }
 }
 return P_OK;
 }
 Perror_t Pfloat64_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst, Pfloat64_acc *a) {
 int i, sz, rp;
 Puint64 cnt_sum;
 Pfloat64 cnt_sum_pcnt;
 Pfloat64 bad_pcnt;
 Pfloat64 track_pcnt;
 Pfloat64 elt_pcnt;
 Void_t *velt;
 Pfloat64_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfloat64) "_acc_report2io called" );
 if (!prefix || *prefix == 0) {
 prefix = "<top>";
 }
 if (!what) {
 what = "float64";
 }
 PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
 Pfloat64_acc_fold_psum(a);
 sz = dtsize(a->dict);
 rp = (sz < a->max2rep) ? sz : a->max2rep;
 if (sz == 0) {
 sfprintf(outstr, "(No %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1 && a->bad == 0) {
 elt = (Pfloat64_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %I810.5f\n", a->good, what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 if (a->good == 0) {
 bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
 }
 else {
 bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
 }
 sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %I88.3f\n", a->good, a->bad, bad_pcnt);
 if (a->good == 0) {
 sfprintf(outstr, "(No good %s values.)\n", what);
 return P_OK;
 }
 if (sz == 1) {
 elt = (Pfloat64_dt_elt_t*)dtfirst(a->dict);
 sfprintf(outstr, "For good %s values, 100 pcnt identical: %I810.5f\n", what, elt->key.val);
 dtnext(a->dict, 0);
 return P_OK;
 }
 dtdisc(a->dict, &Pfloat64_acc_dt_oset_disc, DT_SAMEHASH);
 dtmethod(a->dict, Dtoset);
 sfprintf(outstr, "  Characterizing %s values:  min %I8.5f", what, a->min);
 sfprintf(outstr, " max %I8.5f", a->max);
 sfprintf(outstr, " avg %I8.3f\n", a->avg);
 sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
 if (sz == a->max2track && a->good > a->tracked) {
 track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
 sfprintf(outstr, "        (* hit tracking limit, tracked %I8.3f pcnt of all values *) \n", track_pcnt);
 }
 for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
 velt && i < a->max2rep;
 velt = dtnext(a->dict, velt), i++) {
 if (cnt_sum_pcnt >= a->pcnt2rep) {
 sfprintf(outstr, " [... %d of top %d values not reported due to %I8.2f pcnt limit on reported values ...]\n", rp-i, rp, a->pcnt2rep);
 break;
 }
 elt = (Pfloat64_dt_elt_t*)velt;
 elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
 sfprintf(outstr, "        val: %I810.5f", elt->key.val);
 sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %I88.3f\n", elt->key.cnt, elt_pcnt);
 cnt_sum += elt->key.cnt;
 cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
 }
 dtnext(a->dict, 0);
 sfprintf(outstr, ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
 sfprintf(outstr, "        SUMMING         count: %10llu  pcnt-of-good-vals: %I88.3f\n", cnt_sum, cnt_sum_pcnt);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfloat64_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfloat64_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Pfloat64_acc *a) {
 int i, sz, rp;
 Pfloat64 track_pcnt;
 Void_t *velt;
 Pfloat64_dt_elt_t *elt;
 P_TRACE(pads->disc, PDCI_MacroArg2String(Pfloat64) "_acc_report2xml_io called" ); Pfloat64_acc_fold_psum(a); sz = dtsize(a->dict); rp = (sz < a->max2rep) ? sz : a->max2rep; if (sz == 0) { PDCI_indent(outstr, nst);
 sfprintf(outstr, "<%s><none/></%s>\n", PDCI_MacroArg2String(Pfloat64), PDCI_MacroArg2String(Pfloat64)); return P_OK; } PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<%s>\n", PDCI_MacroArg2String(Pfloat64)); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<good>%llu", a->good);
 sfprintf(outstr, "</good>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<bad>%llu", a->bad);
 sfprintf(outstr, "</bad>\n"); dtdisc(a->dict, &Pfloat64_acc_dt_oset_disc, DT_SAMEHASH); dtmethod(a->dict, Dtoset); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<avg>%.3I8f</avg>\n", a->avg); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<min>%.5I8f", a->min);
 sfprintf(outstr, "</min>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<max>%.5I8f", a->max);
 sfprintf(outstr, "</max>\n"); if (sz!=0){ PDCI_indent(outstr, nst++);
 sfprintf(outstr, "<distribution>\n"); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<top>%d</top>", rp);
 sfprintf(outstr, "<distinct>%d</distinct>\n", sz); if (sz == a->max2track && a->good > a->tracked) { track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good); PDCI_indent(outstr, nst);
 sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt); }; for (i = 0, velt = dtfirst(a->dict); velt && i < a->max2rep; velt = dtnext(a->dict, velt), i++) { elt = (Pfloat64_dt_elt_t*)velt; PDCI_indent(outstr, nst);
 sfprintf(outstr, "<item>");
 sfprintf(outstr, "<val>%I810.5f", elt->key.val);
 sfprintf(outstr, "</val>");
 sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
 sfprintf(outstr, "</item>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</distribution>\n"); } PDCI_indent(outstr, --nst);
 sfprintf(outstr, "</%s>\n", PDCI_MacroArg2String(Pfloat64));
 dtnext(a->dict, 0);
 dtmethod(a->dict, Dtset);
 dtdisc(a->dict, &Pfloat64_acc_dt_set_disc, DT_SAMEHASH);
 return P_OK;
 }
 Perror_t Pfloat64_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pfloat64_acc *a) {
 Sfio_t *tmpstr;
 Perror_t res;
 PDCI_DISC_1P_CHECKS( PDCI_MacroArg2String(Pfloat64) "_acc_report", a);
 if (!pads->disc->error_fn) {
 return P_OK;
 }
 if (!(tmpstr = sfstropen ())) {
 return P_ERR;
 }
 res = Pfloat64_acc_report2io(pads, tmpstr, prefix, what, nst, a);
 if (res == P_OK) {
 pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
 }
 sfstrclose (tmpstr);
 return res;
 }

#if P_CONFIG_ACCUM_FUNCTIONS > 0

typedef struct PDCI_string_dt_key_s {
  Puint64      cnt;
  size_t       len;
  char        *str;
} PDCI_string_dt_key_t;

typedef struct PDCI_string_dt_elt_s {
  PDCI_string_dt_key_t  key;
  Dtlink_t              link;
  char                  buf[1];
} PDCI_string_dt_elt_t;

unsigned int
PDCI_string_dt_elt_hash(Dt_t *dt, Void_t *key, Dtdisc_t *disc)
{
  PDCI_string_dt_key_t *k = (PDCI_string_dt_key_t*)key;
  int len = k->len;
  NoP(dt);
  NoP(disc);
  if (len == 0) return 0;
  return dtstrhash(0, k->str, len);
}

/*
 * Order set comparison function: only used at the end to rehash
 * the (formerly unordered) set.  Since same string only occurs
 * once, ptr equivalence produces key equivalence.
 *   different keys: sort keys by cnt field, break tie with string vals
 */
int
PDCI_string_dt_elt_oset_cmp(Dt_t *dt, PDCI_string_dt_key_t *a, PDCI_string_dt_key_t *b, Dtdisc_t *disc)
{
  size_t min_len;
  int res;
  NoP(dt);
  NoP(disc);
  if (a == b) { /* same key */
    return 0;
  }
  if (a->cnt == b->cnt) { /* same count, so do lexicographic comparison */
    if (a->len == 0) return -1;
    if (b->len == 0) return 1;
    min_len = (a->len < b->len) ? a->len : b->len;
    if ((res = strncmp(a->str, b->str, min_len))) {
      return res;
    }
    return (a->len < b->len) ? -1 : 1;
  }
  /* different counts */
  return (a->cnt > b->cnt) ? -1 : 1;
}

/*
 * Unordered set comparison function: all that matters is string equality
 * (0 => equal, 1 => not equal)
 */
int
PDCI_string_dt_elt_set_cmp(Dt_t *dt, PDCI_string_dt_key_t *a, PDCI_string_dt_key_t *b, Dtdisc_t *disc)
{
  NoP(dt);
  NoP(disc);
  if (a->len != b->len) return 1;
  if (a->len == 0) return 0;
  return strncmp(a->str, b->str, a->len);
}

void*
PDCI_string_dt_elt_make(Dt_t *dt, PDCI_string_dt_elt_t *a, Dtdisc_t *disc)
{
  PDCI_string_dt_elt_t *b;
  NoP(dt);
  NoP(disc);
  if ((b = oldof(0, PDCI_string_dt_elt_t, 1, a->key.len))) {
    memcpy(b->buf, a->key.str, a->key.len);
    b->key.cnt = a->key.cnt;
    b->key.len = a->key.len;
    b->key.str = b->buf;
  }
  return b;
}

void
PDCI_string_dt_elt_free(Dt_t *dt, PDCI_string_dt_elt_t *a, Dtdisc_t *disc)
{
  free(a);
}

static Dtdisc_t PDCI_string_acc_dt_set_disc = {
  DTOFFSET(PDCI_string_dt_elt_t, key),     /* key     */
  0,				           /* size    */
  DTOFFSET(PDCI_string_dt_elt_t, link),    /* link    */
  (Dtmake_f)PDCI_string_dt_elt_make,       /* makef   */
  (Dtfree_f)PDCI_string_dt_elt_free,       /* freef */
  (Dtcompar_f)PDCI_string_dt_elt_set_cmp,  /* comparf */
  (Dthash_f)PDCI_string_dt_elt_hash,       /* hashf   */
  NiL,				           /* memoryf */
  NiL				           /* eventf  */
};

static Dtdisc_t PDCI_string_acc_dt_oset_disc = {
  DTOFFSET(PDCI_string_dt_elt_t, key),     /* key     */
  0,				           /* size    */
  DTOFFSET(PDCI_string_dt_elt_t, link),    /* link    */
  (Dtmake_f)PDCI_string_dt_elt_make,       /* makef   */
  (Dtfree_f)PDCI_string_dt_elt_free,       /* freef */
  (Dtcompar_f)PDCI_string_dt_elt_oset_cmp, /* comparf */
  (Dthash_f)PDCI_string_dt_elt_hash,       /* hashf   */
  NiL,				           /* memoryf */
  NiL				           /* eventf  */
};

Perror_t
Pstring_acc_init(P_t *pads, Pstring_acc *a)
{
  PDCI_DISC_1P_CHECKS("Pstring_acc_init", a);
  if (!(a->dict = dtopen(&PDCI_string_acc_dt_set_disc, Dtset))) {
    return P_ERR;
  }
  a->max2track  = pads->disc->acc_max2track;
  a->max2rep    = pads->disc->acc_max2rep;
  a->pcnt2rep   = pads->disc->acc_pcnt2rep;
  a->tracked    = 0;
  return Puint32_acc_init(pads, &(a->len_accum));
}

Perror_t
Pstring_acc_reset(P_t *pads, Pstring_acc *a)
{
  PDCI_DISC_1P_CHECKS("Pstring_acc_reset", a);
  if (!a->dict) {
    return P_ERR;
  }
  dtclear(a->dict);
  a->tracked = 0;
  return Puint32_acc_reset(pads, &(a->len_accum));
}

Perror_t
Pstring_acc_cleanup(P_t *pads, Pstring_acc *a)
{
  PDCI_DISC_1P_CHECKS("Pstring_acc_cleanup", a);
  if (a->dict) {
    dtclose(a->dict);
    a->dict = 0;
  }
  return Puint32_acc_cleanup(pads, &(a->len_accum));
}

Perror_t
Pstring_acc_add(P_t *pads, Pstring_acc *a, const Pbase_pd *pd, const Pstring *val)
{
  Puint32 val_len;
  PDCI_string_dt_elt_t  insert_elt;
  PDCI_string_dt_key_t  lookup_key;
  PDCI_string_dt_elt_t  *tmp1;
  PDCI_DISC_3P_CHECKS("Pstring_acc_add", a, pd, val);
  if (!a->dict) {
    return P_ERR;
  }
  val_len = val->len;
  if (P_ERR == Puint32_acc_add(pads, &(a->len_accum), pd, &val_len)) {
    return P_ERR;
  }
  if (pd->errCode != P_NO_ERR) {
    return P_OK;
  }
  if (val->len == 0 || dtsize(a->dict) < a->max2track) {
#if 0
    if (val->len == 0) 
      P_WARN(pads->disc, "XXX_REMOVE val->len 0");
    else
      P_WARN3(pads->disc, "XXX_REMOVE val->len %lu string[%.*s]", (unsigned long)val->len, val->len, val->str);
#endif
    insert_elt.key.str = val->str;
    insert_elt.key.len = val->len;
    insert_elt.key.cnt = 0;
    if (!(tmp1 = dtinsert(a->dict, &insert_elt))) {
      P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
      return P_ERR;
    }
    (tmp1->key.cnt)++;
    (a->tracked)++;
  } else {
#if 0
    if (val->len == 0) 
      P_WARN(pads->disc, "XXX_REMOVE val->len 0 (max2track hit)");
    else
      P_WARN3(pads->disc, "XXX_REMOVE val->len %lu string[%.*s] (max2track hit)", (unsigned long)val->len, val->len, val->str);
#endif
    lookup_key.str = val->str;
    lookup_key.len = val->len;
    lookup_key.cnt = 0;
    if ((tmp1 = dtmatch(a->dict, &lookup_key))) {
      (tmp1->key.cnt)++;
      (a->tracked)++;
    }
  }
  return P_OK;
}

Perror_t
Pstring_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst,
		      Pstring_acc *a)
{
  size_t                 pad;
  int                    i, sz, len_sz, rp;
  Puint64             cnt_sum;
  Pfloat64               cnt_sum_pcnt;
  Pfloat64               track_pcnt;
  Pfloat64               elt_pcnt;
  Void_t                 *velt;
  PDCI_string_dt_elt_t   *elt;

  P_TRACE(pads->disc, "Pstring_acc_report2io called");
  if (!prefix || *prefix == 0) {
    prefix = "<top>";
  }
  if (!what) {
    what = "string";
  }
  PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
  sz = dtsize(a->dict);
  len_sz = dtsize(a->len_accum.dict);
  rp = (sz < a->max2rep) ? sz : a->max2rep;
  if (len_sz == 0) { /* no values accumulated */
    sfprintf(outstr, "(No string values.)\n");
    return P_OK;
  }
  if (sz == 1 && a->len_accum.bad == 0) {
    elt = (PDCI_string_dt_elt_t*)dtfirst(a->dict);
    /*    sfprintf(outstr, "%llu string values, 100 pcnt good, 100 pcnt identical (length %8lu): %-.*s\n",
	     a->len_accum.good,
	     (unsigned long)elt->key.len, elt->key.len+2, P_qfmt_cstr_n(elt->key.str, elt->key.len)); */
         sfprintf(outstr, "%llu string values, 100 pcnt good, 100 pcnt identical (length %8lu): %s\n",
	     a->len_accum.good, (unsigned long)elt->key.len, P_qfmt_cstr_n(elt->key.str, elt->key.len)); 
    dtnext(a->dict, 0); /* discard any iterator state */
    return P_OK;
  }
  if (P_ERR == Puint32_acc_report2io(pads, outstr, "String lengths", "string length", -1, &(a->len_accum))) {
    return P_ERR;
  }
  if (a->len_accum.good == 0) {
    sfprintf(outstr, "(No good string values.)\n");
    return P_OK;
  }
  /* check for 100% identical values */
  if (sz == 1) {
    elt = (PDCI_string_dt_elt_t*)dtfirst(a->dict);
    sfprintf(outstr, "For good string values, 100 pcnt identical (length %lu): %-.*s\n",
	     (unsigned long)elt->key.len, elt->key.len+2, P_qfmt_cstr_n(elt->key.str, elt->key.len));
    dtnext(a->dict, 0); /* discard any iterator state */
    return P_OK;
  }
  /* rehash tree to get keys ordered by count */
  dtdisc(a->dict, &PDCI_string_acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */
  sfprintf(outstr, "\n  Characterizing string values:\n");
  sfprintf(outstr, "    => distribution of top %d strings out of %d distinct strings:\n", rp, sz);
  if (sz == a->max2track && a->len_accum.good > a->tracked) {
    track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->len_accum.good);
    sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
  }
  for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
       velt && i < a->max2rep;
       velt = dtnext(a->dict, velt), i++) {
    if (cnt_sum_pcnt >= a->pcnt2rep) {
      sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n",
	       rp-i, rp, a->pcnt2rep);
      break;
    }
    elt = (PDCI_string_dt_elt_t*)velt;
    elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->len_accum.good);
    sfprintf(outstr, "        val: ");
    /*    sfprintf(outstr, "%-.*s", elt->key.len+2, P_qfmt_cstr_n(elt->key.str, elt->key.len)); */
    sfprintf(outstr, "%s", P_qfmt_cstr_n(elt->key.str, elt->key.len));
    sfprintf(outstr, "");
    pad = a->len_accum.max - elt->key.len;
    sfprintf(outstr, "%-.*s", pad, PDCI_spaces);
    sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
    cnt_sum += elt->key.cnt;
    cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->len_accum.good);
  }
  dtnext(a->dict, 0); /* discard any iterator state */
  sfprintf(outstr, ". . . . . . . .");
  pad = a->len_accum.max;
  sfprintf(outstr, "%-.*s", pad,
	   " . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .");
  sfprintf(outstr, " . . . . . . . . . . . . . . . . . . . . . . .\n");

  sfprintf(outstr, "        SUMMING");
  sfprintf(outstr, "%-.*s", pad, PDCI_spaces);
  sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", cnt_sum, cnt_sum_pcnt);
  /* revert to unordered set in case more inserts will occur after this report */
  dtmethod(a->dict, Dtset); /* change to unordered set */
  dtdisc(a->dict, &PDCI_string_acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */
  return P_OK;
}

Perror_t
Pstring_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Pstring_acc *a)
{
  int                    i, sz, len_sz, rp;
  Pfloat64               track_pcnt;
  Void_t                 *velt;
  PDCI_string_dt_elt_t   *elt;

  P_TRACE(pads->disc, "Pstring_acc_report2xml_io called");
  sz = dtsize(a->dict);
  len_sz = dtsize(a->len_accum.dict);
  rp = (sz < a->max2rep) ? sz : a->max2rep;
  if (len_sz == 0) { /* no values accumulated */
    PDCI_indent(outstr, nst);
    sfprintf(outstr, "<Pstring><none/></Pstring>\n");
    return P_OK;
  }
  PDCI_indent(outstr, nst++);
  sfprintf(outstr, "<Pstring>\n");
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<length>\n");
  if (P_ERR == Puint32_acc_report2xml_io(pads, outstr, nst+1, &(a->len_accum))) {
    return P_ERR;
  }
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "</length>\n");

  /* Apparently, string accumulators don't have good and bad fields; all are good? 
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<good>%llu", a->good);
  sfprintf(outstr, "</good>\n");
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<bad>%llu", a->bad);
  sfprintf(outstr, "</bad>\n"); */

  /* rehash tree to get keys ordered by count */
  dtdisc(a->dict, &PDCI_string_acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */

  if (sz!=0){
     PDCI_indent(outstr, nst++);
     sfprintf(outstr, "<distribution>\n");
     PDCI_indent(outstr, nst);
     sfprintf(outstr, "<top>%d</top>", rp);
     sfprintf(outstr, "<distinct>%d</distinct>\n", sz);

     if (sz == a->max2track && a->len_accum.good > a->tracked) {
       track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->len_accum.good);
       PDCI_indent(outstr, nst);
       sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt);
     }
     for (i = 0, velt = dtfirst(a->dict);
          velt && i < a->max2rep;
          velt = dtnext(a->dict, velt), i++) {
            elt = (PDCI_string_dt_elt_t*)velt;

            PDCI_indent(outstr, nst);
            sfprintf(outstr, "<item>");
            sfprintf(outstr, "<val>%s", P_qfmt_cstr_n(elt->key.str, elt->key.len));
            sfprintf(outstr, "</val>");
            sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
            sfprintf(outstr, "</item>\n");
     }
     PDCI_indent(outstr, --nst);
     sfprintf(outstr, "</distribution>\n");
  }
  PDCI_indent(outstr, --nst);
  sfprintf(outstr, "</Pstring>\n");

  dtnext(a->dict, 0); /* discard any iterator state */
  dtmethod(a->dict, Dtset); /* change to unordered set */
  dtdisc(a->dict, &PDCI_string_acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */
  return P_OK;
}

Perror_t
Pstring_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Pstring_acc *a)
{
  Sfio_t *tmpstr;
  Perror_t res;
  PDCI_DISC_1P_CHECKS("Pstring_acc_report", a);
  if (!pads->disc->error_fn) {
    return P_OK;
  }
  if (!(tmpstr = sfstropen ())) { 
    return P_ERR;
  }
  res = Pstring_acc_report2io(pads, tmpstr, prefix, what, nst, a);
  if (res == P_OK) {
    pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
  }
  sfstrclose (tmpstr);
  return res;
}

Perror_t Pip_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix,
			   const char *what, int nst, Puint32_acc *a)
{
  int                i, sz, rp;
  Puint64            cnt_sum;
  Pfloat64           bad_pcnt;
  Pfloat64           cnt_sum_pcnt;
  Pfloat64           track_pcnt;
  Pfloat64           elt_pcnt;
  Void_t            *velt;
  Puint32_dt_elt_t  *elt;
  const char        *xtra;

  P_TRACE(pads->disc, "Pip_acc_report2io called");
  if (!prefix || *prefix == 0) {
    prefix = "<top>";
  }
  if (!what) {
    what = "Pip";
  }
  xtra = "\
    ** N.B. IPs are reported using the Puint32 internal rep, and are also pretty-printed using the default Pip output format";
  PDCI_nst_prefix_what(outstr, &nst, prefix, what, xtra);
  Puint32_acc_fold_psum(a);
  sz = dtsize(a->dict);
  rp = (sz < a->max2rep) ? sz : a->max2rep;
  if (sz == 0) { /* no values accumulated */
    sfprintf(outstr, "(No %s values.)\n", what);
    return P_OK;
  }
  if (sz == 1 && a->bad == 0) {
    elt = (Puint32_dt_elt_t*)dtfirst(a->dict);
    sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10lu (%s)\n",
	     a->good, what, elt->key.val,
	     fmtip4(elt->key.val, -1));
    dtnext(a->dict, 0); /* discard any iterator state */
    return P_OK;
  }
  if (a->good == 0) {
    bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
  } else {
    bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
  }
  sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n",
	   a->good, a->bad, bad_pcnt);
  if (a->good == 0) {
    sfprintf(outstr, "(No good %s values.)\n", what);
    return P_OK;
  }
  /* check for 100% identical values */
  if (sz == 1) {
    elt = (Puint32_dt_elt_t*)dtfirst(a->dict);
    sfprintf(outstr, "For good %s values, 100 pcnt identical: %10lu (%s)\n",
	     what, elt->key.val,
	     fmtip4(elt->key.val, -1));
    dtnext(a->dict, 0); /* discard any iterator state */
    return P_OK;
  }
  dtdisc(a->dict,   &Puint32_acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */
  sfprintf(outstr, "  Characterizing %s values:  min %llu (%s)", what, a->min, fmtip4(a->min, -1));
  sfprintf(outstr, " max %llu (%s)", a->max, fmtip4(a->max, -1));
  {
    Puint32 rounded_down = (Puint32)a->avg;
    sfprintf(outstr, " avg rounded down to nearest Puint32: %lu (%s)\n", rounded_down, fmtip4(rounded_down, -1));
  }

  sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
  if (sz == a->max2track && a->good > a->tracked) {
    track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
    sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
  }
  for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
       velt && i < a->max2rep;
       velt = dtnext(a->dict, velt), i++) {
    if (cnt_sum_pcnt >= a->pcnt2rep) {
      sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n",
	       rp-i, rp, a->pcnt2rep);
      break;
    }
    elt = (Puint32_dt_elt_t*)velt;
    elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
    sfprintf(outstr, "        val: %10lu (%s)", elt->key.val, fmtip4(elt->key.val, -1));
    sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
    cnt_sum += elt->key.cnt;
    cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
  }
  dtnext(a->dict, 0); /* discard any iterator state */
  sfprintf(outstr,   ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
  sfprintf(outstr,   "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n",
	   cnt_sum, cnt_sum_pcnt);
  /* revert to unordered set in case more inserts will occur after this report */
  dtmethod(a->dict, Dtset); /* change to unordered set */
  dtdisc(a->dict,   &Puint32_acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */
  return P_OK;
}

Perror_t Pip_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Puint32_acc *a)
{
  int                i, sz, rp;
  Pfloat64           track_pcnt;
  Void_t            *velt;
  Puint32_dt_elt_t  *elt;

  P_TRACE(pads->disc, "Pip_acc_report2xml_io called");
  Puint32_acc_fold_psum(a);
  sz = dtsize(a->dict);
  rp = (sz < a->max2rep) ? sz : a->max2rep;
  if (sz == 0) { /* no values accumulated */
    PDCI_indent(outstr, nst);
    sfprintf(outstr, "<Pip><none/></Pip>\n");
    return P_OK;
  }

  PDCI_indent(outstr, nst++);
  sfprintf(outstr, "<Pip>\n");

  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<good>%llu", a->good);
  sfprintf(outstr, "</good>\n");
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<bad>%llu", a->bad);
  sfprintf(outstr, "</bad>\n");

  dtdisc(a->dict,   &Puint32_acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */

  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<min>%s", fmtip4(a->min, -1));
  sfprintf(outstr, "</min>\n");
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<max>%s", fmtip4(a->max, -1));
  sfprintf(outstr, "</max>\n");

  if (sz!=0){
     PDCI_indent(outstr, nst++);
     sfprintf(outstr, "<distribution>\n");
     PDCI_indent(outstr, nst);
     sfprintf(outstr, "<top>%d</top>", rp);
     sfprintf(outstr, "<distinct>%d</distinct>\n", sz);

     if (sz == a->max2track && a->good > a->tracked) {
       track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
       PDCI_indent(outstr, nst);
       sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt);
     }
     for (i = 0, velt = dtfirst(a->dict);
	  velt && i < a->max2rep;
	  velt = dtnext(a->dict, velt), i++) {
            elt = (Puint32_dt_elt_t*)velt;
            PDCI_indent(outstr, nst);
            sfprintf(outstr, "<item>");
            sfprintf(outstr, "<val>%s", fmtip4(elt->key.val,-1));
            sfprintf(outstr, "</val>");
            sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
            sfprintf(outstr, "</item>\n");
     }
     PDCI_indent(outstr, --nst);
     sfprintf(outstr, "</distribution>\n");
  }
  PDCI_indent(outstr, --nst);
  sfprintf(outstr, "</Pip>\n");

  dtnext(a->dict, 0); /* discard any iterator state */
  /* revert to unordered set in case more inserts will occur after this report */
  dtmethod(a->dict, Dtset); /* change to unordered set */
  dtdisc(a->dict,   &Puint32_acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */
  return P_OK;
}

Perror_t Pip_acc_report(P_t *pads, const char *prefix, const char *what,
			int nst, Puint32_acc *a)
{
  Sfio_t *tmpstr;
  Perror_t res;
  PDCI_DISC_1P_CHECKS("Pip_acc_report", a);
  if (!pads->disc->error_fn) {
    return P_OK;
  }
  if (!(tmpstr = sfstropen ())) { 
    return P_ERR;
  }
  res = Pip_acc_report2io(pads, tmpstr, prefix, what, nst, a);
  if (res == P_OK) {
    pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
  }
  sfstrclose (tmpstr);
  return res;
}

Perror_t
PDCI_date_time_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix,
			     const char *what, int nst, Puint32_acc *a,
			     const char *whatfn, const char *def_what,
			     const char *format, const char *format_descr,
			     Tm_zone_t *tzone, const char *tzone_descr)
{
  int                i, sz, rp;
  Puint64            cnt_sum;
  Pfloat64           bad_pcnt;
  Pfloat64           cnt_sum_pcnt;
  Pfloat64           track_pcnt;
  Pfloat64           elt_pcnt;
  Void_t            *velt;
  Puint32_dt_elt_t  *elt;
  const char        *xtra;

  P_TRACE2(pads->disc, "PDCI_date_time_acc_report2io called, whatfn = %s, out format = %s",
	   whatfn, format);
  tmset(tzone);
  if (!prefix || *prefix == 0) {
    prefix = "<top>";
  }
  if (!what) {
    what = def_what;
  }
  if (strcmp(def_what, "time") == 0) {
    xtra = "\
    ** N.B. times are reported in # of seconds, and also as formatted strings (using the default time output format)";
  } else if (strcmp(def_what, "date") == 0) {
    xtra = "\
    ** N.B. dates are reported in # of seconds since midnight 1-jan-1970, and also as formatted strings (using the default date output format)";
  } else {
    xtra = "\
    ** N.B. timestamps are reported in # of seconds since midnight 1-jan-1970, and also as formatted strings (using the default timestamp output format)";
  }
  PDCI_nst_prefix_what(outstr, &nst, prefix, what, xtra);
  Puint32_acc_fold_psum(a);
  sz = dtsize(a->dict);
  rp = (sz < a->max2rep) ? sz : a->max2rep;
  if (sz == 0) { /* no values accumulated */
    sfprintf(outstr, "(No %s values.)\n", what);
    return P_OK;
  }
  if (sz == 1 && a->bad == 0) {
    elt = (Puint32_dt_elt_t*)dtfirst(a->dict);
    sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %10lu (%s)\n",
	     a->good, what, elt->key.val,
	     fmttime(format, (time_t)elt->key.val));
    dtnext(a->dict, 0); /* discard any iterator state */
    return P_OK;
  }
  if (a->good == 0) {
    bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
  } else {
    bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
  }
  sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n",
	   a->good, a->bad, bad_pcnt);
  if (a->good == 0) {
    sfprintf(outstr, "(No good %s values.)\n", what);
    return P_OK;
  }
  /* check for 100% identical values */
  if (sz == 1) {
    elt = (Puint32_dt_elt_t*)dtfirst(a->dict);
    sfprintf(outstr, "For good %s values, 100 pcnt identical: %10lu (%s)\n",
	     what, elt->key.val,
	     fmttime(format, (time_t)elt->key.val));
    dtnext(a->dict, 0); /* discard any iterator state */
    return P_OK;
  }
  dtdisc(a->dict,   &Puint32_acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */
  sfprintf(outstr, "  Characterizing %s values:  min %llu (%s)", what, a->min, fmttime(format, (time_t)a->min));
  sfprintf(outstr, " max %llu (%s)", a->max, fmttime(format, (time_t)a->max));
  {
    Puint32 rounded_down = (Puint32)a->avg;
    sfprintf(outstr, " avg rounded down to nearest Puint32: %lu (%s)\n", rounded_down, fmttime(format, (time_t)rounded_down));
  }
  sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
  if (sz == a->max2track && a->good > a->tracked) {
    track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
    sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
  }
  for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
       velt && i < a->max2rep;
       velt = dtnext(a->dict, velt), i++) {
    if (cnt_sum_pcnt >= a->pcnt2rep) {
      sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n",
	       rp-i, rp, a->pcnt2rep);
      break;
    }
    elt = (Puint32_dt_elt_t*)velt;
    elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
    sfprintf(outstr, "        val: %10lu (%s)", elt->key.val, fmttime(format, (time_t)elt->key.val));
    sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
    cnt_sum += elt->key.cnt;
    cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
  }
  dtnext(a->dict, 0); /* discard any iterator state */
  sfprintf(outstr,   ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
  sfprintf(outstr,   "        SUMMING         count: %10llu  pcnt-of-good-vals: %8.3I8f\n",
	   cnt_sum, cnt_sum_pcnt);
  /* revert to unordered set in case more inserts will occur after this report */
  dtmethod(a->dict, Dtset); /* change to unordered set */
  dtdisc(a->dict,   &Puint32_acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */
  return P_OK;
}

Perror_t
PDCI_date_time_acc_report2xml_io(P_t *pads, Sfio_t *outstr, const char *src_type,
			         int nst, Puint32_acc *a, const char *whatfn, 
				 const char *format, Tm_zone_t *tzone)
{
  int                i, sz, rp;
  Pfloat64           track_pcnt;
  Void_t            *velt;
  Puint32_dt_elt_t  *elt;

  P_TRACE2(pads->disc, "PDCI_date_time_acc_report2xml_io called, whatfn = %s, out format = %s",
	   whatfn, format);
  tmset(tzone);
  Puint32_acc_fold_psum(a);
  sz = dtsize(a->dict);
  rp = (sz < a->max2rep) ? sz : a->max2rep;
  if (sz == 0) { /* no values accumulated */
    PDCI_indent(outstr, nst);
    sfprintf(outstr, "<%s><none/></%s>\n", src_type, src_type);
    return P_OK;
  }

  PDCI_indent(outstr, nst++);
  sfprintf(outstr, "<%s>\n", src_type);

  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<good>%llu", a->good);
  sfprintf(outstr, "</good>\n");
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<bad>%llu", a->bad);
  sfprintf(outstr, "</bad>\n");

  dtdisc(a->dict,   &Puint32_acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */

  {
    Puint32 rounded_down = (Puint32) a->avg;
    PDCI_indent(outstr, nst);
    sfprintf(outstr, "<avg>%s</avg>\n", fmttime(format, (time_t)rounded_down));
  }
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<min>%s", fmttime(format, (time_t)a->min));
  sfprintf(outstr, "</min>\n");
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<max>%s", fmttime(format, (time_t)a->max));
  sfprintf(outstr, "</max>\n");

  if (sz!=0){
     PDCI_indent(outstr, nst++);
     sfprintf(outstr, "<distribution>\n");
     PDCI_indent(outstr, nst);
     sfprintf(outstr, "<top>%d</top>", rp);
     sfprintf(outstr, "<distinct>%d</distinct>\n", sz);

     if (sz == a->max2track && a->good > a->tracked) {
       track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
       sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt);
     }
     for (i = 0, velt = dtfirst(a->dict);
	  velt && i < a->max2rep;
	  velt = dtnext(a->dict, velt), i++) {
            elt = (Puint32_dt_elt_t*)velt;
	    PDCI_indent(outstr, nst);
	    sfprintf(outstr, "<item>");
	    sfprintf(outstr, "<val>%s", fmttime(format, (time_t)elt->key.val));
	    sfprintf(outstr, "</val>");
	    sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
	    sfprintf(outstr, "</item>\n");
     }
     PDCI_indent(outstr, --nst);
     sfprintf(outstr, "</distribution>\n");
  }
  PDCI_indent(outstr, --nst);
  sfprintf(outstr, "</%s>\n", src_type);

  dtnext(a->dict, 0); /* discard any iterator state */
  /* revert to unordered set in case more inserts will occur after this report */
  dtmethod(a->dict, Dtset); /* change to unordered set */
  dtdisc(a->dict,   &Puint32_acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */
  return P_OK;
}

Perror_t
PDCI_date_time_acc_report(P_t *pads, const char *prefix, const char *what, int nst, Puint32_acc *a,
			  const char *whatfn, const char *def_what,
			  const char *format, const char *format_descr,
			  Tm_zone_t *tzone, const char *tzone_descr)
{
  Sfio_t *tmpstr;
  Perror_t res;
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  PDCI_DISC_1P_CHECKS(whatfn, a);
  if (!pads->disc->error_fn) {
    return P_OK;
  }
  if (!(tmpstr = sfstropen ())) { 
    return P_ERR;
  }
  res = PDCI_date_time_acc_report2io(pads, tmpstr, prefix, what, nst, a,
				     whatfn, def_what,
				     format, format_descr,
				     tzone, tzone_descr);
  if (res == P_OK) {
    pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
  }
  sfstrclose (tmpstr);
  return res;
}

Perror_t
Pchar_acc_init(P_t *pads, Pchar_acc *a)
{
  return Puint8_acc_init(pads, a);
}

Perror_t
Pchar_acc_reset(P_t *pads, Pchar_acc *a)
{
  return Puint8_acc_reset(pads, a);
}

Perror_t
Pchar_acc_cleanup(P_t *pads, Pchar_acc *a)
{
  return Puint8_acc_cleanup(pads, a);
}

Perror_t
Pchar_acc_add(P_t *pads, Pchar_acc *a, const Pbase_pd *pd, const Puint8 *val)
{
  return Puint8_acc_add(pads, a, pd, val);
}

Perror_t
Pchar_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst,
		       Pchar_acc *a)
{
  int                   i, sz, rp;
  Puint64            cnt_sum;
  Pfloat64              cnt_sum_pcnt;
  Pfloat64              bad_pcnt;
  Pfloat64              track_pcnt;
  Pfloat64              elt_pcnt;
  Void_t                *velt;
  Puint8_dt_elt_t    *elt;

  P_TRACE(pads->disc, "Pchar_acc_report2io called");
  if (!prefix || *prefix == 0) {
    prefix = "<top>";
  }
  if (!what) {
    what = "char";
  }
  PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0);
  Puint8_acc_fold_psum(a);
  sz = dtsize(a->dict);
  rp = (sz < a->max2rep) ? sz : a->max2rep;
  if (sz == 0) { /* no values accumulated */
    sfprintf(outstr, "(No %s values.)\n", what);
    return P_OK;
  }
  if (sz == 1 && a->bad == 0) {
    elt = (Puint8_dt_elt_t*)dtfirst(a->dict);
    sfprintf(outstr, "%llu %s values, 100 pcnt good, 100 pcnt identical: %s (as ASCII)\n",
	     a->good, what, P_qfmt_char(elt->key.val));
    dtnext(a->dict, 0); /* discard any iterator state */
    return P_OK;
  }
  if (a->good == 0) {
    bad_pcnt = (a->bad == 0) ? 0.0 : 100.0;
  } else {
    bad_pcnt = 100.0 * (a->bad / (Pfloat64)(a->good + a->bad));
  }
  sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n",
	   a->good, a->bad, bad_pcnt);
  if (a->good == 0) {
    sfprintf(outstr, "(No good %s values.)\n", what);
    return P_OK;
  }
  /* check for 100% identical values */
  if (sz == 1) {
    elt = (Puint8_dt_elt_t*)dtfirst(a->dict);
    sfprintf(outstr, "For good %s values, 100 pcnt identical: %s (as ASCII)\n",
	     what, P_qfmt_char(elt->key.val));
    dtnext(a->dict, 0); /* discard any iterator state */
    return P_OK;
  }
  dtdisc(a->dict,   &Puint8_acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */
  sfprintf(outstr, "  Characterizing %s values:  min %s", what, P_qfmt_char(a->min));
  sfprintf(outstr, " max %s", P_qfmt_char(a->max));
  sfprintf(outstr, " (based on ASCII encoding)\n");

  sfprintf(outstr, "    => distribution of top %d values out of %d distinct values:\n", rp, sz);
  if (sz == a->max2track && a->good > a->tracked) {
    track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
    sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all values *) \n", track_pcnt);
  }
  for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
       velt && i < a->max2rep;
       velt = dtnext(a->dict, velt), i++) {
    if (cnt_sum_pcnt >= a->pcnt2rep) {
      sfprintf(outstr, " [... %d of top %d values not reported due to %.2I8f pcnt limit on reported values ...]\n",
	       rp-i, rp, a->pcnt2rep);
      break;
    }
    elt = (Puint8_dt_elt_t*)velt;
    elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
    sfprintf(outstr, "        val: %6s", P_qfmt_char(elt->key.val));
    sfprintf(outstr, " count: %10llu  pcnt-of-good-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
    cnt_sum += elt->key.cnt;
    cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
  }
  dtnext(a->dict, 0); /* discard any iterator state */
  sfprintf(outstr,   ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
  sfprintf(outstr,   "        SUMMING     count: %10llu  pcnt-of-good-vals: %8.3I8f\n",
	   cnt_sum, cnt_sum_pcnt);
  /* revert to unordered set in case more inserts will occur after this report */
  dtmethod(a->dict, Dtset); /* change to unordered set */
  dtdisc(a->dict,   &Puint8_acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */
  return P_OK;
}

Perror_t
Pchar_acc_report2xml_io(P_t *pads, Sfio_t *outstr, int nst, Pchar_acc *a)
{
  int                   i, sz, rp;
  Pfloat64              track_pcnt;
  Void_t                *velt;
  Puint8_dt_elt_t    *elt;

  P_TRACE(pads->disc, "Pchar_acc_report2xml_io called");
  Puint8_acc_fold_psum(a);
  sz = dtsize(a->dict);
  rp = (sz < a->max2rep) ? sz : a->max2rep;
  if (sz == 0) { /* no values accumulated */
    PDCI_indent(outstr, nst);
    sfprintf(outstr, "<Pchar><none/></Pchar>\n");
    return P_OK;
  }

  PDCI_indent(outstr, nst++);
  sfprintf(outstr, "<Pchar>\n");

  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<good>%llu", a->good);
  sfprintf(outstr, "</good>\n");
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<bad>%llu", a->bad);
  sfprintf(outstr, "</bad>\n");

  dtdisc(a->dict,   &Puint8_acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */
  dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */

  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<min>%s", P_qfmt_char(a->min));
  sfprintf(outstr, "</min>\n");
  PDCI_indent(outstr, nst);
  sfprintf(outstr, "<max>%s", P_qfmt_char(a->max));
  sfprintf(outstr, "</max>\n");

  if (sz!=0){
     PDCI_indent(outstr, nst++);
     sfprintf(outstr, "<distribution>\n");
     PDCI_indent(outstr, nst);
     sfprintf(outstr, "<top>%d</top>", rp);
     sfprintf(outstr, "<distinct>%d</distinct>\n", sz);

     if (sz == a->max2track && a->good > a->tracked) {
       track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
       PDCI_indent(outstr, nst);
       sfprintf(outstr, "<tracked>%.3I8f</tracked>\n", track_pcnt);
     }
     for (i = 0, velt = dtfirst(a->dict);
          velt && i < a->max2rep;
          velt = dtnext(a->dict, velt), i++) {
           elt = (Puint8_dt_elt_t*)velt;
            PDCI_indent(outstr, nst);
            sfprintf(outstr, "<item>");
            sfprintf(outstr, "<val>%s", P_qfmt_char(elt->key.val));
            sfprintf(outstr, "</val>");
            sfprintf(outstr, "<count>%llu</count>", elt->key.cnt);
            sfprintf(outstr, "</item>\n");
     }
     PDCI_indent(outstr, --nst);
     sfprintf(outstr, "</distribution>\n");
  }
  PDCI_indent(outstr, --nst);
  sfprintf(outstr, "</Pchar>\n");

  dtnext(a->dict, 0); /* discard any iterator state */
  /* revert to unordered set in case more inserts will occur after this report */
  dtmethod(a->dict, Dtset); /* change to unordered set */
  dtdisc(a->dict,   &Puint8_acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */
  return P_OK;
}

Perror_t
Pchar_acc_report(P_t *pads, const char *prefix, const char *what, int nst,
		 Pchar_acc *a)
{
  Sfio_t *tmpstr;
  Perror_t res;
  PDCI_DISC_1P_CHECKS("Pchar_acc_report", a);
  if (!pads->disc->error_fn) {
    return P_OK;
  }
  if (!(tmpstr = sfstropen ())) { 
    return P_ERR;
  }
  res = Pchar_acc_report2io(pads, tmpstr, prefix, what, nst, a);
  if (res == P_OK) {
    pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
  }
  sfstrclose (tmpstr);
  return res;
}

#endif /* P_CONFIG_ACCUM_FUNCTIONS */

Perror_t
P_nerr_acc_report2io(P_t *pads, Sfio_t *outstr, const char *prefix, const char *what, int nst,
		     Puint32_acc *a)
{
  int                i, sz, rp;
  Puint64            ngood, nbad;
  Puint64            cnt_sum;
  Pfloat64           bad_pcnt;
  Pfloat64           cnt_sum_pcnt;
  Pfloat64           track_pcnt;
  Pfloat64           elt_pcnt;
  Void_t            *velt;
  Puint32_dt_elt_t  *elt;
  Puint32_dt_key_t   lookup_key;

  P_TRACE(pads->disc, "P_nerr_acc_report2io called");
  if (!prefix || *prefix == 0) {
    prefix = "<top>";
  }
  if (!what) {
    what = "nerr";
  }
  /* XXX_REMOVE PDCI_nst_prefix_what(outstr, &nst, prefix, what, 0); */
#ifndef NDEBUG
  if (a->bad) {
    P_WARN(pads->disc, "** UNEXPECTED: P_nerr_acc_report called with bad values (all nerr are valid).  Ignoring bad.");
  }
#endif
  if (a->good == 0) {
    /* sfprintf(outstr, "good vals: %10u    bad vals: %10u    pcnt-bad: %8.3f\n", 0, 0, 0.0); XXX do not report anything */
    return P_OK;
  }
  Puint32_acc_fold_psum(a);
  lookup_key.val = 0;
  lookup_key.cnt = 0;
  if (!(elt = dtmatch(a->dict, &lookup_key))) {
    /* there were no good values */
    ngood = 0;
    nbad = a->good;
    bad_pcnt = 100.0; 
  } else {
    ngood = elt->key.cnt;
    nbad = a->good - ngood;
    bad_pcnt = 100.0 * (nbad / (Pfloat64)(a->good));
  }
  sfprintf(outstr, "good vals: %10llu    bad vals: %10llu    pcnt-bad: %8.3I8f\n",
	   ngood, nbad, bad_pcnt);
  if (nbad) {
    sz = dtsize(a->dict);
    rp = (sz < a->max2rep) ? sz : a->max2rep;
    dtdisc(a->dict,   &Puint32_acc_dt_oset_disc, DT_SAMEHASH); /* change cmp function */
    dtmethod(a->dict, Dtoset); /* change to ordered set -- establishes an ordering */
    sfprintf(outstr, "  Characterizing number of errors PER READ CALL (nerr-per-read) :");
    sfprintf(outstr, " min %lld", a->min);
    sfprintf(outstr, " max %lld", a->max);
    sfprintf(outstr, " avg %.3I8f\n", a->avg);
    sfprintf(outstr, "    => distribution of top %d nerr-per-read values out of %d distinct nerr-per-read values:\n", rp, sz);
    if (sz == a->max2track && a->good > a->tracked) {
      track_pcnt = 100.0 * (a->tracked/(Pfloat64)a->good);
      sfprintf(outstr, "        (* hit tracking limit, tracked %.3I8f pcnt of all nerr-per-read values *) \n", track_pcnt);
    }
    for (i = 0, cnt_sum = 0, cnt_sum_pcnt = 0, velt = dtfirst(a->dict);
	 velt && i < a->max2rep;
	 velt = dtnext(a->dict, velt), i++) {
      if (cnt_sum_pcnt >= a->pcnt2rep) {
	sfprintf(outstr, " [... %d of top %d nerr-per-read values not reported due to %.2I8f pcnt limit on reported values ...]\n",
		 rp-i, rp, a->pcnt2rep);
	break;
      }
      elt = (Puint32_dt_elt_t*)velt;
      elt_pcnt = 100.0 * (elt->key.cnt/(Pfloat64)a->good);
      sfprintf(outstr, "        val: %10ld", elt->key.val);
      sfprintf(outstr, " count: %10llu pcnt-of-total-vals: %8.3I8f\n", elt->key.cnt, elt_pcnt);
      cnt_sum += elt->key.cnt;
      cnt_sum_pcnt = 100.0 * (cnt_sum/(Pfloat64)a->good);
    }
    dtnext(a->dict, 0); /* discard any iterator state */
    sfprintf(outstr,   ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n");
    sfprintf(outstr,   "        SUMMING         count: %10llu pcnt-of-total-vals: %8.3I8f\n",
	     cnt_sum, cnt_sum_pcnt);
    /* revert to unordered set in case more inserts will occur after this report */
    dtmethod(a->dict, Dtset); /* change to unordered set */
    dtdisc(a->dict,   &Puint32_acc_dt_set_disc, DT_SAMEHASH); /* change cmp function */
  }
  return P_OK;
}

Perror_t
P_nerr_acc_report(P_t *pads, const char *prefix, const char *what, int nst,
		    Puint32_acc *a)
{
  Sfio_t *tmpstr;
  Perror_t res;
  PDCI_DISC_1P_CHECKS("P_nerr_acc_report", a);

  if (!pads->disc->error_fn) {
    return P_OK;
  }
  if (!(tmpstr = sfstropen ())) { 
    return P_ERR;
  }
  res = P_nerr_acc_report2io(pads, tmpstr, prefix, what, nst, a);
  if (res == P_OK) {
    pads->disc->error_fn(NiL, 0, "%s", PDCI_sfstr_use(tmpstr));
  }
  sfstrclose (tmpstr);
  return res;
}

/* ACCUM IMPL HELPERS */

static const char *PDCI_hdr_strings[] = {
  "*****************************************************************************************************\n",
  "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n",
  "=====================================================================================================\n",
  "-----------------------------------------------------------------------------------------------------\n",
  ".....................................................................................................\n",
  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n",
  "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n",
  "= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n",
  "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n"
};

void 
PDCI_indent(Sfio_t *outstr, int nst)
{
  int i;
  for (i=0; i<nst; i++){
    sfprintf(outstr, " ");
  };
};

void
PDCI_nst_prefix_what(Sfio_t *outstr, int *nst, const char *prefix, const char *what, const char *xtra)
{
  if (prefix) {
    if ((*nst) >= 0) {
      int idx = (*nst) % 9;
      sfprintf(outstr, "\n%s", PDCI_hdr_strings[idx]);
      sfprintf(outstr, "%s : %s\n", prefix, what);
      if (xtra) {
	sfprintf(outstr, "%s\n", xtra);
      }
      sfprintf(outstr, "%s", PDCI_hdr_strings[idx]);
      (*nst)++;
    } else {
      sfprintf(outstr, "%s: ", prefix);
    }
  }
}

