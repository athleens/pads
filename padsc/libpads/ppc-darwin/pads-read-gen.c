/*
 * WARNING: GENERATED FILE.  Do not edit this file, edit /Users/kfisher/pads/padsc/libpads/pads.c instead. 
 */

/*
 * Generated read functions
 * 
 * Kathleen Fisher, Robert Gruber
 * AT&T Labs Research
 */

#include "pads-internal.h"
#include "pads-macros-gen.h"

Perror_t Pa_int8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint8 *res_out) {
 Pint8 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_int8) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_a_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_a_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_a_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2int8(begin, &p1);
 }
 else {
 tmp = PDCI_a2int8_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int8) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int8) "_read", "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int8) "_read", 0, P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int8) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int8) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int8) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_int16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint16 *res_out) {
 Pint16 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_int16) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_a_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_a_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_a_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2int16(begin, &p1);
 }
 else {
 tmp = PDCI_a2int16_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int16) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int16) "_read", "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int16) "_read", 0, P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int16) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int16) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int16) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_int32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint32 *res_out) {
 Pint32 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_int32) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_a_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_a_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_a_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2int32(begin, &p1);
 }
 else {
 tmp = PDCI_a2int32_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int32) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int32) "_read", "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int32) "_read", 0, P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int32) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int32) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int32) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_int64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint64 *res_out) {
 Pint64 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_int64) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_a_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_a_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_a_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2int64(begin, &p1);
 }
 else {
 tmp = PDCI_a2int64_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int64) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int64) "_read", "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int64) "_read", 0, P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int64) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int64) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int64) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_uint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint8 *res_out) {
 Puint8 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_uint8) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_a_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_a_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_a_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2uint8(begin, &p1);
 }
 else {
 tmp = PDCI_a2uint8_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint8) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint8) "_read", "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint8) "_read", 0, P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint8) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint8) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint8) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_uint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint16 *res_out) {
 Puint16 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_uint16) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_a_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_a_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_a_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2uint16(begin, &p1);
 }
 else {
 tmp = PDCI_a2uint16_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint16) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint16) "_read", "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint16) "_read", 0, P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint16) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint16) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint16) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_uint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint32 *res_out) {
 Puint32 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_uint32) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_a_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_a_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_a_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2uint32(begin, &p1);
 }
 else {
 tmp = PDCI_a2uint32_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint32) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint32) "_read", "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint32) "_read", 0, P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint32) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint32) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint32) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_uint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint64 *res_out) {
 Puint64 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_uint64) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_a_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_a_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_a_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_a_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2uint64(begin, &p1);
 }
 else {
 tmp = PDCI_a2uint64_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint64) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint64) "_read", "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint64) "_read", 0, P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint64) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint64) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint64) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_int8_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint8 *res_out, size_t width) {
 Pint8 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_int8_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pa_int8_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_a_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2int8(begin, &p1);
 }
 else {
 tmp = PDCI_a2int8_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_a_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_a_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int8_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int8_FW_read), 0, P_INVALID_A_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int8_FW_read), "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int8_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int8_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int8_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_int16_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint16 *res_out, size_t width) {
 Pint16 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_int16_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pa_int16_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_a_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2int16(begin, &p1);
 }
 else {
 tmp = PDCI_a2int16_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_a_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_a_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int16_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int16_FW_read), 0, P_INVALID_A_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int16_FW_read), "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int16_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int16_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int16_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_int32_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint32 *res_out, size_t width) {
 Pint32 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_int32_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pa_int32_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_a_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2int32(begin, &p1);
 }
 else {
 tmp = PDCI_a2int32_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_a_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_a_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int32_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int32_FW_read), 0, P_INVALID_A_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int32_FW_read), "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int32_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int32_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int32_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_int64_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint64 *res_out, size_t width) {
 Pint64 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_int64_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pa_int64_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_a_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2int64(begin, &p1);
 }
 else {
 tmp = PDCI_a2int64_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_a_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_a_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int64_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int64_FW_read), 0, P_INVALID_A_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int64_FW_read), "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_int64_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int64_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_int64_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_uint8_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint8 *res_out, size_t width) {
 Puint8 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_uint8_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pa_uint8_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_a_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2uint8(begin, &p1);
 }
 else {
 tmp = PDCI_a2uint8_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_a_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_a_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint8_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint8_FW_read), 0, P_INVALID_A_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint8_FW_read), "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint8_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint8_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint8_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_uint16_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint16 *res_out, size_t width) {
 Puint16 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_uint16_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pa_uint16_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_a_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2uint16(begin, &p1);
 }
 else {
 tmp = PDCI_a2uint16_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_a_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_a_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint16_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint16_FW_read), 0, P_INVALID_A_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint16_FW_read), "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint16_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint16_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint16_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_uint32_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint32 *res_out, size_t width) {
 Puint32 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_uint32_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pa_uint32_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_a_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2uint32(begin, &p1);
 }
 else {
 tmp = PDCI_a2uint32_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_a_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_a_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint32_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint32_FW_read), 0, P_INVALID_A_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint32_FW_read), "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint32_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint32_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint32_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_uint64_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint64 *res_out, size_t width) {
 Puint64 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pa_uint64_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pa_uint64_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_a_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2uint64(begin, &p1);
 }
 else {
 tmp = PDCI_a2uint64_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_a_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_a_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint64_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint64_FW_read), 0, P_INVALID_A_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint64_FW_read), "spaces not allowed in " "a_int" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_uint64_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint64_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_uint64_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pb_int8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint8 *res_out) {
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pb_int8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(1, goto fatal_nb_io_err);
 if (end-begin != 1) goto width_not_avail;
 if (P_Test_Set(*m)) {
 (*res_out) = *begin;
 }
 PDCI_IO_FORWARD(1, goto fatal_forward_err);
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pb_int8_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_int8_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_int8_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pb_uint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint8 *res_out) {
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pb_uint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(1, goto fatal_nb_io_err);
 if (end-begin != 1) goto width_not_avail;
 if (P_Test_Set(*m)) {
 (*res_out) = *begin;
 }
 PDCI_IO_FORWARD(1, goto fatal_forward_err);
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pb_uint8_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_uint8_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_uint8_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pb_int16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint16 *res_out) {
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pb_int16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(2, goto fatal_nb_io_err);
 if (end-begin != 2) goto width_not_avail;
 if (P_Test_Set(*m)) {
 if (pads->m_endian != pads->disc->d_endian) {
 swapmem(1, begin, res_out, 2);
 }
 else {
 swapmem(0, begin, res_out, 2);
 }
 }
 PDCI_IO_FORWARD(2, goto fatal_forward_err);
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pb_int16_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_int16_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_int16_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pb_uint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint16 *res_out) {
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pb_uint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(2, goto fatal_nb_io_err);
 if (end-begin != 2) goto width_not_avail;
 if (P_Test_Set(*m)) {
 if (pads->m_endian != pads->disc->d_endian) {
 swapmem(1, begin, res_out, 2);
 }
 else {
 swapmem(0, begin, res_out, 2);
 }
 }
 PDCI_IO_FORWARD(2, goto fatal_forward_err);
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pb_uint16_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_uint16_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_uint16_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pb_int32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint32 *res_out) {
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pb_int32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(4, goto fatal_nb_io_err);
 if (end-begin != 4) goto width_not_avail;
 if (P_Test_Set(*m)) {
 if (pads->m_endian != pads->disc->d_endian) {
 swapmem(3, begin, res_out, 4);
 }
 else {
 swapmem(0, begin, res_out, 4);
 }
 }
 PDCI_IO_FORWARD(4, goto fatal_forward_err);
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pb_int32_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_int32_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_int32_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pb_uint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint32 *res_out) {
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pb_uint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(4, goto fatal_nb_io_err);
 if (end-begin != 4) goto width_not_avail;
 if (P_Test_Set(*m)) {
 if (pads->m_endian != pads->disc->d_endian) {
 swapmem(3, begin, res_out, 4);
 }
 else {
 swapmem(0, begin, res_out, 4);
 }
 }
 PDCI_IO_FORWARD(4, goto fatal_forward_err);
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pb_uint32_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_uint32_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_uint32_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pb_int64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint64 *res_out) {
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pb_int64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(8, goto fatal_nb_io_err);
 if (end-begin != 8) goto width_not_avail;
 if (P_Test_Set(*m)) {
 if (pads->m_endian != pads->disc->d_endian) {
 swapmem(7, begin, res_out, 8);
 }
 else {
 swapmem(0, begin, res_out, 8);
 }
 }
 PDCI_IO_FORWARD(8, goto fatal_forward_err);
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pb_int64_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_int64_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_int64_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pb_uint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint64 *res_out) {
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pb_uint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(8, goto fatal_nb_io_err);
 if (end-begin != 8) goto width_not_avail;
 if (P_Test_Set(*m)) {
 if (pads->m_endian != pads->disc->d_endian) {
 swapmem(7, begin, res_out, 8);
 }
 else {
 swapmem(0, begin, res_out, 8);
 }
 }
 PDCI_IO_FORWARD(8, goto fatal_forward_err);
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pb_uint64_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_uint64_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pb_uint64_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_int8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint8 *res_out) {
 Pint8 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_int8) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_e_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_e_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_e_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2int8(begin, &p1);
 }
 else {
 tmp = PDCI_e2int8_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int8) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int8) "_read", "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int8) "_read", 0, P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int8) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int8) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int8) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_int16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint16 *res_out) {
 Pint16 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_int16) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_e_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_e_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_e_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2int16(begin, &p1);
 }
 else {
 tmp = PDCI_e2int16_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int16) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int16) "_read", "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int16) "_read", 0, P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int16) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int16) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int16) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_int32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint32 *res_out) {
 Pint32 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_int32) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_e_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_e_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_e_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2int32(begin, &p1);
 }
 else {
 tmp = PDCI_e2int32_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int32) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int32) "_read", "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int32) "_read", 0, P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int32) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int32) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int32) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_int64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint64 *res_out) {
 Pint64 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_int64) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_e_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_e_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_e_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2int64(begin, &p1);
 }
 else {
 tmp = PDCI_e2int64_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int64) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int64) "_read", "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int64) "_read", 0, P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int64) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int64) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int64) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_uint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint8 *res_out) {
 Puint8 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_uint8) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_e_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_e_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_e_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2uint8(begin, &p1);
 }
 else {
 tmp = PDCI_e2uint8_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint8) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint8) "_read", "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint8) "_read", 0, P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint8) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint8) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint8) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_uint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint16 *res_out) {
 Puint16 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_uint16) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_e_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_e_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_e_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2uint16(begin, &p1);
 }
 else {
 tmp = PDCI_e2uint16_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint16) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint16) "_read", "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint16) "_read", 0, P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint16) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint16) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint16) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_uint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint32 *res_out) {
 Puint32 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_uint32) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_e_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_e_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_e_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2uint32(begin, &p1);
 }
 else {
 tmp = PDCI_e2uint32_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint32) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint32) "_read", "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint32) "_read", 0, P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint32) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint32) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint32) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_uint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint64 *res_out) {
 Puint64 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_uint64) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 if (P_Test_Ignore(*m)) {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 return P_ERR;
 }
 while (PDCI_is_e_space(*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if ('-' == (*p1) || '+' == (*p1)) {
 p1++;
 if (p1 == end) return P_ERR;
 }
 if (!PDCI_is_e_digit(*p1)) {
 return P_ERR;
 }
 while (PDCI_is_e_digit(*p1)) {
 p1++;
 if (p1 == end && !(eor|eof)) {
 return P_ERR;
 }
 }
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_is_e_space(*p1) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2uint64(begin, &p1);
 }
 else {
 tmp = PDCI_e2uint64_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 return P_OK;
 }
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint64) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint64) "_read", "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint64) "_read", 0, P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint64) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint64) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint64) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_int8_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint8 *res_out, size_t width) {
 Pint8 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_int8_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pe_int8_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_e_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2int8(begin, &p1);
 }
 else {
 tmp = PDCI_e2int8_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_e_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_e_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int8_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int8_FW_read), 0, P_INVALID_E_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int8_FW_read), "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int8_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int8_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int8_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_int16_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint16 *res_out, size_t width) {
 Pint16 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_int16_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pe_int16_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_e_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2int16(begin, &p1);
 }
 else {
 tmp = PDCI_e2int16_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_e_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_e_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int16_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int16_FW_read), 0, P_INVALID_E_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int16_FW_read), "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int16_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int16_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int16_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_int32_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint32 *res_out, size_t width) {
 Pint32 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_int32_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pe_int32_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_e_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2int32(begin, &p1);
 }
 else {
 tmp = PDCI_e2int32_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_e_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_e_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int32_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int32_FW_read), 0, P_INVALID_E_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int32_FW_read), "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int32_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int32_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int32_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_int64_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint64 *res_out, size_t width) {
 Pint64 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_int64_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pe_int64_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_e_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2int64(begin, &p1);
 }
 else {
 tmp = PDCI_e2int64_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_e_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_e_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int64_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int64_FW_read), 0, P_INVALID_E_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int64_FW_read), "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_int64_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int64_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_int64_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_uint8_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint8 *res_out, size_t width) {
 Puint8 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_uint8_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pe_uint8_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_e_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2uint8(begin, &p1);
 }
 else {
 tmp = PDCI_e2uint8_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_e_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_e_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint8_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint8_FW_read), 0, P_INVALID_E_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint8_FW_read), "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint8_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint8_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint8_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_uint16_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint16 *res_out, size_t width) {
 Puint16 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_uint16_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pe_uint16_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_e_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2uint16(begin, &p1);
 }
 else {
 tmp = PDCI_e2uint16_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_e_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_e_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint16_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint16_FW_read), 0, P_INVALID_E_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint16_FW_read), "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint16_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint16_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint16_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_uint32_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint32 *res_out, size_t width) {
 Puint32 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_uint32_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pe_uint32_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_e_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2uint32(begin, &p1);
 }
 else {
 tmp = PDCI_e2uint32_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_e_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_e_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint32_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint32_FW_read), 0, P_INVALID_E_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint32_FW_read), "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint32_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint32_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint32_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_uint64_FW_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint64 *res_out, size_t width) {
 Puint64 tmp;
 Pbyte ct;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pe_uint64_FW_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(Pe_uint64_FW_read), "", width);
 PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
 if (end-begin != width) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (PDCI_is_e_space(*begin) && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 ct = *end;
 *end = 0;
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2uint64(begin, &p1);
 }
 else {
 tmp = PDCI_e2uint64_norange(begin, &p1);
 }
 *end = ct;
 if (errno == EINVAL) goto invalid;
 if (p1 < end && PDCI_is_e_space(*p1)) {
 if (!(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 do {
 p1++;
 }
 while (p1 < end && PDCI_is_e_space(*p1));
 }
 if (p1 != end) {
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 }
 return P_OK;
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_IO_FORWARD(end-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint64_FW_read), 0, P_WIDTH_NOT_AVAILABLE);
 invalid: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint64_FW_read), 0, P_INVALID_E_NUM);
 invalid_wspace: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint64_FW_read), "spaces not allowed in " "e_int" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 range_err: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
 PDCI_IO_FORWARD(width, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_uint64_FW_read), 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint64_FW_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_uint64_FW_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pebc_int8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint8 *res_out, Puint32 num_digits_or_bytes) {
 Pint8 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_int8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_ebc2int8 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_ebc2int8_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int8_read), 0, P_INVALID_EBC_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int8_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int8_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int8_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_int8_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_int8_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pebc_int16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint16 *res_out, Puint32 num_digits_or_bytes) {
 Pint16 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_int16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_ebc2int16 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_ebc2int16_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int16_read), 0, P_INVALID_EBC_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int16_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int16_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int16_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_int16_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_int16_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pebc_int32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint32 *res_out, Puint32 num_digits_or_bytes) {
 Pint32 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_int32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_ebc2int32 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_ebc2int32_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int32_read), 0, P_INVALID_EBC_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int32_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int32_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int32_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_int32_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_int32_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pebc_int64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint64 *res_out, Puint32 num_digits_or_bytes) {
 Pint64 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_int64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_ebc2int64 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_ebc2int64_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int64_read), 0, P_INVALID_EBC_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int64_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int64_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_int64_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_int64_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_int64_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pebc_uint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint8 *res_out, Puint32 num_digits_or_bytes) {
 Puint8 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_uint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_ebc2uint8 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_ebc2uint8_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint8_read), 0, P_INVALID_EBC_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint8_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint8_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint8_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_uint8_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_uint8_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pebc_uint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint16 *res_out, Puint32 num_digits_or_bytes) {
 Puint16 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_uint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_ebc2uint16 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_ebc2uint16_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint16_read), 0, P_INVALID_EBC_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint16_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint16_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint16_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_uint16_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_uint16_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pebc_uint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint32 *res_out, Puint32 num_digits_or_bytes) {
 Puint32 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_uint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_ebc2uint32 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_ebc2uint32_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint32_read), 0, P_INVALID_EBC_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint32_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint32_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint32_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_uint32_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_uint32_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pebc_uint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint64 *res_out, Puint32 num_digits_or_bytes) {
 Puint64 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_uint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_ebc2uint64 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_ebc2uint64_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint64_read), 0, P_INVALID_EBC_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint64_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint64_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_uint64_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_uint64_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pebc_uint64_read), *m, "IO_forward error", P_FORWARD_ERR);
 }

Perror_t Pbcd_int8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint8 *res_out, Puint32 num_digits_or_bytes) {
 Pint8 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_int8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(((num_digits_or_bytes+2)/2), goto fatal_nb_io_err);
 if (end-begin != ((num_digits_or_bytes+2)/2)) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_bcd2int8 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_bcd2int8_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2)-1);
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int8_read), 0, P_INVALID_BCD_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int8_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int8_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int8_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_int8_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_int8_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pbcd_int16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint16 *res_out, Puint32 num_digits_or_bytes) {
 Pint16 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_int16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(((num_digits_or_bytes+2)/2), goto fatal_nb_io_err);
 if (end-begin != ((num_digits_or_bytes+2)/2)) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_bcd2int16 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_bcd2int16_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2)-1);
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int16_read), 0, P_INVALID_BCD_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int16_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int16_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int16_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_int16_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_int16_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pbcd_int32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint32 *res_out, Puint32 num_digits_or_bytes) {
 Pint32 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_int32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(((num_digits_or_bytes+2)/2), goto fatal_nb_io_err);
 if (end-begin != ((num_digits_or_bytes+2)/2)) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_bcd2int32 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_bcd2int32_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2)-1);
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int32_read), 0, P_INVALID_BCD_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int32_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int32_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int32_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_int32_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_int32_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pbcd_int64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint64 *res_out, Puint32 num_digits_or_bytes) {
 Pint64 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_int64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(((num_digits_or_bytes+2)/2), goto fatal_nb_io_err);
 if (end-begin != ((num_digits_or_bytes+2)/2)) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_bcd2int64 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_bcd2int64_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2)-1);
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int64_read), 0, P_INVALID_BCD_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int64_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int64_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_int64_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_int64_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_int64_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pbcd_uint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint8 *res_out, Puint32 num_digits_or_bytes) {
 Puint8 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_uint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(((num_digits_or_bytes+2)/2), goto fatal_nb_io_err);
 if (end-begin != ((num_digits_or_bytes+2)/2)) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_bcd2uint8 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_bcd2uint8_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2)-1);
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint8_read), 0, P_INVALID_BCD_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint8_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint8_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint8_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_uint8_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_uint8_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pbcd_uint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint16 *res_out, Puint32 num_digits_or_bytes) {
 Puint16 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_uint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(((num_digits_or_bytes+2)/2), goto fatal_nb_io_err);
 if (end-begin != ((num_digits_or_bytes+2)/2)) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_bcd2uint16 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_bcd2uint16_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2)-1);
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint16_read), 0, P_INVALID_BCD_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint16_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint16_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint16_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_uint16_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_uint16_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pbcd_uint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint32 *res_out, Puint32 num_digits_or_bytes) {
 Puint32 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_uint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(((num_digits_or_bytes+2)/2), goto fatal_nb_io_err);
 if (end-begin != ((num_digits_or_bytes+2)/2)) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_bcd2uint32 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_bcd2uint32_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2)-1);
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint32_read), 0, P_INVALID_BCD_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint32_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint32_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint32_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_uint32_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_uint32_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pbcd_uint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint64 *res_out, Puint32 num_digits_or_bytes) {
 Puint64 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_uint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(((num_digits_or_bytes+2)/2), goto fatal_nb_io_err);
 if (end-begin != ((num_digits_or_bytes+2)/2)) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_bcd2uint64 (begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_bcd2uint64_norange (begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2)-1);
 PDCI_IO_FORWARD(((num_digits_or_bytes+2)/2), goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint64_read), 0, P_INVALID_BCD_NUM);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint64_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint64_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_uint64_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_uint64_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pbcd_uint64_read), *m, "IO_forward error", P_FORWARD_ERR);
 }

Perror_t Psbl_int8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint8 *res_out, Puint32 num_digits_or_bytes) {
 Pint8 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_int8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbl2int8 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbl2int8_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int8_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int8_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int8_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int8_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_int8_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_int8_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbl_int16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint16 *res_out, Puint32 num_digits_or_bytes) {
 Pint16 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_int16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbl2int16 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbl2int16_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int16_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int16_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int16_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int16_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_int16_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_int16_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbl_int32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint32 *res_out, Puint32 num_digits_or_bytes) {
 Pint32 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_int32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbl2int32 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbl2int32_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int32_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int32_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int32_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int32_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_int32_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_int32_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbl_int64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint64 *res_out, Puint32 num_digits_or_bytes) {
 Pint64 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_int64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbl2int64 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbl2int64_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int64_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int64_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int64_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_int64_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_int64_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_int64_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbl_uint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint8 *res_out, Puint32 num_digits_or_bytes) {
 Puint8 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_uint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbl2uint8 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbl2uint8_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint8_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint8_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint8_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint8_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_uint8_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_uint8_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbl_uint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint16 *res_out, Puint32 num_digits_or_bytes) {
 Puint16 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_uint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbl2uint16 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbl2uint16_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint16_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint16_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint16_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint16_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_uint16_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_uint16_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbl_uint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint32 *res_out, Puint32 num_digits_or_bytes) {
 Puint32 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_uint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbl2uint32 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbl2uint32_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint32_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint32_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint32_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint32_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_uint32_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_uint32_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbl_uint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint64 *res_out, Puint32 num_digits_or_bytes) {
 Puint64 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_uint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbl2uint64 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbl2uint64_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint64_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint64_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint64_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_uint64_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_uint64_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbl_uint64_read), *m, "IO_forward error", P_FORWARD_ERR);
 }

Perror_t Psbh_int8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint8 *res_out, Puint32 num_digits_or_bytes) {
 Pint8 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_int8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbh2int8 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbh2int8_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int8_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int8_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int8_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int8_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_int8_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_int8_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbh_int16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint16 *res_out, Puint32 num_digits_or_bytes) {
 Pint16 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_int16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbh2int16 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbh2int16_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int16_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int16_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int16_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int16_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_int16_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_int16_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbh_int32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint32 *res_out, Puint32 num_digits_or_bytes) {
 Pint32 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_int32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbh2int32 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbh2int32_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int32_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int32_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int32_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int32_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_int32_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_int32_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbh_int64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pint64 *res_out, Puint32 num_digits_or_bytes) {
 Pint64 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_int64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbh2int64 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbh2int64_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int64_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int64_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int64_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_int64_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_int64_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_int64_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbh_uint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint8 *res_out, Puint32 num_digits_or_bytes) {
 Puint8 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_uint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbh2uint8 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbh2uint8_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint8_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint8_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint8_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint8_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_uint8_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_uint8_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbh_uint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint16 *res_out, Puint32 num_digits_or_bytes) {
 Puint16 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_uint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbh2uint16 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbh2uint16_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint16_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint16_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint16_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint16_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_uint16_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_uint16_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbh_uint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint32 *res_out, Puint32 num_digits_or_bytes) {
 Puint32 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_uint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbh2uint32 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbh2uint32_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint32_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint32_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint32_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint32_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_uint32_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_uint32_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Psbh_uint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Puint64 *res_out, Puint32 num_digits_or_bytes) {
 Puint64 tmp;
 Pbyte *p1;
 PDCI_IO_NEED_K_BYTES_SETUP;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_uint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_K_BYTES(num_digits_or_bytes, goto fatal_nb_io_err);
 if (end-begin != num_digits_or_bytes) goto width_not_avail;
 if (P_Test_NotIgnore(*m)) {
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_sbh2uint64 (pads, begin, num_digits_or_bytes, &p1);
 }
 else {
 tmp = PDCI_sbh2uint64_norange (pads, begin, num_digits_or_bytes, &p1);
 }
 if (errno) goto invalid_range_dom;
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 }
 else {
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 }
 return P_OK;
 invalid_range_dom: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, num_digits_or_bytes-1);
 PDCI_IO_FORWARD(num_digits_or_bytes, goto fatal_forward_err);
 switch (errno) {
 case EINVAL: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint64_read), 0, P_UNEXPECTED_ERR);
 case ERANGE: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint64_read), 0, P_RANGE);
 case EDOM: PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint64_read), 0, P_BAD_PARAM);
 }
 width_not_avail: PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_uint64_read), 0, P_WIDTH_NOT_AVAILABLE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_uint64_read), *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Psbh_uint64_read), *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pebc_fpoint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint8 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint8 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_fpoint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pebc_int8_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_fpoint8_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 2) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_fpoint8_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pebc_fpoint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint16 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint16 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_fpoint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pebc_int16_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_fpoint16_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 4) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_fpoint16_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pebc_fpoint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint32 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint32 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_fpoint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pebc_int32_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_fpoint32_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 9) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_fpoint32_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pebc_fpoint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint64 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint64 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_fpoint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pebc_int64_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_fpoint64_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 19) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_fpoint64_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pebc_ufpoint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint8 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint8 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_ufpoint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pebc_uint8_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_ufpoint8_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 2) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_ufpoint8_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pebc_ufpoint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint16 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint16 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_ufpoint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pebc_uint16_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_ufpoint16_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 4) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_ufpoint16_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pebc_ufpoint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint32 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint32 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_ufpoint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pebc_uint32_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_ufpoint32_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 9) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_ufpoint32_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pebc_ufpoint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint64 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint64 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pebc_ufpoint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pebc_uint64_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_ufpoint64_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 19) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pebc_ufpoint64_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }

Perror_t Pbcd_fpoint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint8 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint8 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_fpoint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pbcd_int8_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_fpoint8_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 2) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2));
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_fpoint8_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pbcd_fpoint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint16 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint16 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_fpoint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pbcd_int16_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_fpoint16_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 4) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2));
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_fpoint16_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pbcd_fpoint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint32 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint32 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_fpoint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pbcd_int32_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_fpoint32_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 9) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2));
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_fpoint32_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pbcd_fpoint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint64 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint64 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_fpoint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pbcd_int64_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_fpoint64_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 19) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2));
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_fpoint64_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pbcd_ufpoint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint8 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint8 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_ufpoint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pbcd_uint8_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_ufpoint8_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 2) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2));
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_ufpoint8_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pbcd_ufpoint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint16 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint16 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_ufpoint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pbcd_uint16_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_ufpoint16_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 4) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2));
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_ufpoint16_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pbcd_ufpoint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint32 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint32 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_ufpoint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pbcd_uint32_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_ufpoint32_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 9) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2));
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_ufpoint32_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pbcd_ufpoint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint64 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint64 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Pbcd_ufpoint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Pbcd_uint64_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_ufpoint64_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 19) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, ((num_digits_or_bytes+2)/2));
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pbcd_ufpoint64_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }

Perror_t Psbl_fpoint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint8 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint8 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_fpoint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbl_int8_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_fpoint8_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 2) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_fpoint8_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbl_fpoint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint16 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint16 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_fpoint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbl_int16_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_fpoint16_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 4) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_fpoint16_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbl_fpoint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint32 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint32 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_fpoint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbl_int32_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_fpoint32_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 9) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_fpoint32_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbl_fpoint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint64 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint64 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_fpoint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbl_int64_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_fpoint64_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 19) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_fpoint64_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbl_ufpoint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint8 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint8 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_ufpoint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbl_uint8_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_ufpoint8_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 2) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_ufpoint8_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbl_ufpoint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint16 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint16 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_ufpoint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbl_uint16_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_ufpoint16_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 4) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_ufpoint16_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbl_ufpoint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint32 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint32 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_ufpoint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbl_uint32_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_ufpoint32_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 9) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_ufpoint32_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbl_ufpoint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint64 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint64 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbl_ufpoint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbl_uint64_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_ufpoint64_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 19) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbl_ufpoint64_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }

Perror_t Psbh_fpoint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint8 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint8 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_fpoint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbh_int8_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_fpoint8_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 2) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_fpoint8_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbh_fpoint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint16 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint16 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_fpoint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbh_int16_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_fpoint16_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 4) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_fpoint16_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbh_fpoint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint32 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint32 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_fpoint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbh_int32_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_fpoint32_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 9) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_fpoint32_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbh_fpoint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfpoint64 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pfpoint64 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_fpoint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbh_int64_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_fpoint64_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 19) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_fpoint64_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbh_ufpoint8_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint8 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint8 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_ufpoint8_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbh_uint8_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_ufpoint8_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 2) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_ufpoint8_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbh_ufpoint16_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint16 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint16 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_ufpoint16_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbh_uint16_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_ufpoint16_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 4) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_ufpoint16_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbh_ufpoint32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint32 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint32 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_ufpoint32_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbh_uint32_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_ufpoint32_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 9) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_ufpoint32_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Psbh_ufpoint64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pufpoint64 *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) {
 Pufpoint64 tmp;
 PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(Psbh_ufpoint64_read), m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 (pads->inestlev)++;
 if (P_ERR == Psbh_uint64_read(pads, m, pd, &(tmp.num), num_digits_or_bytes)) {
 (pads->inestlev)--;
 PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_ufpoint64_read), 0);
 }
 (pads->inestlev)--;
 if (d_exp > 19) {
 PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, num_digits_or_bytes);
 PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Psbh_ufpoint64_read), 0, P_BAD_PARAM);
 }
 if (P_Test_Set(*m)) {
 tmp.denom = PDCI_10toThe[d_exp];
 (*res_out) = tmp;
 }
 return P_OK;
 }
Perror_t Pa_float32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfloat32 *res_out) {
 Pfloat32 tmp;
 Pbyte ct;
 Pbyte *p1;
 Pchar plus = PDCI_identity_charmap[(int)'+'];
 Pchar minus = PDCI_identity_charmap[(int)'-'];
 Pchar e_lower = PDCI_identity_charmap[(int)'e'];
 Pchar e_upper = PDCI_identity_charmap[(int)'E'];
 Pchar dot = PDCI_identity_charmap[(int)'.'];
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS(PDCI_MacroArg2String(Pa_float32) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 ct = *end;
 *end = 0;
 if (P_Test_Ignore(*m)) {
 if (PDCI_ascii_is_space[(int)*p1] && !(pads->disc->flags & P_WSPACE_OK)) goto nocheck_err;
 while (PDCI_ascii_is_space[(int)(*p1)]) {
 p1++;
 }
 if (plus == (*p1) || minus == (*p1)) {
 p1++;
 }
 if (!PDCI_ascii_is_digit[(int)*p1]) goto nocheck_err;
 while (PDCI_ascii_is_digit[(int)*p1]) {
 p1++;
 }
 if (dot == (*p1)) {
 p1++;
 while (PDCI_ascii_is_digit[(int)*p1]) {
 p1++;
 }
 }
 if ((e_lower == (*p1) || e_upper == (*p1))) {
 p1++;
 if (p1 == end) goto nocheck_err;
 if (plus == (*p1) || minus == (*p1)) {
 p1++;
 if (p1 == end) goto nocheck_err;
 }
 if (!PDCI_ascii_is_digit[(int)*p1]) goto nocheck_err;
 while (PDCI_ascii_is_digit[(int)*p1]) {
 p1++;
 }
 }
 if (p1 == end && !(eor|eof)) goto nocheck_err;
 *end = ct;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_ascii_is_space[(int)(*p1)] && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2float32(begin, &p1);
 }
 else {
 tmp = PDCI_a2float32_norange(begin, &p1);
 }
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 *end = ct;
 return P_OK;
 }
 nocheck_err: *end = ct;
 return P_ERR;
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_float32) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_float32) "_read", "spaces not allowed in " "a_float" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 invalid: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_float32) "_read", 0, P_INVALID_A_NUM);
 range_err: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_float32) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_float32) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: *end = ct;
 PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_float32) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pa_float64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfloat64 *res_out) {
 Pfloat64 tmp;
 Pbyte ct;
 Pbyte *p1;
 Pchar plus = PDCI_identity_charmap[(int)'+'];
 Pchar minus = PDCI_identity_charmap[(int)'-'];
 Pchar e_lower = PDCI_identity_charmap[(int)'e'];
 Pchar e_upper = PDCI_identity_charmap[(int)'E'];
 Pchar dot = PDCI_identity_charmap[(int)'.'];
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS(PDCI_MacroArg2String(Pa_float64) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 ct = *end;
 *end = 0;
 if (P_Test_Ignore(*m)) {
 if (PDCI_ascii_is_space[(int)*p1] && !(pads->disc->flags & P_WSPACE_OK)) goto nocheck_err;
 while (PDCI_ascii_is_space[(int)(*p1)]) {
 p1++;
 }
 if (plus == (*p1) || minus == (*p1)) {
 p1++;
 }
 if (!PDCI_ascii_is_digit[(int)*p1]) goto nocheck_err;
 while (PDCI_ascii_is_digit[(int)*p1]) {
 p1++;
 }
 if (dot == (*p1)) {
 p1++;
 while (PDCI_ascii_is_digit[(int)*p1]) {
 p1++;
 }
 }
 if ((e_lower == (*p1) || e_upper == (*p1))) {
 p1++;
 if (p1 == end) goto nocheck_err;
 if (plus == (*p1) || minus == (*p1)) {
 p1++;
 if (p1 == end) goto nocheck_err;
 }
 if (!PDCI_ascii_is_digit[(int)*p1]) goto nocheck_err;
 while (PDCI_ascii_is_digit[(int)*p1]) {
 p1++;
 }
 }
 if (p1 == end && !(eor|eof)) goto nocheck_err;
 *end = ct;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_ascii_is_space[(int)(*p1)] && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_a2float64(begin, &p1);
 }
 else {
 tmp = PDCI_a2float64_norange(begin, &p1);
 }
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 *end = ct;
 return P_OK;
 }
 nocheck_err: *end = ct;
 return P_ERR;
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_float64) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_float64) "_read", "spaces not allowed in " "a_float" " field unless flag P_WSPACE_OK is set", P_INVALID_A_NUM);
 invalid: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_float64) "_read", 0, P_INVALID_A_NUM);
 range_err: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pa_float64) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_float64) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: *end = ct;
 PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pa_float64) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_float32_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfloat32 *res_out) {
 Pfloat32 tmp;
 Pbyte ct;
 Pbyte *p1;
 Pchar plus = P_mod_ae_tab[(int)'+'];
 Pchar minus = P_mod_ae_tab[(int)'-'];
 Pchar e_lower = P_mod_ae_tab[(int)'e'];
 Pchar e_upper = P_mod_ae_tab[(int)'E'];
 Pchar dot = P_mod_ae_tab[(int)'.'];
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS(PDCI_MacroArg2String(Pe_float32) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 ct = *end;
 *end = 0;
 if (P_Test_Ignore(*m)) {
 if (PDCI_ebcdic_is_space[(int)*p1] && !(pads->disc->flags & P_WSPACE_OK)) goto nocheck_err;
 while (PDCI_ebcdic_is_space[(int)(*p1)]) {
 p1++;
 }
 if (plus == (*p1) || minus == (*p1)) {
 p1++;
 }
 if (!PDCI_ebcdic_is_digit[(int)*p1]) goto nocheck_err;
 while (PDCI_ebcdic_is_digit[(int)*p1]) {
 p1++;
 }
 if (dot == (*p1)) {
 p1++;
 while (PDCI_ebcdic_is_digit[(int)*p1]) {
 p1++;
 }
 }
 if ((e_lower == (*p1) || e_upper == (*p1))) {
 p1++;
 if (p1 == end) goto nocheck_err;
 if (plus == (*p1) || minus == (*p1)) {
 p1++;
 if (p1 == end) goto nocheck_err;
 }
 if (!PDCI_ebcdic_is_digit[(int)*p1]) goto nocheck_err;
 while (PDCI_ebcdic_is_digit[(int)*p1]) {
 p1++;
 }
 }
 if (p1 == end && !(eor|eof)) goto nocheck_err;
 *end = ct;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_ebcdic_is_space[(int)(*p1)] && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2float32(begin, &p1);
 }
 else {
 tmp = PDCI_e2float32_norange(begin, &p1);
 }
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 *end = ct;
 return P_OK;
 }
 nocheck_err: *end = ct;
 return P_ERR;
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_float32) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_float32) "_read", "spaces not allowed in " "e_float" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 invalid: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_float32) "_read", 0, P_INVALID_E_NUM);
 range_err: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_float32) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_float32) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: *end = ct;
 PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_float32) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }
Perror_t Pe_float64_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pfloat64 *res_out) {
 Pfloat64 tmp;
 Pbyte ct;
 Pbyte *p1;
 Pchar plus = P_mod_ae_tab[(int)'+'];
 Pchar minus = P_mod_ae_tab[(int)'-'];
 Pchar e_lower = P_mod_ae_tab[(int)'e'];
 Pchar e_upper = P_mod_ae_tab[(int)'E'];
 Pchar dot = P_mod_ae_tab[(int)'.'];
 PDCI_IO_NEED_BYTES_SETUP_NUMERIC;
 PDCI_IODISC_3P_CHECKS(PDCI_MacroArg2String(Pe_float64) "_read", m, pd, res_out);
 PDCI_READFN_PD_INIT(pads, pd);
 PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
 if (begin == end) {
 goto at_eor_or_eof_err;
 }
 p1 = begin;
 ct = *end;
 *end = 0;
 if (P_Test_Ignore(*m)) {
 if (PDCI_ebcdic_is_space[(int)*p1] && !(pads->disc->flags & P_WSPACE_OK)) goto nocheck_err;
 while (PDCI_ebcdic_is_space[(int)(*p1)]) {
 p1++;
 }
 if (plus == (*p1) || minus == (*p1)) {
 p1++;
 }
 if (!PDCI_ebcdic_is_digit[(int)*p1]) goto nocheck_err;
 while (PDCI_ebcdic_is_digit[(int)*p1]) {
 p1++;
 }
 if (dot == (*p1)) {
 p1++;
 while (PDCI_ebcdic_is_digit[(int)*p1]) {
 p1++;
 }
 }
 if ((e_lower == (*p1) || e_upper == (*p1))) {
 p1++;
 if (p1 == end) goto nocheck_err;
 if (plus == (*p1) || minus == (*p1)) {
 p1++;
 if (p1 == end) goto nocheck_err;
 }
 if (!PDCI_ebcdic_is_digit[(int)*p1]) goto nocheck_err;
 while (PDCI_ebcdic_is_digit[(int)*p1]) {
 p1++;
 }
 }
 if (p1 == end && !(eor|eof)) goto nocheck_err;
 *end = ct;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 return P_OK;
 }
 else {
 if (PDCI_ebcdic_is_space[(int)(*p1)] && !(pads->disc->flags & P_WSPACE_OK)) {
 goto invalid_wspace;
 }
 if (P_Test_SemCheck(*m)) {
 tmp = PDCI_e2float64(begin, &p1);
 }
 else {
 tmp = PDCI_e2float64_norange(begin, &p1);
 }
 if (errno == EINVAL) {
 if (p1 != end) p1++;
 goto invalid;
 }
 if (errno == ERANGE) goto range_err;
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 if (P_Test_Set(*m)) {
 (*res_out) = tmp;
 }
 *end = ct;
 return P_OK;
 }
 nocheck_err: *end = ct;
 return P_ERR;
 at_eor_or_eof_err: PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_float64) "_read", 0, eor ? P_AT_EOR : P_AT_EOF);
 invalid_wspace: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC(pads, pd->loc);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_float64) "_read", "spaces not allowed in " "e_float" " field unless flag P_WSPACE_OK is set", P_INVALID_E_NUM);
 invalid: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_float64) "_read", 0, P_INVALID_E_NUM);
 range_err: *end = ct;
 PDCI_READFN_BEGINLOC(pads, pd->loc);
 PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
 PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
 PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(Pe_float64) "_read", 0, P_RANGE);
 fatal_nb_io_err: PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_float64) "_read", *m, "IO error (nb)", P_IO_ERR);
 fatal_forward_err: *end = ct;
 PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(Pe_float64) "_read", *m, "IO_forward error", P_FORWARD_ERR);
 }

/*
 * XXX dummy going away eventually
 */
Perror_t
Pdummy_read(P_t *pads, const Pbase_m *m, Pint32 dummy_val, Pbase_pd *pd, Pint32 *res_out)
{
  PDCI_DISC_3P_CHECKS("Pdummy_read", m, pd, res_out);
  PDCI_READFN_PD_INIT(pads, pd);
  (*res_out) = dummy_val;
  return P_OK;
}

