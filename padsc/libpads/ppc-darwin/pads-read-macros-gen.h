#ifdef _USE_PROTO
#pragma prototyped
#endif
/*
 * WARNING: GENERATED FILE.  Do not edit this file, edit /Users/kfisher/pads/padsc/libpads/pads.c instead. 
 */

#ifndef __PADS_READ_MACROS_GEN_H__
#define __PADS_READ_MACROS_GEN_H__

/*
 * Macros that help implement read functions
 * 
 * Kathleen Fisher, Robert Gruber
 * AT&T Labs Research
 */

#include "pads-config.h"

#define PDCI_AE_INT_READ_FN_GEN(fn_pref, targ_type, bytes2num_fn, invalid_err, isspace_fn, isdigit_fn, a_or_e_int) \
 \
Perror_t \
fn_pref ## _read(P_t *pads, const Pbase_m *m, \
		 Pbase_pd *pd, targ_type *res_out) \
{ \
  targ_type    tmp;   /* tmp num */ \
  Pbyte        ct;    /* char tmp */ \
  Pbyte       *p1; \
  PDCI_IO_NEED_BYTES_SETUP_NUMERIC; \
 \
  PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(fn_pref) "_read", m, pd, res_out); \
  PDCI_READFN_PD_INIT(pads, pd); \
  PDCI_IO_NEED_BYTES(goto fatal_nb_io_err); \
  if (begin == end) { \
    goto at_eor_or_eof_err; \
  } \
  p1 = begin; \
  if (P_Test_Ignore(*m)) { \
    /* move beyond anything that looks like an ascii number, return P_ERR if none such */ \
    if (isspace_fn(*p1) && !(pads->disc->flags & P_WSPACE_OK)) { \
      return P_ERR; \
    } \
    while (isspace_fn(*p1)) { /* skip spaces, if any */ \
      p1++; \
      if (p1 == end) return P_ERR; /* did not find digit */ \
    } \
    if ('-' == (*p1) || '+' == (*p1)) { /* skip +/-, if any */ \
      p1++; \
      if (p1 == end) return P_ERR; /* did not find a digit */ \
    } \
    if (!isdigit_fn(*p1)) { \
      return P_ERR; /* did not find a digit */ \
    } \
    /* all set: skip digits, move IO cursor, and return P_OK */ \
    while (isdigit_fn(*p1)) { \
      p1++; \
      if (p1 == end && !(eor|eof)) { \
	/* did not find end of digits within P_BUILTIN_NUMERIC_MAX bytes */ \
	return P_ERR; \
      } \
    } \
    PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err); \
    return P_OK; \
 \
  } else { /* !P_Test_Ignore(*m) */ \
 \
    if (isspace_fn(*p1) && !(pads->disc->flags & P_WSPACE_OK)) { \
      goto invalid_wspace; \
    } \
    ct = *end;    /* save */ \
    *end = 0;     /* null */ \
    if (P_Test_SemCheck(*m)) { \
      tmp = bytes2num_fn(begin, &p1); \
    } else { \
      tmp = bytes2num_fn ## _norange(begin, &p1); \
    } \
    *end = ct;    /* restore */ \
    if (errno == EINVAL) { \
      if (p1 != end) p1++; /* move to just beyond offending char */ \
      goto invalid; \
    } \
    if (errno == ERANGE) goto range_err; \
    /* success */ \
    PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err); \
    if (P_Test_Set(*m)) { \
      (*res_out) = tmp; \
    } \
    return P_OK; \
  } \
 \
 at_eor_or_eof_err: \
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_pref) "_read", 0, eor ? P_AT_EOR : P_AT_EOF); \
 \
 invalid_wspace: \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC(pads, pd->loc); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_pref) "_read", "spaces not allowed in " a_or_e_int " field unless flag P_WSPACE_OK is set", invalid_err); \
 \
 invalid: \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_pref) "_read", 0, invalid_err); \
 \
 range_err: \
  /* range error still consumes the number */ \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1); \
  PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_pref) "_read", 0, P_RANGE); \
 \
 fatal_nb_io_err: \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_pref) "_read", *m, "IO error (nb)", P_IO_ERR); \
 \
 fatal_forward_err: \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_pref) "_read", *m, "IO_forward error", P_FORWARD_ERR); \
} \

#define PDCI_AE_INT_FW_READ_FN_GEN(fn_name, targ_type, bytes2num_fn, invalid_err, isspace_fn, a_or_e_int) \
 \
Perror_t \
fn_name(P_t *pads, const Pbase_m *m, \
	Pbase_pd *pd, targ_type *res_out, size_t width) \
{ \
  targ_type    tmp;   /* tmp num */ \
  Pbyte        ct;    /* char tmp */ \
  Pbyte       *p1; \
  PDCI_IO_NEED_K_BYTES_SETUP; \
 \
  PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(fn_name), m, pd, res_out); \
  PDCI_READFN_PD_INIT(pads, pd); \
  PDCI_READFN_WIDTH_CHECK( PDCI_MacroArg2String(fn_name), "", width); \
  PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err); \
  if (end-begin != width)     goto width_not_avail; \
  if (P_Test_NotIgnore(*m)) { \
    if (isspace_fn(*begin) && !(pads->disc->flags & P_WSPACE_OK)) { \
      goto invalid_wspace; \
    } \
    ct = *end;    /* save */ \
    *end = 0;     /* null */ \
    if (P_Test_SemCheck(*m)) { \
      tmp = bytes2num_fn(begin, &p1); \
    } else { \
      tmp = bytes2num_fn ## _norange(begin, &p1); \
    } \
    *end = ct;    /* restore */ \
    if (errno == EINVAL) goto invalid; \
    if (p1 < end && isspace_fn(*p1)) { \
      if (!(pads->disc->flags & P_WSPACE_OK)) { \
	goto invalid_wspace; \
      } \
      do { p1++; } while (p1 < end && isspace_fn(*p1)); \
    } \
    if (p1 != end) { \
      goto invalid; \
    } \
    if (errno == ERANGE) goto range_err; \
    /* success */ \
    PDCI_IO_FORWARD(width, goto fatal_forward_err); \
    if (P_Test_Set(*m)) { \
      (*res_out) = tmp; \
    } \
  } else { \
    /* just move forward */ \
    PDCI_IO_FORWARD(width, goto fatal_forward_err); \
  } \
  return P_OK; \
 \
 width_not_avail: \
  /* FW field: eat the space whether or not there is an error */ \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1); \
  PDCI_IO_FORWARD(end-begin, goto fatal_forward_err); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0, P_WIDTH_NOT_AVAILABLE); \
 \
 invalid: \
  /* FW field: eat the space whether or not there is an error */ \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1); \
  PDCI_IO_FORWARD(width, goto fatal_forward_err); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0, invalid_err); \
 \
 invalid_wspace: \
  /* FW field: eat the space whether or not there is an error */ \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1); \
  PDCI_IO_FORWARD(width, goto fatal_forward_err); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), "spaces not allowed in " a_or_e_int " field unless flag P_WSPACE_OK is set", invalid_err); \
 \
 range_err: \
  /* FW field: eat the space whether or not there is an error */ \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1); \
  PDCI_IO_FORWARD(width, goto fatal_forward_err); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0, P_RANGE); \
 \
  /* fatal_alloc_err: \
     PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_name), *m, "Memory alloc err", P_ALLOC_ERR); */ \
 \
 fatal_nb_io_err: \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_name), *m, "IO error (nb)", P_IO_ERR); \
 \
 fatal_forward_err: \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_name), *m, "IO_forward error", P_FORWARD_ERR); \
} \

#define PDCI_ASCII_LOWER_E   'e' \

#define PDCI_EBCDIC_LOWER_E   XXX_TODO \

#define PDCI_AE_FLOAT_READ_FN_GEN(fn_pref, targ_type, bytes2num_fn, invalid_err, isspacemap, isdigitmap, charmap, a_or_e_float) \
/* Char-based floats have the form:     [+|-]DIGITS[.][DIGITS][(e|E)[+|-]DIGITS] */ \
Perror_t \
fn_pref ## _read(P_t *pads, const Pbase_m *m, \
		 Pbase_pd *pd, targ_type *res_out) \
{ \
  targ_type tmp; \
  Pbyte    ct; \
  Pbyte   *p1; \
  Pchar plus     = charmap[(int)'+']; \
  Pchar minus    = charmap[(int)'-']; \
  Pchar e_lower  = charmap[(int)'e']; \
  Pchar e_upper  = charmap[(int)'E']; \
  Pchar dot      = charmap[(int)'.']; \
  PDCI_IO_NEED_BYTES_SETUP_NUMERIC; \
 \
  PDCI_IODISC_3P_CHECKS(PDCI_MacroArg2String(fn_pref) "_read", m, pd, res_out); \
  PDCI_READFN_PD_INIT(pads, pd); \
  PDCI_IO_NEED_BYTES(goto fatal_nb_io_err); \
  if (begin == end) { \
    goto at_eor_or_eof_err; \
  } \
  p1 = begin; \
  ct = *end;    /* save */ \
  *end = 0;     /* null */ \
  if (P_Test_Ignore(*m)) { \
    /* move beyond anything that looks like a float, return P_ERR if none such */ \
    if (isspacemap[(int)*p1] && !(pads->disc->flags & P_WSPACE_OK)) goto nocheck_err; \
    while (isspacemap[(int)(*p1)]) { p1++; }            /* skip spaces, if any */ \
    if (plus == (*p1) || minus == (*p1)) { p1++; }   /* skip +/-, if any */ \
    if (!isdigitmap[(int)*p1]) goto nocheck_err;        /* did not find a digit */ \
    while (isdigitmap[(int)*p1]) { p1++; }              /* skip digits */ \
    if (dot == (*p1)) {    /* skip dot and trailing digits */ \
      p1++; \
      while (isdigitmap[(int)*p1]) { p1++; } \
    } \
    /* skip e, optional sign, digits, if present */ \
    if ((e_lower == (*p1) || e_upper == (*p1))) { \
      p1++; \
      if (p1 == end) goto nocheck_err; /* did not find at least 1 digit after e */ \
      if (plus == (*p1) || minus == (*p1)) {  /* skip +/-, if any */ \
	p1++; \
	if (p1 == end) goto nocheck_err; /* did not find at least 1 digit after e */ \
      } \
      if (!isdigitmap[(int)*p1]) goto nocheck_err; /* did not find at least 1 digit after e */ \
      while (isdigitmap[(int)*p1]) { p1++; }  /* skip digits */ \
    } \
    if (p1 == end && !(eor|eof)) goto nocheck_err; /* did not find end of float within P_BUILTIN_NUMERIC_MAX bytes */ \
    /* OK */ \
    *end = ct; /* restore */ \
    PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err); \
    return P_OK; \
 \
  } else { /* !P_Test_Ignore(*m) */ \
 \
    if (isspacemap[(int)(*p1)] && !(pads->disc->flags & P_WSPACE_OK)) { \
      goto invalid_wspace; \
    } \
    if (P_Test_SemCheck(*m)) { \
      tmp = bytes2num_fn(begin, &p1); \
    } else { \
      tmp = bytes2num_fn ## _norange(begin, &p1); \
    } \
    if (errno == EINVAL) { \
      if (p1 != end) p1++; /* move to just beyond offending char */ \
      goto invalid; \
    } \
    if (errno == ERANGE) goto range_err; \
    PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err); \
    if (P_Test_Set(*m)) { \
      (*res_out) = tmp; \
    } \
    *end = ct;    /* restore */ \
    return P_OK; \
  } \
 \
 nocheck_err: \
  *end = ct; /* restore */ \
  return P_ERR; \
 \
 at_eor_or_eof_err: \
  /* don't need to restore, eor/eof error occurs before *end is set to 0 */ \
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_pref) "_read", 0, eor ? P_AT_EOR : P_AT_EOF); \
 \
 invalid_wspace: \
  *end = ct; /* restore */ \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC(pads, pd->loc); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_pref) "_read", "spaces not allowed in " a_or_e_float " field unless flag P_WSPACE_OK is set", invalid_err); \
 \
 invalid: \
  *end = ct; /* restore */ \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_pref) "_read", 0, invalid_err); \
 \
 range_err: \
  *end = ct; /* restore */ \
  /* range error still consumes the number */ \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1); \
  PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_pref) "_read", 0, P_RANGE); \
 \
 fatal_nb_io_err: \
  /* don't need to restore, need bytes error occurs before *end is set to 0 */ \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_pref) "_read", *m, "IO error (nb)", P_IO_ERR); \
 \
 fatal_forward_err: \
  *end = ct;    /* restore */ \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_pref) "_read", *m, "IO_forward error", P_FORWARD_ERR); \
} \

#define PDCI_B1_INT_READ_FN_GEN(fn_name, targ_type) \
 \
Perror_t \
fn_name(P_t *pads, const Pbase_m *m, \
	Pbase_pd *pd, targ_type *res_out) \
{ \
  PDCI_IO_NEED_K_BYTES_SETUP; \
 \
  PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(fn_name), m, pd, res_out); \
  PDCI_READFN_PD_INIT(pads, pd); \
  PDCI_IO_NEED_K_BYTES(1, goto fatal_nb_io_err); \
  if (end-begin != 1)     goto width_not_avail; \
  if (P_Test_Set(*m)) { \
    (*res_out) = *begin; \
  } \
  PDCI_IO_FORWARD(1, goto fatal_forward_err); \
  return P_OK; \
 \
 width_not_avail: \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0, P_WIDTH_NOT_AVAILABLE); \
 \
 fatal_nb_io_err: \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_name), *m, "IO error (nb)", P_IO_ERR); \
 \
 fatal_forward_err: \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_name), *m, "IO_forward error", P_FORWARD_ERR); \
} \

#define PDCI_B_INT_READ_FN_GEN(fn_name, targ_type, width, swapmem_op) \
 \
Perror_t \
fn_name(P_t *pads, const Pbase_m *m, \
	Pbase_pd *pd, targ_type *res_out) \
{ \
  PDCI_IO_NEED_K_BYTES_SETUP; \
 \
  PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(fn_name), m, pd, res_out); \
  PDCI_READFN_PD_INIT(pads, pd); \
  PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err); \
  if (end-begin != width)     goto width_not_avail; \
  if (P_Test_Set(*m)) { \
    if (pads->m_endian != pads->disc->d_endian) { \
      swapmem(swapmem_op, begin, res_out, width); \
    } else { \
      swapmem(0, begin, res_out, width); \
    } \
  } \
  PDCI_IO_FORWARD(width, goto fatal_forward_err); \
  return P_OK; \
 \
 width_not_avail: \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0, P_WIDTH_NOT_AVAILABLE); \
 \
 fatal_nb_io_err: \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_name), *m, "IO error (nb)", P_IO_ERR); \
 \
 fatal_forward_err: \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_name), *m, "IO_forward error", P_FORWARD_ERR); \
} \

#define PDCI_EBCBCDSB_INT_READ_FN_GEN(fn_name, targ_type, bytes2num_fn, invalid_err, width, bytes2num_args) \
 \
Perror_t \
fn_name(P_t *pads, const Pbase_m *m, Pbase_pd *pd, targ_type *res_out, Puint32 num_digits_or_bytes) \
{ \
  targ_type     tmp;   /* tmp num */ \
  Pbyte        *p1;    /* available for use in bytes2num_args */ \
  PDCI_IO_NEED_K_BYTES_SETUP; \
 \
  PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(fn_name), m, pd, res_out); \
  PDCI_READFN_PD_INIT(pads, pd); \
  PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err); \
  if (end-begin != width)     goto width_not_avail; \
  if (P_Test_NotIgnore(*m)) { \
    if (P_Test_SemCheck(*m)) { \
      tmp = bytes2num_fn bytes2num_args; \
    } else { \
      tmp = bytes2num_fn ## _norange bytes2num_args; \
    } \
    if (errno) goto invalid_range_dom; \
    /* success */ \
    PDCI_IO_FORWARD(width, goto fatal_forward_err); \
    if (P_Test_Set(*m)) { \
      (*res_out) = tmp; \
    } \
  } else { \
    /* just move forward */ \
    PDCI_IO_FORWARD(width, goto fatal_forward_err); \
  } \
  return P_OK; \
 \
 invalid_range_dom: \
  /* FW field: eat the space whether or not there is an error */ \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1); \
  PDCI_IO_FORWARD(width, goto fatal_forward_err); \
  switch (errno) { \
  case EINVAL: \
    PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0, invalid_err); \
  case ERANGE: \
    PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0, P_RANGE); \
  case EDOM: \
    PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0, P_BAD_PARAM); \
  } \
 \
 width_not_avail: \
  PDCI_READFN_BEGINLOC(pads, pd->loc); \
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1); \
  PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0, P_WIDTH_NOT_AVAILABLE); \
 \
 fatal_nb_io_err: \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_name), *m, "IO error (nb)", P_IO_ERR); \
 \
 fatal_forward_err: \
  PDCI_READFN_RET_ERRCODE_FATAL(PDCI_MacroArg2String(fn_name), *m, "IO_forward error", P_FORWARD_ERR); \
} \

#define PDCI_EBCBCDSB_FPOINT_READ_FN_GEN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max) \
 \
Perror_t \
fn_name(P_t *pads, const Pbase_m *m, \
	Pbase_pd *pd, targ_type *res_out, Puint32 num_digits_or_bytes, Puint32 d_exp) \
{ \
  targ_type       tmp;   /* tmp num */ \
 \
  PDCI_IODISC_3P_CHECKS( PDCI_MacroArg2String(fn_name), m, pd, res_out); \
  PDCI_READFN_PD_INIT(pads, pd); \
  (pads->inestlev)++; \
  if (P_ERR == internal_numerator_read_fn(pads, m, pd, &(tmp.num), num_digits_or_bytes)) { \
    /* pd filled in already, IO cursor advanced if appropriate */ \
    (pads->inestlev)--; \
    PDCI_READFN_RET_EXIST_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0); \
  } \
  (pads->inestlev)--; \
  /* so far so good, IO cursor has been advanced, pd->errCode set to P_NO_ERR */ \
  if (d_exp > dexp_max) { \
    PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, width); \
    PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc); \
    PDCI_READFN_RET_ERRCODE_WARN(PDCI_MacroArg2String(fn_name), 0, P_BAD_PARAM); \
  } \
  if (P_Test_Set(*m)) { \
    tmp.denom = PDCI_10toThe[d_exp]; \
    (*res_out) = tmp; \
  } \
  return P_OK; \
} \

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_A_INT > 0
#  define PDCI_A_INT_READ_FN(fn_pref, targ_type, bytes2num_fn) \
            PDCI_AE_INT_READ_FN_GEN(fn_pref, targ_type, bytes2num_fn, P_INVALID_A_NUM, PDCI_is_a_space, PDCI_is_a_digit, "a_int")
#else
#  define PDCI_A_INT_READ_FN(fn_pref, targ_type, bytes2num_fn)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_A_INT_FW > 0
#  define PDCI_A_INT_FW_READ_FN(fn_name, targ_type, bytes2num_fn) \
            PDCI_AE_INT_FW_READ_FN_GEN(fn_name, targ_type, bytes2num_fn, P_INVALID_A_NUM, PDCI_is_a_space, "a_int")
#else
#  define PDCI_A_INT_FW_READ_FN(fn_name, targ_type, bytes2num_fn)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_E_INT > 0
#  define PDCI_E_INT_READ_FN(fn_pref, targ_type, bytes2num_fn) \
            PDCI_AE_INT_READ_FN_GEN(fn_pref, targ_type, bytes2num_fn, P_INVALID_E_NUM, PDCI_is_e_space, PDCI_is_e_digit, "e_int")
#else
#  define PDCI_E_INT_READ_FN(fn_pref, targ_type, bytes2num_fn)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_E_INT_FW > 0
#  define PDCI_E_INT_FW_READ_FN(fn_name, targ_type, bytes2num_fn) \
            PDCI_AE_INT_FW_READ_FN_GEN(fn_name, targ_type, bytes2num_fn, P_INVALID_E_NUM, PDCI_is_e_space, "e_int")
#else
#  define PDCI_E_INT_FW_READ_FN(fn_name, targ_type, bytes2num_fn)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_B_INT > 0
#  define PDCI_B1_INT_READ_FN(fn_name, targ_type) \
            PDCI_B1_INT_READ_FN_GEN(fn_name, targ_type)
#  define PDCI_B_INT_READ_FN(fn_name, targ_type, width, swapmem_op) \
            PDCI_B_INT_READ_FN_GEN(fn_name, targ_type, width, swapmem_op)
#else
#  define PDCI_B1_INT_READ_FN(fn_name, targ_type)
#  define PDCI_B_INT_READ_FN(fn_name, targ_type, width, swapmem_op)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && (P_CONFIG_EBC_INT > 0 || P_CONFIG_EBC_FPOINT > 0)
#  define PDCI_EBC_INT_READ_FN(fn_name, targ_type, bytes2num_fn, width) \
            PDCI_EBCBCDSB_INT_READ_FN_GEN(fn_name, targ_type, bytes2num_fn, P_INVALID_EBC_NUM, width, (begin, num_digits_or_bytes, &p1))
#else
#  define PDCI_EBC_INT_READ_FN(fn_name, targ_type, bytes2num_fn, width)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && (P_CONFIG_BCD_INT > 0 || P_CONFIG_BCD_FPOINT > 0)
#  define PDCI_BCD_INT_READ_FN(fn_name, targ_type, bytes2num_fn, width) \
            PDCI_EBCBCDSB_INT_READ_FN_GEN(fn_name, targ_type, bytes2num_fn, P_INVALID_BCD_NUM, width, (begin, num_digits_or_bytes, &p1))
#else
#  define PDCI_BCD_INT_READ_FN(fn_name, targ_type, bytes2num_fn, width)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && (P_CONFIG_SBL_INT > 0 || P_CONFIG_SBL_FPOINT > 0)
#  define PDCI_SBL_INT_READ_FN(fn_name, targ_type, bytes2num_fn, width) \
            PDCI_EBCBCDSB_INT_READ_FN_GEN(fn_name, targ_type, bytes2num_fn, P_UNEXPECTED_ERR, width, (pads, begin, num_digits_or_bytes, &p1))
#else
#  define PDCI_SBL_INT_READ_FN(fn_name, targ_type, bytes2num_fn, width)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && (P_CONFIG_SBH_INT > 0 || P_CONFIG_SBH_FPOINT > 0)
#  define PDCI_SBH_INT_READ_FN(fn_name, targ_type, bytes2num_fn, width) \
            PDCI_EBCBCDSB_INT_READ_FN_GEN(fn_name, targ_type, bytes2num_fn, P_UNEXPECTED_ERR, width, (pads, begin, num_digits_or_bytes, &p1))
#else
#  define PDCI_SBH_INT_READ_FN(fn_name, targ_type, bytes2num_fn, width)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_EBC_FPOINT > 0
#  define PDCI_EBC_FPOINT_READ_FN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max) \
            PDCI_EBCBCDSB_FPOINT_READ_FN_GEN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max)
#else
#  define PDCI_EBC_FPOINT_READ_FN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_BCD_FPOINT > 0
#  define PDCI_BCD_FPOINT_READ_FN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max) \
            PDCI_EBCBCDSB_FPOINT_READ_FN_GEN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max)
#else
#  define PDCI_BCD_FPOINT_READ_FN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_SBL_FPOINT > 0
#  define PDCI_SBL_FPOINT_READ_FN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max) \
            PDCI_EBCBCDSB_FPOINT_READ_FN_GEN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max)
#else
#  define PDCI_SBL_FPOINT_READ_FN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_SBH_FPOINT > 0
#  define PDCI_SBH_FPOINT_READ_FN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max) \
            PDCI_EBCBCDSB_FPOINT_READ_FN_GEN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max)
#else
#  define PDCI_SBH_FPOINT_READ_FN(fn_name, targ_type, internal_numerator_read_fn, width, dexp_max)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_A_FLOAT > 0
#  define PDCI_A_FLOAT_READ_FN(fn_pref, targ_type, bytes2num_fn) \
            PDCI_AE_FLOAT_READ_FN_GEN(fn_pref, targ_type, bytes2num_fn, P_INVALID_A_NUM, PDCI_ascii_is_space, PDCI_ascii_is_digit, PDCI_identity_charmap, "a_float")
#else
#  define PDCI_A_FLOAT_READ_FN(fn_pref, targ_type, bytes2num_fn)
#endif

#if P_CONFIG_READ_FUNCTIONS > 0 && P_CONFIG_E_FLOAT > 0
#  define PDCI_E_FLOAT_READ_FN(fn_pref, targ_type, bytes2num_fn) \
            PDCI_AE_FLOAT_READ_FN_GEN(fn_pref, targ_type, bytes2num_fn, P_INVALID_E_NUM, PDCI_ebcdic_is_space, PDCI_ebcdic_is_digit, P_mod_ae_tab, "e_float")
#else
#  define PDCI_E_FLOAT_READ_FN(fn_pref, targ_type, bytes2num_fn)
#endif

#endif  /*  __PADS_READ_MACROS_GEN_H__  */

