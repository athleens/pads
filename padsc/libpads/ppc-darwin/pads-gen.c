/*
 * WARNING: GENERATED FILE.  Do not edit this file, edit /Users/kfisher/pads/padsc/libpads/pads.c instead. 
 */

/*
 * library routines for library that goes with padsc
 *
 * Kathleen Fisher, Robert Gruber
 * AT&T Labs Research
 */

#include "pads-internal.h"
#include "pads-macros-gen.h"

static const char id[] = "\n@(#)$Id: pads.c,v 1.202 2006/07/31 21:29:53 kfisher Exp $\0\n";

static const char lib[] = "padsc";

/* ================================================================================ */ 
/* IMPL CONSTANTS */

#define PDCI_initStkElts      8

/* ================================================================================
 * ASCII CHAR TABLES
 */

/* Identity map */
int PDCI_identity_charmap[256] = {
  /* 0x0? */ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
  /* 0x1? */ 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
  /* 0x2? */ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
  /* 0x3? */ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
  /* 0x4? */ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
  /* 0x5? */ 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
  /* 0x6? */ 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
  /* 0x7? */ 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
  /* 0x8? */ 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
  /* 0x9? */ 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
  /* 0xA? */ 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
  /* 0xB? */ 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
  /* 0xC? */ 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
  /* 0xD? */ 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
  /* 0xE? */ 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
  /* 0xF? */ 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
};

/* ASCII digits are 0x3[0-9] */
int PDCI_ascii_digit[256] = {
  /* 0x0? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x1? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x2? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x3? */  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
  /* 0x4? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x5? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x6? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x7? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x8? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x9? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xA? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xB? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xC? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xD? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xE? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xF? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

/* ASCII digits are 0x3[0-9] */
int PDCI_ascii_is_digit[256] = {
  /* 0x0? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x1? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x2? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x3? */  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,
  /* 0x4? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x5? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x6? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x7? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x8? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x9? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xA? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xB? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xC? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xD? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xE? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xF? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
};

/* ASCII spaces : 0x09:HT, 0x0A:LF, 0x0B:VT, 0x0C:FF, 0x0D:CR, 0x20:SP */
int PDCI_ascii_is_space[256] = {
  /* 0x0? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  0,  0,
  /* 0x1? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x2? */  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x3? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x4? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x5? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x6? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x7? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x8? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x9? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xA? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xB? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xC? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xD? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xE? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xF? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
};

/* ================================================================================
 * EBCDIC CHAR TABLES : tables for EBCDIC char conversion
 *   -- from Andrew Hume (ng_ebcdic.c)
 *
 * ================================================================================ */

/* not-sign 0xac -> circumflex 0x5e */
/* non-spacing macron 0xaf -> tilde 0x7e */
Pbyte P_ea_tab[256] =
{
  /* 0x0? */ 0x00, 0x01, 0x02, 0x03, '?',  0x09, '?',  0x7f, '?',  '?',  '?',  0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  /* 0x1? */ 0x10, 0x11, 0x12, 0x13, '?',  '?',  0x08,'?',   0x18, 0x09, '?',  '?',  0x1c, 0x1d, 0x1e, 0x1f,
  /* 0x2? */ '?',  '?',  '?',  '?',  '?',  0x0a, 0x17, 0x1b, '?',  '?',  '?',  '?',  '?',  0x05, 0x06, 0x07,
  /* 0x3? */ '?',  '?',  0x16, '?',  '?',  '?',  '?',  0x04, '?',  '?',  '?',  '?',  0x14, 0x15, '?',  0x1a,
  /* 0x4? */ 0x20, '?',  '?',  '?',  '?',  '?',  '?', '?',   '?',  '?',  0x5b, 0x2e, 0x3c, 0x28, 0x2b, 0x21,
  /* 0x5? */ 0x26, '?',  '?',  '?',  '?',  '?',  '?', '?',   '?',  '?',  0x5d, 0x24, 0x2a, 0x29, 0x3b, 0x5e,
  /* 0x6? */ 0x2d, 0x2f, '?',  '?',  '?',  '?',  '?', '?',   '?',  '?',  0x7c, 0x2c, 0x25, 0x5f, 0x3e, 0x3f,
  /* 0x7? */ '?',  '?',  '?',  '?',  '?',  '?',  '?', '?',   '?',  0x60, 0x3a, 0x23, 0x40, 0x27, 0x3d, 0x22,
  /* 0x8? */ '?',  0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, '?',  '?',  '?',  '?',  '?', '?',
  /* 0x9? */ '?',  0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, '?',  '?',  '?',  '?',  '?', '?',
  /* 0xA? */ '?',  0x7e, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, '?',  '?',  '?',  '?',  '?', '?',
  /* 0xB? */ '?',  '?',  '?',  '?',  '?',  '?',  '?', '?',   '?',  '?',  '?',  '?',  '?',  '?',  '?', '?',
  /* 0xC? */ 0x7b, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, '?',  '?',  '?',  '?',  '?', '?',
  /* 0xD? */ 0x7d, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, '?',  '?',  '?',  '?',  '?', '?',
  /* 0xE? */ 0x5c, '?',  0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, '?',  '?',  '?',  '?',  '?', '?',
  /* 0xF? */ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, '?',  '?',  '?',  '?',  '?', '?',
};

Pbyte P_ae_tab[256] =
{
  /* 0x0? */ 0x00, 0x01, 0x02, 0x03, 0x37, 0x2d, 0x2e, 0x2f, 0x16, 0x19, 0x25, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 
  /* 0x1? */ 0x10, 0x11, 0x12, 0x13, 0x3c, 0x3d, 0x32, 0x26, 0x18, '?',  0x3f, 0x27, 0x1c, 0x1d, 0x1e, 0x1f, 
  /* 0x2? */ 0x40, 0x4f, 0x7f, 0x7b, 0x5b, 0x6c, 0x50, 0x7d, 0x4d, 0x5d, 0x5c, 0x4e, 0x6b, 0x60, 0x4b, 0x61, 
  /* 0x3? */ 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0x7a, 0x5e, 0x4c, 0x7e, 0x6e, 0x6f, 
  /* 0x4? */ 0x7c, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 
  /* 0x5? */ 0xd7, 0xd8, 0xd9, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0x4a, 0xe0, 0x5a, 0x5f, 0x6d, 
  /* 0x6? */ 0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 
  /* 0x7? */ 0x97, 0x98, 0x99, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xc0, 0x6a, 0xd0, 0xa1, 0x07, 
  /* 0x8? */ '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  
  /* 0x9? */ '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  
  /* 0xA? */ '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  
  /* 0xB? */ '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  
  /* 0xC? */ '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  
  /* 0xD? */ '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  
  /* 0xE? */ '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  
  /* 0xF? */ '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',  
};

/* Modified versions of the above tables.
 * replaced '?' with 0xff
 *    '?' is a valid character value ['?' ASCII char, EBCDIC SUB (substitute) character]
 * would rather use 0xff which is unspecified
 */

/* Note that both 0x05 and 0x19 map to ASCII 0x09.
 * This results in one more ea mapping than ae mapping
 */
Pbyte P_mod_ea_tab[256] =
{
  /* 0x0? */ 0x00, 0x01, 0x02, 0x03, 0xff, 0x09, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  /* 0x1? */ 0x10, 0x11, 0x12, 0x13, 0xff, 0xff, 0x08, 0xff, 0x18, 0x09, 0xff, 0xff, 0x1c, 0x1d, 0x1e, 0x1f,
  /* 0x2? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x17, 0x1b, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x06, 0x07,
  /* 0x3? */ 0xff, 0xff, 0x16, 0xff, 0xff, 0xff, 0xff, 0x04, 0xff, 0xff, 0xff, 0xff, 0x14, 0x15, 0xff, 0x1a,
  /* 0x4? */ 0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5b, 0x2e, 0x3c, 0x28, 0x2b, 0x21,
  /* 0x5? */ 0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5d, 0x24, 0x2a, 0x29, 0x3b, 0x5e,
  /* 0x6? */ 0x2d, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0x2c, 0x25, 0x5f, 0x3e, 0x3f,
  /* 0x7? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x60, 0x3a, 0x23, 0x40, 0x27, 0x3d, 0x22,
  /* 0x8? */ 0xff, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  /* 0x9? */ 0xff, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  /* 0xA? */ 0xff, 0x7e, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  /* 0xB? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  /* 0xC? */ 0x7b, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  /* 0xD? */ 0x7d, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  /* 0xE? */ 0x5c, 0xff, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  /* 0xF? */ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

Pbyte P_mod_ae_tab[256] =
{
  /* 0x0? */ 0x00, 0x01, 0x02, 0x03, 0x37, 0x2d, 0x2e, 0x2f, 0x16, 0x19, 0x25, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 
  /* 0x1? */ 0x10, 0x11, 0x12, 0x13, 0x3c, 0x3d, 0x32, 0x26, 0x18, 0xff, 0x3f, 0x27, 0x1c, 0x1d, 0x1e, 0x1f, 
  /* 0x2? */ 0x40, 0x4f, 0x7f, 0x7b, 0x5b, 0x6c, 0x50, 0x7d, 0x4d, 0x5d, 0x5c, 0x4e, 0x6b, 0x60, 0x4b, 0x61, 
  /* 0x3? */ 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0x7a, 0x5e, 0x4c, 0x7e, 0x6e, 0x6f, 
  /* 0x4? */ 0x7c, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 
  /* 0x5? */ 0xd7, 0xd8, 0xd9, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0x4a, 0xe0, 0x5a, 0x5f, 0x6d, 
  /* 0x6? */ 0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 
  /* 0x7? */ 0x97, 0x98, 0x99, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xc0, 0x6a, 0xd0, 0xa1, 0x07, 
  /* 0x8? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  /* 0x9? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  /* 0xA? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  /* 0xB? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  /* 0xC? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  /* 0xD? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  /* 0xE? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  /* 0xF? */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
};

/* EBCDIC digits are 0xC[0-9], 0xD[0-9], 0XF[0-9] */
/* aka 192-201, 208-217, 240-249 */
int PDCI_ebcdic_digit[256] = {
  /* 0x0? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x1? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x2? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x3? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x4? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x5? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x6? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x7? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x8? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0x9? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xA? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xB? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xC? */  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
  /* 0xD? */  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
  /* 0xE? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xF? */  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
};

/* EBCDIC digits are 0xC[0-9], 0xD[0-9], 0XF[0-9] */
int PDCI_ebcdic_is_digit[256] = {
  /* 0x0? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x1? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x2? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x3? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x4? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x5? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x6? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x7? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x8? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x9? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xA? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xB? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xC? */  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,
  /* 0xD? */  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,
  /* 0xE? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xF? */  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,
};

/* EBCDIC spaces : 0x05:HT, 0x0B:VT, 0x0C:FF, 0x0D:CR, 0x15:NL, 0x40:SP */
int PDCI_ebcdic_is_space[256] = {
  /* 0x0? */  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,
  /* 0x1? */  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x2? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x3? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x4? */  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x5? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x6? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x7? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x8? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x9? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xA? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xB? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xC? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xD? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xE? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xF? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
};

/* ================================================================================
 * BCD TABLES : tables for BCD conversion
 *     -- from Andrew Hume (ng_bcd.c)
 *
 * ================================================================================ */

int PDCI_bcd_hilo_digits[256] = {
  /* 0x0? */  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
  /* 0x1? */ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, -1, -1, -1, -1, -1, -1,
  /* 0x2? */ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, -1, -1, -1, -1, -1, -1,
  /* 0x3? */ 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, -1, -1, -1, -1, -1, -1,
  /* 0x4? */ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, -1, -1, -1, -1, -1, -1,
  /* 0x5? */ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, -1, -1, -1, -1, -1, -1,
  /* 0x6? */ 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, -1, -1, -1, -1, -1, -1,
  /* 0x7? */ 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, -1, -1, -1, -1, -1, -1,
  /* 0x8? */ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, -1, -1, -1, -1, -1, -1,
  /* 0x9? */ 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, -1, -1, -1, -1, -1, -1,
  /* 0xA? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xB? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xC? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xD? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xE? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xF? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

#if 0 
/* HUME version */
int PDCI_bcd_hilo_digits[256] = {
  /* 0x0? */  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  0,  0,  0,  0,  0,
  /* 0x1? */ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 10, 10, 10, 10, 10, 10,
  /* 0x2? */ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 20, 20, 20, 20, 20, 20,
  /* 0x3? */ 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 30, 30, 30, 30, 30, 30,
  /* 0x4? */ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 40, 40, 40, 40, 40, 40,
  /* 0x5? */ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 50, 50, 50, 50, 50, 50,
  /* 0x6? */ 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 60, 60, 60, 60, 60, 60,
  /* 0x7? */ 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 70, 70, 70, 70, 70, 70,
  /* 0x8? */ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 80, 80, 80, 80, 80, 80,
  /* 0x9? */ 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 90, 90, 90, 90, 90, 90,
  /* 0xA? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xB? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xC? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xD? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xE? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xF? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
};
#endif

int PDCI_bcd_hi_digit[256] = {
  /* 0x0? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x1? */  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
  /* 0x2? */  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
  /* 0x3? */  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
  /* 0x4? */  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
  /* 0x5? */  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
  /* 0x6? */  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
  /* 0x7? */  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
  /* 0x8? */  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,
  /* 0x9? */  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
  /* 0xA? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xB? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xC? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xD? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xE? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xF? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

#if 0
/* HUME version */
int PDCI_bcd_hi_digit[256] = {
  /* 0x0? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0x1? */  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
  /* 0x2? */  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
  /* 0x3? */  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
  /* 0x4? */  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
  /* 0x5? */  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
  /* 0x6? */  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
  /* 0x7? */  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
  /* 0x8? */  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,
  /* 0x9? */  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
  /* 0xA? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xB? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xC? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xD? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xE? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  /* 0xF? */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
};
#endif

#if 0
/* XXX the only valid 2nd nible is  C, D, or F, so an alternate
 * XXX form of the above would be: */
int PDCI_bcd_hi_digit[256] = {
  /* 0x0? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0, -1,  0,
  /* 0x1? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1, -1,  1,
  /* 0x2? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  2,  2, -1,  2,
  /* 0x3? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  3,  3, -1,  3,
  /* 0x4? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  4,  4, -1,  4,
  /* 0x5? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  5,  5, -1,  5,
  /* 0x6? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  6,  6, -1,  6,
  /* 0x7? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  7,  7, -1,  7,
  /* 0x8? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  8,  8, -1,  8,
  /* 0x9? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  9,  9, -1,  9,
  /* 0xA? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xB? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xC? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xD? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xE? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* 0xF? */ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};
#endif

/* ================================================================================
 * MISC TABLES
 * ================================================================================ */

Puint64 PDCI_10toThe[] = {
  /* 10^0  = */                          1ULL,
  /* 10^1  = */                         10ULL,
  /* 10^2  = */                        100ULL,
  /* 10^3  = */                       1000ULL,
  /* 10^4  = */                      10000ULL,
  /* 10^5  = */                     100000ULL,
  /* 10^6  = */                    1000000ULL,
  /* 10^7  = */                   10000000ULL,
  /* 10^8  = */                  100000000ULL,
  /* 10^9  = */                 1000000000ULL,
  /* 10^10 = */                10000000000ULL,
  /* 10^11 = */               100000000000ULL,
  /* 10^12 = */              1000000000000ULL,
  /* 10^13 = */             10000000000000ULL,
  /* 10^14 = */            100000000000000ULL,
  /* 10^15 = */           1000000000000000ULL,
  /* 10^16 = */          10000000000000000ULL,
  /* 10^17 = */         100000000000000000ULL,
  /* 10^18 = */        1000000000000000000ULL,
  /* 10^19 = */       10000000000000000000ULL
};

/* ================================================================================
 * MISC STRING CONSTANTS
 * ================================================================================ */

/* used for indent, max length 128 */ 
const char *PDCI_spaces = "                                                                                                                                                                                                                                                                 ";

/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * EXTERNAL FUNCTIONS (see pads.h)
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */

/* ================================================================================ */ 
/* EXTERNAL ERROR REPORTING FUNCTIONS */

int
P_error(const char *libnm, int level, ...)
{
  va_list ap;
  va_start(ap, level);
  errorv(libnm, (libnm ? level|ERROR_LIBRARY : level), ap);
  va_end(ap);
  return 0;
}

/* ================================================================================ */ 
/* EXTERNAL INVOKE HELPERS */

Perror_t
P_invoke_inv_val_fn(Pinv_val_fn fn, P_t *pads, void *pd_void, void *val_void, ...)
{
  Perror_t  res;
  va_list   type_args;

  va_start(type_args, val_void);
  res = fn(pads, pd_void, val_void, type_args);
  va_end(type_args);
  return res;
}

ssize_t
P_invoke_fmt_fn(Pfmt_fn fn, P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
		int *requested_out, const char *delims,
		void *m, void *pd, void *rep, ...)
{
  ssize_t   res;
  va_list   type_args;

  va_start(type_args, rep);
  res = fn(pads, buf, buf_len, buf_full, requested_out, delims, m, pd, rep, type_args);
  va_end(type_args);
  return res;
}

/* ================================================================================ */
/* EXTERNAL LIBRARY TOP-LEVEL OPEN/CLOSE FUNCTIONS */

/* The default disc */
Pdisc_t Pdefault_disc = {
  P_VERSION,
  (Pflags_t)P_NULL_CTL_FLAG,
  Pcharset_ASCII,
  0, /* string read functions do not copy strings */
  0, /* match_max:   0 means end-of-record / soft limit for non-record-based IO disciplines */
  0, /* numeric_max: 0 means end-of-record / soft limit for non-record-based IO disciplines */
  0, /* scan_max:    0 means end-of-record / soft limit for non-record-based IO disciplines */
  0, /* panic_max:   0 means end-of-record / soft limit for non-record-based IO disciplines */
  P_fopen,
  P_error,
  PerrorRep_Max,
  PlittleEndian,
  1000,   /* default max2track */
  10,     /* default max2rep   */
  100,    /* default pcnt2rep  */
  "UTC",  /* in_time_zone      */
  "UTC",  /* out_time_zone     */
  {
    /* default input formats */
    "%m%d%y+%H%M%S%|%m%d%y+%H:%M:%S%|%m%d%Y+%H%M%S%|%m%d%Y+%H:%M:%S%|%&",    /* timestamp */
    "%m%d%y%|%m%d%Y%|%&",      /* date */
    "%H%M%S%|%H:%M:%S%|%&"     /* time */
  },

  {
    /* default output formats */
    "%K",            /* timestamp_explicit */
    "%K",            /* timestamp */
    "%Y-%m-%d",      /* date_explicit */
    "%Y-%m-%d",      /* date */
    "%H:%M:%S",      /* time_explicit */
    "%H:%M:%S"       /* time */
  },

  0,    /* by default, no inv_val_fn map */
  0,    /* by default, no fmt_fn map */
  0     /* a default IO discipline is installed on P_open */
};

Tm_zone_t*
PDCI_cstr2timezone(P_t *pads, const char *zone_str, const char *whatfn)
{
  size_t   expected_len, actual_len;
  char    *end;
  Tm_zone_t *res;

  PDCI_NULLPARAM_CHECK_RET_0("P_cstr2timezone", zone_str);
  expected_len = strlen(zone_str);
  res = tmzone(zone_str, &end, 0, 0);
  if (!res) {
    P_WARN2(pads ? pads->disc : &Pdefault_disc, "%s: failed to parse time zone '%s'", whatfn, zone_str);
    return NULL;
  }
  actual_len = end - zone_str;
  if (actual_len != expected_len) {
    P_WARN5(pads ? pads->disc : &Pdefault_disc, "%s: ignoring extra characters at end of time zone string: %.*s>>%.*s<<",
	    whatfn, actual_len, zone_str, expected_len - actual_len, zone_str + actual_len);
  }
  return res;
}

Tm_zone_t*
P_cstr2timezone(const char *zone_str)
{
  return PDCI_cstr2timezone(NULL, zone_str, "P_cstr2timezone");
}

Perror_t
PDCI_set_in_time_zone(P_t *pads, const char *new_in_time_zone, const char *whatfn)
{
  if (!(pads->in_zone = PDCI_cstr2timezone(pads, new_in_time_zone, whatfn))) {
    return P_ERR;
  }
  pads->disc->in_time_zone = new_in_time_zone;
  return P_OK;
}

Perror_t
PDCI_set_out_time_zone(P_t *pads, const char *new_out_time_zone, const char *whatfn)
{
  if (!(pads->out_zone = PDCI_cstr2timezone(pads, new_out_time_zone, whatfn))) {
    return P_ERR;
  }
  pads->disc->out_time_zone = new_out_time_zone;
  return P_OK;
}

Perror_t
P_set_in_time_zone(P_t *pads, const char *new_in_time_zone)
{
  return PDCI_set_in_time_zone(pads, new_in_time_zone, "P_set_in_time_zone");
}

Perror_t
P_set_out_time_zone(P_t *pads, const char *new_out_time_zone)
{
  return PDCI_set_out_time_zone(pads, new_out_time_zone, "P_set_out_time_zone");
}

Perror_t
PDCI_libopen(P_t **pads_out, Pdisc_t *disc, Pio_disc_t *io_disc, int iodisc_required, const char *whatfn)
{
  Vmalloc_t    *vm;
  P_t          *pads;
  Pint32        testint = 2;

  P_TRACE2(&Pdefault_disc, "PDCI_libopen called, iodisc_required = %d whatfn = %s",
	   iodisc_required, whatfn);
  if (!pads_out) {
    P_WARN1(&Pdefault_disc, "%s: param pads_out must not be NULL", whatfn);
    return P_ERR;
  }
  if (!(vm = vmopen(Vmdcheap, Vmbest, 0))) {
    goto fatal_alloc_err;
  }
  if (!disc) { /* copy the default discipline */
    if (!(disc = vmnewof(vm, 0, Pdisc_t, 1, 0))) {
      disc = &Pdefault_disc;
      goto fatal_alloc_err;
    }
    (*disc) = Pdefault_disc;
  }
  if (io_disc) {
    disc->io_disc = io_disc;
  } else if (iodisc_required && !disc->io_disc) {
    P_WARN1(disc, "%s: Installing default IO discipline : newline-terminated records", whatfn);
    if (!(disc->io_disc = P_ctrec_noseek_make('\n', 0))) {
      P_FATAL1(disc, "%s: Unexpected failure to install default IO discipline", whatfn);
    }
  }
  if (!(pads = vmnewof(vm, 0, P_t, 1, 0))) {
    goto fatal_alloc_err;
  }
  /* allocate a 1 MB + 1 byte buffer to use with sfio */
  if (!(pads->sfbuf = vmoldof(vm, 0, Pbyte, 1024 * 1024, 1))) {
    goto fatal_alloc_err;
  }
  pads->outbuf_len = 1024 * 64;
  pads->outbuf_res = 1024 * 32;
  if (!(pads->outbuf = vmoldof(vm, 0, Pbyte, pads->outbuf_len, 1))) {
    goto fatal_alloc_err;
  }
  pads->inestlev = 0;
  if (!(pads->tmp1 = sfstropen())) {
    goto fatal_alloc_err;
  }
  if (!(pads->tmp2 = sfstropen())) {
    goto fatal_alloc_err;
  }
  if (!(pads->tmp3 = sfstropen())) {
    goto fatal_alloc_err;
  }
  if (!(pads->tmp4 = sfstropen())) {
    goto fatal_alloc_err;
  }
  if (!(pads->rmm_z = RMM_open(RMM_zero_disc_ptr))) {
    goto fatal_alloc_err;
  }
  if (!(pads->rmm_nz = RMM_open(RMM_nozero_disc_ptr))) {
    goto fatal_alloc_err;
  }
  pads->m_endian = (((char*)(&testint))[0]) ? PlittleEndian : PbigEndian;
  pads->id          = lib;
  pads->vm          = vm;
  pads->disc        = disc;
  if (!(pads->head = vmnewof(vm, 0, Pio_elt_t, 1, 0))) {
    goto fatal_alloc_err;
  }
  pads->head->next = pads->head;
  pads->head->prev = pads->head;

  pads->salloc = PDCI_initStkElts;
  if (!(pads->stack = vmnewof(vm, 0, PDCI_stkElt_t, pads->salloc, 0))) {
    goto fatal_alloc_err;
  }
  Pstring_init(pads, &pads->stmp1);
  Pstring_init(pads, &pads->stmp2);
  /* These fields are 0/NiL due to zero-based alloc of pads:
   *   path, io_state, top, buf, balloc, bchars, speclev
   */
  (*pads_out) = pads;
  P_lib_init();
  if (!(pads->disc->in_time_zone)) {
    P_WARN1(pads->disc, "%s: pads->disc->in_time_zone is null, replacing with 'UTC'", whatfn);
    pads->disc->in_time_zone = "UTC";
  }
  if (P_ERR == PDCI_set_in_time_zone(pads, pads->disc->in_time_zone, whatfn)) {
    P_WARN1(pads->disc, "%s: pads->disc->in_time_zone invalid, replacing with 'UTC'", whatfn);
    pads->disc->in_time_zone = "UTC";
    PDCI_set_in_time_zone(pads, pads->disc->in_time_zone, whatfn);
  }
  if (!(pads->disc->out_time_zone)) {
    P_WARN1(pads->disc, "%s: pads->disc->out_time_zone is null, replacing with 'UTC'", whatfn);
    pads->disc->out_time_zone = "UTC";
  }
  if (P_ERR == PDCI_set_out_time_zone(pads, pads->disc->out_time_zone, whatfn)) {
    P_WARN1(pads->disc, "%s: pads->disc->out_time_zone invalid, replacing with 'UTC'", whatfn);
    pads->disc->out_time_zone = "UTC";
    PDCI_set_out_time_zone(pads, pads->disc->out_time_zone, whatfn);
  }
  return P_OK;

 fatal_alloc_err:
  P_FATAL(disc, "out of space error during PDCI_libopen");
#if 0
  /* P_FATAL halts program, so the following is not needed */
  if (pads) {
    if (pads->rmm_z) {
      RMM_close(pads->rmm_z);
    }
    if (pads->rmm_nz) {
      RMM_close(pads->rmm_nz);
    }
    if (pads->tmp1) {
      sfstrclose(pads->tmp1);
    }
    if (pads->tmp2) {
      sfstrclose(pads->tmp2);
    }
    if (pads->tmp3) {
      sfstrclose(pads->tmp3);
    }
    if (pads->tmp4) {
      sfstrclose(pads->tmp4);
    }
  }
  if (vm) {
    vmclose(vm);
  }
#endif
  return P_ERR;
}

Perror_t
P_open(P_t **pads_out, Pdisc_t *disc, Pio_disc_t *io_disc)
{
  return PDCI_libopen(pads_out, disc, io_disc, 1, "P_open");
}

Perror_t
P_libopen(P_t **pads_out, Pdisc_t *disc, Pio_disc_t *io_disc, int iodisc_required)
{
  return PDCI_libopen(pads_out, disc, io_disc, iodisc_required, "P_libopen");
}

Perror_t
P_close_keep_io_disc(P_t *pads, int keep_io_disc)
{

  PDCI_DISC_0P_CHECKS("P_close");
  Pstring_cleanup(pads, &pads->stmp1);
  Pstring_cleanup(pads, &pads->stmp2);
  if (pads->disc->io_disc && !keep_io_disc) {
    pads->disc->io_disc->unmake_fn(pads->disc->io_disc);
  }
  pads->disc->io_disc = 0;
  if (pads->rmm_z) {
    RMM_close(pads->rmm_z);
  }
  if (pads->rmm_nz) {
    RMM_close(pads->rmm_nz);
  }
  if (pads->tmp1) {
    sfstrclose(pads->tmp1);
  }
  if (pads->tmp2) {
    sfstrclose(pads->tmp2);
  }
  if (pads->vm) {
    vmclose(pads->vm); /* frees everything alloc'd using vm */
  }
  RBUF_DBG_REPORT("At end of P_close");
  IODISC_DBG_REPORT("At end of P_close");
  return P_OK;
}

Perror_t
P_close(P_t *pads)
{
  return P_close_keep_io_disc(pads, 0);
}

/* ================================================================================ */
/* EXTERNAL DISCIPLINE GET/SET FUNCTIONS */

Pdisc_t *
P_get_disc(P_t *pads)
{
  return (pads ? pads->disc : 0);
}

Perror_t
P_set_disc(P_t *pads, Pdisc_t *new_disc, int xfer_io)
{
  PDCI_DISC_1P_CHECKS("P_set_disc", new_disc);
  if (xfer_io) {
    if (new_disc->io_disc) {
      P_WARN(pads->disc, "P_set_disc: Cannot transfer IO discipline when new_disc->io_disc is non-NULL");
      return P_ERR;
    }
    new_disc->io_disc = pads->disc->io_disc;
    pads->disc->io_disc = 0;
  }
  pads->disc = new_disc;
  return P_OK;
}

Perror_t
P_set_io_disc_keep_old(P_t* pads, Pio_disc_t* new_io_disc, int keep_old_io_disc)
{
  PDCI_stkElt_t    *bot       = &(pads->stack[0]);
  Pio_elt_t     *io_elt    = bot->elt;
  size_t           io_remain  = bot->remain;

  PDCI_DISC_1P_CHECKS("P_set_disc", new_io_disc);
  if (pads->top != 0) {
    P_WARN(pads->disc, "P_set_io_disc: cannot change IO discipline "
	     "in the middle of a speculative read function (e.g., union, ...)");
    return P_ERR;
  }
  if (pads->io && pads->disc->io_disc) {
    /* do a clean sfclose */
    if (P_ERR == pads->disc->io_disc->sfclose_fn(pads, pads->disc->io_disc, io_elt, io_remain)) {
      /* XXX perhaps it was not open?? */
    }
  }
  if (pads->disc->io_disc && !keep_old_io_disc) {
    /* unmake the previous discipline */
    if (P_ERR == pads->disc->io_disc->unmake_fn(pads->disc->io_disc)) {
      /* XXX report an error ??? */
    }
  }
  pads->disc->io_disc = new_io_disc;
  if (pads->io) {
    if (P_ERR == pads->disc->io_disc->sfopen_fn(pads, new_io_disc, pads->io, pads->head)) {
      /* XXX report an error ??? */
    }
  }
  return P_OK;
}

Perror_t
P_set_io_disc(P_t* pads, Pio_disc_t* new_io_disc)
{
  return P_set_io_disc_keep_old(pads, new_io_disc, 0);
}

/* ================================================================================ */
/* EXTERNAL RMM ACCESSORS */

RMM_t *
P_rmm_zero(P_t *pads)
{
  return (pads ? pads->rmm_z : 0);
}

RMM_t *
P_rmm_nozero(P_t *pads)
{
  return (pads ? pads->rmm_nz : 0);
}

/* ================================================================================ */
/* EXTERNAL inv_val FUNCTIONS */

/* Type Pinv_val_fn_map_t: */
struct Pinv_val_fn_map_s {
  Dt_t *dt;
};

typedef struct PDCI_inv_val_fn_elt_s {
  Dtlink_t        link;
  const char     *key;
  Pinv_val_fn     val;
} PDCI_inv_val_fn_elt_t;

void*
PDCI_inv_val_fn_elt_make(Dt_t *dt, PDCI_inv_val_fn_elt_t *a, Dtdisc_t *disc)
{
  PDCI_inv_val_fn_elt_t *b;
  if ((b = oldof(0, PDCI_inv_val_fn_elt_t, 1, 0))) {
    b->key  = a->key;
    b->val  = a->val;
  }
  return b;
}

void
PDCI_inv_val_fn_elt_free(Dt_t *dt, PDCI_inv_val_fn_elt_t *a, Dtdisc_t *disc)
{
  free(a);
}

static Dtdisc_t PDCI_inv_val_fn_map_disc = {
  DTOFFSET(PDCI_inv_val_fn_elt_t, key),     /* key     */
  -1,                                       /* size    */
  DTOFFSET(PDCI_inv_val_fn_elt_t, link),    /* link    */
  (Dtmake_f)PDCI_inv_val_fn_elt_make,       /* makef   */
  (Dtfree_f)PDCI_inv_val_fn_elt_free,       /* freef   */
  NiL,                                      /* comparf */
  NiL,                                      /* hashf   */
  NiL,                                      /* memoryf */
  NiL                                       /* eventf  */
};

Pinv_val_fn_map_t*
Pinv_val_fn_map_create(P_t *pads)
{
  Pinv_val_fn_map_t *map; 

  PDCI_DISC_0P_CHECKS_RET_0("Pinv_val_fn_map_create");
  if (!pads->vm) {
    P_WARN(pads->disc, "Pinv_val_fn_map_create: pads handle not initialized properly");
    return 0;
  }
  if (!(map = vmnewof(pads->vm, 0, Pinv_val_fn_map_t, 1, 0))) {
    goto alloc_err;
  }
  if (!(map->dt = dtopen(&PDCI_inv_val_fn_map_disc, Dtset))) {
    vmfree(pads->vm, map);
    goto alloc_err;
  }
  return map;

 alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, "Pinv_val_fn_map_create", "Memory alloc error");
  return 0;
}

Perror_t
Pinv_val_fn_map_destroy(P_t *pads, Pinv_val_fn_map_t *map)
{
  PDCI_DISC_1P_CHECKS("Pinv_val_fn_map_destroy", map);
  if (map->dt) {
    dtclose(map->dt);
    map->dt = 0;
  }
  if (pads->vm) {
    vmfree(pads->vm, map);
  }
  return P_OK;
}

Perror_t
Pinv_val_fn_map_clear(P_t *pads, Pinv_val_fn_map_t *map)
{
  PDCI_DISC_1P_CHECKS("Pinv_val_fn_map_clear", map);
  if (map->dt) {
    dtclear(map->dt);
    return P_OK;
  }
  return P_ERR;
}

Pinv_val_fn
P_get_inv_val_fn(P_t* pads, Pinv_val_fn_map_t *map, const char *type_name)
{
  PDCI_inv_val_fn_elt_t *tmp;

  PDCI_DISC_2P_CHECKS_RET_0("P_get_inv_val_fn", map, type_name);
#ifndef NDEBUG
  if (!map->dt) {
    P_WARN(pads->disc, "P_get_inv_val_fn: map not initialized properly");
    return 0;
  }
#endif
  if ((tmp = dtmatch(map->dt, type_name))) {
    return tmp->val;
  }
  return 0;
}
 
Pinv_val_fn
P_set_inv_val_fn(P_t* pads, Pinv_val_fn_map_t *map, const char *type_name, Pinv_val_fn fn)
{
  Pinv_val_fn             res = 0;
  PDCI_inv_val_fn_elt_t  *tmp;
  PDCI_inv_val_fn_elt_t   insert_elt;

  PDCI_DISC_2P_CHECKS_RET_0("P_set_inv_val_fn", map, type_name);
#ifndef NDEBUG
  if (!map->dt) {
    P_WARN(pads->disc, "P_set_inv_val_fn: map not initialized properly");
    return 0;
  }
#endif
  if ((tmp = dtmatch(map->dt, type_name))) {
    res = tmp->val;
    tmp->val = fn;
    return res;
  }
  if (fn) {
    insert_elt.key = type_name;
    insert_elt.val = fn;
    if (!(tmp = dtinsert(map->dt, &insert_elt))) {
      P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
    }
  }
  return 0;
}

/* ================================================================================ */
/* EXTERNAL fmt FUNCTIONS */

/* Type Pfmt_fn_map_t: */
struct Pfmt_fn_map_s {
  Dt_t *dt;
};

typedef struct PDCI_fmt_fn_elt_s {
  Dtlink_t        link;
  const char     *key;
  Pfmt_fn         val;
} PDCI_fmt_fn_elt_t;

void*
PDCI_fmt_fn_elt_make(Dt_t *dt, PDCI_fmt_fn_elt_t *a, Dtdisc_t *disc)
{
  PDCI_fmt_fn_elt_t *b;
  if ((b = oldof(0, PDCI_fmt_fn_elt_t, 1, 0))) {
    b->key  = a->key;
    b->val  = a->val;
  }
  return b;
}

void
PDCI_fmt_fn_elt_free(Dt_t *dt, PDCI_fmt_fn_elt_t *a, Dtdisc_t *disc)
{
  free(a);
}

static Dtdisc_t PDCI_fmt_fn_map_disc = {
  DTOFFSET(PDCI_fmt_fn_elt_t, key),         /* key     */
  -1,                                       /* size    */
  DTOFFSET(PDCI_fmt_fn_elt_t, link),        /* link    */
  (Dtmake_f)PDCI_fmt_fn_elt_make,           /* makef   */
  (Dtfree_f)PDCI_fmt_fn_elt_free,           /* freef   */
  NiL,                                      /* comparf */
  NiL,                                      /* hashf   */
  NiL,                                      /* memoryf */
  NiL                                       /* eventf  */
};

Pfmt_fn_map_t*
Pfmt_fn_map_create(P_t *pads)
{
  Pfmt_fn_map_t *map; 

  PDCI_DISC_0P_CHECKS_RET_0("Pfmt_fn_map_create");
  if (!pads->vm) {
    P_WARN(pads->disc, "Pfmt_fn_map_create: pads handle not initialized properly");
    return 0;
  }
  if (!(map = vmnewof(pads->vm, 0, Pfmt_fn_map_t, 1, 0))) {
    goto alloc_err;
  }
  if (!(map->dt = dtopen(&PDCI_fmt_fn_map_disc, Dtset))) {
    vmfree(pads->vm, map);
    goto alloc_err;
  }
  return map;

 alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, "Pfmt_fn_map_create", "Memory alloc error");
  return 0;
}

Perror_t
Pfmt_fn_map_destroy(P_t *pads, Pfmt_fn_map_t *map)
{
  PDCI_DISC_1P_CHECKS("Pfmt_fn_map_destroy", map);
  if (map->dt) {
    dtclose(map->dt);
    map->dt = 0;
  }
  if (pads->vm) {
    vmfree(pads->vm, map);
  }
  return P_OK;
}

Perror_t
Pfmt_fn_map_clear(P_t *pads, Pfmt_fn_map_t *map)
{
  PDCI_DISC_1P_CHECKS("Pfmt_fn_map_clear", map);
  if (map->dt) {
    dtclear(map->dt);
    return P_OK;
  }
  return P_ERR;
}

Pfmt_fn
P_get_fmt_fn(P_t* pads, Pfmt_fn_map_t *map, const char *type_name)
{
  PDCI_fmt_fn_elt_t *tmp;

  PDCI_DISC_2P_CHECKS_RET_0("P_get_fmt_fn", map, type_name);
#ifndef NDEBUG
  if (!map->dt) {
    P_WARN(pads->disc, "P_get_fmt_fn: map not initialized properly");
    return 0;
  }
#endif
  if ((tmp = dtmatch(map->dt, type_name))) {
    return tmp->val;
  }
  return 0;
}
 
Pfmt_fn
P_set_fmt_fn(P_t* pads, Pfmt_fn_map_t *map, const char *type_name, Pfmt_fn fn)
{
  Pfmt_fn             res = 0;
  PDCI_fmt_fn_elt_t  *tmp;
  PDCI_fmt_fn_elt_t   insert_elt;

  PDCI_DISC_2P_CHECKS_RET_0("P_set_fmt_fn", map, type_name);
#ifndef NDEBUG
  if (!map->dt) {
    P_WARN(pads->disc, "P_set_fmt_fn: map not initialized properly");
    return 0;
  }
#endif
  if ((tmp = dtmatch(map->dt, type_name))) {
    res = tmp->val;
    tmp->val = fn;
    return res;
  }
  if (fn) {
    insert_elt.key = type_name;
    insert_elt.val = fn;
    if (!(tmp = dtinsert(map->dt, &insert_elt))) {
      P_WARN(pads->disc, "** PADSC internal error: dtinsert failed (out of memory?) **");
    }
  }
  return 0;
}

/* ================================================================================ */
/* EXTERNAL IO FUNCTIONS */

const char *
P_io_read_unit(P_t *pads)
{
  PDCI_IODISC_INIT_CHECKS_RET_0("P_io_read_unit");
  return pads->disc->io_disc->read_unit_fn(pads, pads->disc->io_disc);
}

Perror_t
P_io_set(P_t *pads, Sfio_t *io)
{
  PDCI_IODISC_1P_CHECKS("P_io_set", io);
  if (pads->io) {
    if (pads->path && strcmp(pads->path, "/dev/stdin")) {
      P_WARN(pads->disc, "IO_set called with previous installed io due to fopen; closing");
    }
    P_io_close(pads);
    /* path and io are no longer set */
  }
  return PDCI_io_install_io(pads, io);
}

Perror_t
P_io_fopen(P_t *pads, const char *path)
{
  Sfio_t           *io; 
  Pfopen_fn         fopen_fn;

  PDCI_IODISC_1P_CHECKS("P_io_fopen", path);
  if (pads->io) {
    if (pads->path && strcmp(pads->path, "/dev/stdin")) {
      P_WARN(pads->disc, "IO_fopen called while previous file still open; closing");
    }
    P_io_close(pads);
    /* path and io are no longer set */
  }
  if (!(pads->path = vmnewof(pads->vm, 0, char, strlen(path) + 1, 0))) {
    P_FATAL(pads->disc, "out of space [string to record file path]");
    return P_ERR;
  }
  strcpy(pads->path, path);
  fopen_fn = (pads->disc->fopen_fn) ? pads->disc->fopen_fn : P_fopen;
  if (!(io = fopen_fn(path, "r"))) {
    if (errno) {
      P_SYSERR1(pads->disc, "Failed to open file \"%s\"", path);
    } else {
      P_WARN1(pads->disc, "Failed to open file \"%s\"", path);
    }
    vmfree(pads->vm, pads->path);
    pads->path = 0;
    return P_ERR;
  }
  return PDCI_io_install_io(pads, io);
}

Perror_t
P_io_close(P_t *pads)
{
  PDCI_stkElt_t    *bot;
  Pio_elt_t     *io_elt;
  size_t           io_remain;

  PDCI_DISC_0P_CHECKS("P_io_close");
  bot        = &(pads->stack[0]);
  io_elt     = bot->elt;
  io_remain  = bot->remain;

  if (!pads->io) {
    return P_ERR;
  }
  /* close IO discpline */
  if (pads->disc->io_disc) {
    pads->disc->io_disc->sfclose_fn(pads, pads->disc->io_disc, io_elt, io_remain);
  }
  if (pads->path && strcmp(pads->path, "/dev/stdin")) {
    sfclose(pads->io);
  }
  if (pads->vm && pads->path) {
    vmfree(pads->vm, pads->path);
  }
  pads->io = 0;
  pads->path = 0;
  return P_OK;
}

Perror_t
P_io_next_rec(P_t *pads, size_t *skipped_bytes_out) {
  PDCI_stkElt_t    *tp;
  Pio_elt_t        *keep_elt;
  Pio_elt_t        *next_elt;
  int               prev_eor;

  PDCI_IODISC_1P_CHECKS("P_io_next_rec", skipped_bytes_out);
  tp                    = &(pads->stack[pads->top]);
  (*skipped_bytes_out)  = 0;
  if (pads->disc->io_disc->rec_based == 0) {
    P_WARN(pads->disc, "P_io_next_rec called when pads->disc->io_disc does not support records");
    return P_ERR;
  }
  while (1) {
    prev_eor = tp->elt->eor;
    (*skipped_bytes_out) += tp->remain;
    tp->remain = 0;
    if (tp->elt->eof) {
      return P_ERR;
    }
    /* advance IO cursor */
    if (tp->elt->next != pads->head) {
      tp->elt = tp->elt->next;
    } else {
      /* use IO disc read_fn */
      keep_elt = pads->stack[0].elt;
      if (P_ERR == pads->disc->io_disc->read_fn(pads, pads->disc->io_disc, keep_elt, &next_elt)) {
	tp->elt = P_LAST_ELT(pads->head); /* IO disc may have added eof elt */
	tp->remain = 0;
	return P_ERR;
      }
#ifndef NDEBUG
      if (next_elt == pads->head) { /* should not happen */
	P_FATAL(pads->disc, "Internal error, P_io_next_rec observed incorrect read_fn behavior");
	return P_ERR;
      }
#endif
      tp->elt = next_elt;
    }
    tp->remain = tp->elt->len;
    if (prev_eor) { /* we just advanced past an EOR */
      break;
    }
    /* just advanced past a partial read -- continue while loop */
  }
  return P_OK;
}

Perror_t
P_io_skip_bytes(P_t *pads, size_t width, size_t *skipped_bytes_out) {
  size_t            skipped;
  PDCI_IO_NEED_K_BYTES_SETUP;

  PDCI_IODISC_1P_CHECKS("P_io_skip_bytes", skipped_bytes_out);
  if (width == 0) return P_OK;
  PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
  skipped = end - begin;
  PDCI_IO_FORWARD(skipped, goto fatal_forward_err);
  (*skipped_bytes_out) = skipped;
  return (skipped == width) ? P_OK : P_ERR;

 fatal_nb_io_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_IO_ERR, "P_io_skip_bytes", "IO error (nb)");
  return P_ERR;

 fatal_forward_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_FORWARD_ERR, "P_io_skip_bytes", "IO_forward error");
  return P_ERR;
}

int
P_io_at_eor(P_t *pads) {
  PDCI_stkElt_t    *tp;

  PDCI_DISC_0P_CHECKS_RET_0("P_io_at_eor");
  tp        = &(pads->stack[pads->top]);
  return (tp->remain == 0 && tp->elt && tp->elt->eor) ? 1 : 0;
}

int
P_io_at_eof(P_t *pads) {
  PDCI_stkElt_t    *tp;

  PDCI_DISC_0P_CHECKS_RET_0("P_io_at_eof");
  tp        = &(pads->stack[pads->top]);
  return (tp->remain == 0 && tp->elt && tp->elt->eof) ? 1 : 0;
}

int
P_io_at_eor_OR_EOF(P_t *pads) {
  PDCI_stkElt_t    *tp;

  PDCI_DISC_0P_CHECKS_RET_0("P_io_at_eor_or_eof");
  tp        = &(pads->stack[pads->top]);
  return (tp->remain == 0 && tp->elt && (tp->elt->eor || tp->elt->eof)) ? 1 : 0;
}

Perror_t
P_io_getPos(P_t *pads, Ppos_t *pos, int offset)
{
  Perror_t res = P_OK;
  PDCI_DISC_1P_CHECKS("P_io_getPos", pos);
  if (offset == 0) {
    PDCI_ALWAYS_GETPOS_CHECKED(pads, *pos, res);
  } else if (offset > 0) {
    PDCI_ALWAYS_GETPOS_PLUS_CHECKED(pads, *pos, offset, res);
  } else {
    int noffset = -1 * offset;
    PDCI_ALWAYS_GETPOS_MINUS_CHECKED(pads, *pos, noffset, res);
  }
  return res;
}

Perror_t
P_io_getLocB(P_t *pads, Ploc_t *loc, int offset)
{
  Perror_t res = P_OK;
  PDCI_DISC_1P_CHECKS("P_io_getLocB", loc);
  if (offset == 0) {
    PDCI_ALWAYS_GETPOS_CHECKED(pads, loc->b, res);
  } else if (offset > 0) {
    PDCI_ALWAYS_GETPOS_PLUS_CHECKED(pads, loc->b, offset, res);
  } else {
    int noffset = -1 * offset;
    PDCI_ALWAYS_GETPOS_MINUS_CHECKED(pads, loc->b, noffset, res);
  }
  return res;
}

Perror_t
P_io_getLocE(P_t *pads, Ploc_t *loc, int offset)
{
  Perror_t res = P_OK;
  PDCI_DISC_1P_CHECKS("P_io_getLocE", loc);
  if (offset == 0) {
    PDCI_ALWAYS_GETPOS_CHECKED(pads, loc->e, res);
  } else if (offset > 0) {
    PDCI_ALWAYS_GETPOS_PLUS_CHECKED(pads, loc->e, offset, res);
  } else {
    int noffset = -1 * offset;
    PDCI_ALWAYS_GETPOS_MINUS_CHECKED(pads, loc->e, noffset, res);
  }
  return res;
}

Perror_t
P_io_getLoc(P_t *pads, Ploc_t *loc, int offset)
{
  Perror_t res = P_OK;
  PDCI_DISC_1P_CHECKS("P_io_getLoc", loc);
  if (offset == 0) {
    PDCI_ALWAYS_GETPOS_CHECKED(pads, loc->b, res);
  } else if (offset > 0) {
    PDCI_ALWAYS_GETPOS_PLUS_CHECKED(pads, loc->b, offset, res);
  } else {
    int noffset = -1 * offset;
    PDCI_ALWAYS_GETPOS_MINUS_CHECKED(pads, loc->b, noffset, res);
  }
  PDCI_ALWAYS_ENDLOC_SPAN0(pads, *loc);
  return res;
}

#if P_CONFIG_WRITE_FUNCTIONS > 0
Pbyte*
P_io_write_start(P_t *pads, Sfio_t *io, size_t *buf_len, int *set_buf)
{
  PDCI_DISC_3P_CHECKS_RET_0("P_io_write_start", io, buf_len, set_buf);
  return PDCI_io_write_start(pads, io, buf_len, set_buf, "P_io_write_start");
}

ssize_t
P_io_write_commit(P_t *pads, Sfio_t *io, Pbyte *buf, int set_buf, size_t num_bytes)
{
  PDCI_DISC_2P_CHECKS_RET_SSIZE("P_io_write_commit", io, buf);
  return PDCI_io_write_commit(pads, io, buf, set_buf, num_bytes, "P_io_write_commit");
}

void
P_io_write_abort (P_t *pads, Sfio_t *io, Pbyte *buf, int set_buf)
{
  PDCI_DISC_2P_CHECKS_RET_VOID("P_io_write_abort", io, buf);
  PDCI_io_write_abort(pads, io, buf, set_buf, "P_io_write_abort");
}

ssize_t
P_io_rec_write2io(P_t *pads, Sfio_t *io, Pbyte *buf, size_t rec_data_len)
{
  PDCI_IODISC_INIT_CHECKS_RET_SSIZE("P_io_rec_write2io");
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rec_write2io", io);
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rec_write2io", buf);
  return PDCI_io_rec_write2io(pads, io, buf, rec_data_len, "P_io_rec_write2io");
}

ssize_t
P_io_rec_open_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full)
{
  PDCI_IODISC_INIT_CHECKS_RET_SSIZE("P_io_rec_open_write2buf");
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rec_open_write2buf", buf);
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rec_open_write2buf", buf_full);
  return PDCI_io_rec_open_write2buf(pads, buf, buf_len, buf_full, "P_io_rec_open_write2buf");
}

ssize_t
P_io_rec_close_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			 Pbyte *rec_start, size_t num_bytes) 
{
  PDCI_IODISC_INIT_CHECKS_RET_SSIZE("P_io_rec_close_write2buf");
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rec_close_write2buf", buf);
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rec_close_write2buf", buf_full);
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rec_close_write2buf", rec_start);
  return PDCI_io_rec_close_write2buf(pads, buf, buf_len, buf_full, rec_start, num_bytes, "P_io_rec_close_write2buf");
}

ssize_t
P_io_rblk_write2io(P_t *pads, Sfio_t *io, Pbyte *buf, size_t blk_data_len, Puint32 num_recs)
{
  PDCI_IODISC_INIT_CHECKS_RET_SSIZE("P_io_rblk_write2io");
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rblk_write2io", io);
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rblk_write2io", buf);
  return PDCI_io_rblk_write2io(pads, io, buf, blk_data_len, num_recs, "P_io_rblk_write2io");
}

ssize_t
P_io_rblk_open_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full)
{
  PDCI_IODISC_INIT_CHECKS_RET_SSIZE("P_io_rblk_open_write2buf");
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rblk_open_write2buf", buf);
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rblk_open_write2buf", buf_full);
  return PDCI_io_rblk_open_write2buf(pads, buf, buf_len, buf_full, "P_io_rblk_open_write2buf");
}

ssize_t
P_io_rblk_close_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			    Pbyte *blk_start, size_t num_bytes, Puint32 num_recs)
{
  PDCI_IODISC_INIT_CHECKS_RET_SSIZE("P_io_rblk_close_write2buf");
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rblk_close_write2buf", buf);
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rblk_close_write2buf", buf_full);
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rblk_close_write2buf", blk_start);
  return PDCI_io_rblk_close_write2buf(pads, buf, buf_len, buf_full, blk_start, num_bytes, num_recs, "P_io_rblk_close_write2buf");
}

ssize_t
P_io_rec_fmt2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full)
{
  PDCI_IODISC_INIT_CHECKS_RET_SSIZE("P_io_rec_fmt2buf");
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rec_fmt2buf", buf);
  PDCI_NULLPARAM_CHECK_RET_SSIZE("P_io_rec_fmt2buf", buf_full);
  return PDCI_io_rec_fmt2buf(pads, buf, buf_len, buf_full, Pcharset_ASCII, "P_io_rec_fmt2buf");
}

#endif

/* ================================================================================ */
/* EXTERNAL IO CHECKPOINT API */

Perror_t
P_io_checkpoint(P_t *pads, int speculative)
{
  PDCI_DISC_INIT_CHECKS("P_io_checkpoint");
  if (++(pads->top) >= pads->salloc) {
    PDCI_stkElt_t *stack_next;
    size_t salloc_next = 2 * pads->salloc;
    error(0, "XXX_REMOVE Growing from %d to %d checkpoint stack slots", pads->salloc, salloc_next);
    if (!(stack_next = vmnewof(pads->vm, pads->stack, PDCI_stkElt_t, salloc_next, 0))) {
      P_FATAL(pads->disc, "out of space [input cursor stack]");
      return P_ERR;
    }
    pads->stack  = stack_next;
    pads->salloc = salloc_next;
  }
  pads->stack[pads->top].elt     = pads->stack[pads->top - 1].elt;
  pads->stack[pads->top].remain  = pads->stack[pads->top - 1].remain;
#ifdef USE_GALAX
  pads->stack[pads->top].id_gen  = pads->stack[pads->top - 1].id_gen;
#endif
  pads->stack[pads->top].spec    = speculative;
  if (speculative) {
    (pads->speclev)++;
  }
  return P_OK;
}

Perror_t
P_io_restore(P_t *pads)
{
  PDCI_DISC_INIT_CHECKS("P_io_restore");
  if (pads->top <= 0) {
    P_WARN(pads->disc, "Internal error: P_io_restore called when stack top <= 0");
    return P_ERR;
  }
  if (pads->stack[pads->top].spec) {
    (pads->speclev)--;
  }
  /* this discards all changes since the latest checkpoint */ 
  (pads->top)--;
  return P_OK;
}

Perror_t
P_io_commit(P_t *pads)
{
  PDCI_DISC_INIT_CHECKS("P_io_commit");
#ifndef NDEBUG
  if (pads->top <= 0) {
    P_WARN(pads->disc, "Internal error: P_io_commit called when stack top <= 0");
    return P_ERR;
  }
#endif
  if (pads->stack[pads->top].spec) {
    (pads->speclev)--;
  }
  /* propagate changes to elt/remain up to next level */
  pads->stack[pads->top - 1].elt    = pads->stack[pads->top].elt;
  pads->stack[pads->top - 1].remain = pads->stack[pads->top].remain;
#ifdef USE_GALAX
  pads->stack[pads->top - 1].id_gen  = pads->stack[pads->top].id_gen;
#endif
  (pads->top)--;
  return P_OK;
}

Perror_t
P_io_commit_pos(P_t *pads, Ppos_t pos)
{
  Pio_elt_t *elt;
  PDCI_DISC_INIT_CHECKS("P_io_commit_pos");
#ifndef NDEBUG
  if (pads->top <= 0) {
    P_WARN(pads->disc, "Internal error: P_io_commit_pos called when stack top <= 0");
    return P_ERR;
  }
#endif
  if (pads->stack[pads->top].spec) {
    (pads->speclev)--;
  }
  /* see if we can find pos */
#ifdef USE_GALAX
  pads->stack[pads->top - 1].id_gen  = pads->stack[pads->top].id_gen;
#endif
  (pads->top)--;
  if (P_ERR == PDCI_io_getElt(pads, pos.num, &elt)) {
    P_FATAL(pads->disc, "P_io_commit_pos called with invalid pos (elt not found)");
  }
  pads->stack[pads->top].elt    = elt;
  pads->stack[pads->top].remain = elt->len - (pos.offset - elt->offset); /* if pos.offset == elt->offset, all bytes remain */
  return P_OK;
}

unsigned int
P_spec_level(P_t *pads)
{
  PDCI_DISC_INIT_CHECKS("P_spec_level");
  return pads->speclev;
}

/* ================================================================================ */
/* Pstring helper functions */

Perror_t
Pstring_init(P_t *pads, Pstring *s)
{
#ifndef NDEBUG
  if (!s) {
    return P_ERR;
  }
#endif
  memset((void*)s, 0, sizeof(*s));
  return P_OK;
}

Perror_t
Pstring_cleanup(P_t *pads, Pstring *s)
{
  PDCI_DISC_1P_CHECKS("Pstring_cleanup", s);
  /* if (s->sharing) { P_WARN1(pads->disc, "XXX_REMOVE cleanup: string %p is no longer sharing", (void*)s); } */
  if (s->rbuf && (0 != RMM_free_rbuf(s->rbuf))) {
    PDCI_report_err(pads, P_LEV_FATAL, 0, P_ALLOC_ERR, "Pstring_cleanup", "Couldn\'t free growable buffer");
  }
  memset((void*)s, 0, sizeof(*s));
  return P_OK;
}

Perror_t
Pstring_share(P_t *pads, Pstring *targ, const Pstring *src)
{
  PDCI_DISC_2P_CHECKS("Pstring_share", src, targ);
  PDCI_STR_SHARE(targ, src->str, src->len);
  return P_OK;
}

Perror_t
Pstring_cstr_share(P_t *pads, Pstring *targ, const char *src, size_t len)
{
  PDCI_DISC_2P_CHECKS("Pstring_cstr_share", src, targ);
  PDCI_STR_SHARE(targ, src, len);
  return P_OK;
}

Perror_t
Pstring_copy(P_t *pads, Pstring *targ, const Pstring *src)
{
  PDCI_DISC_2P_CHECKS("Pstring_copy", src, targ);
  PDCI_STR_CPY(targ, src->str, src->len);
  return P_OK;

 fatal_alloc_err:
  P_FATAL(pads->disc, "Pstring_copy: out of space");
  return P_ERR;
}

Perror_t
Pstring_cstr_copy(P_t *pads, Pstring *targ, const char *src, size_t len)
{
  PDCI_DISC_2P_CHECKS("Pstring_cstr_copy", src, targ);
  PDCI_STR_CPY(targ, src, len);
  return P_OK;

 fatal_alloc_err:
  P_FATAL(pads->disc, "Pstring_cstr_copy: out of space");
  return P_ERR;
}

Perror_t
Pstring_preserve(P_t *pads, Pstring *s)
{
  PDCI_DISC_1P_CHECKS("Pstring_preserve", s);
  PDCI_STR_PRESERVE(s);
  return P_OK;

 fatal_alloc_err:
  P_FATAL(pads->disc, "Pstring_preserve: out of space");
  return P_ERR;
}

Perror_t
Pstring_pd_init(P_t *pads, Pbase_pd *pd)
{
  PDCI_DISC_1P_CHECKS("Pstring_pd_init", pd);
  memset((void*)pd, 0, sizeof(*pd));
  return P_OK;
}

Perror_t
Pstring_pd_cleanup(P_t *pads, Pbase_pd *pd)
{
  PDCI_DISC_1P_CHECKS("Pstring_pd_cleanup", pd);
  return P_OK;
}

Perror_t
Pstring_pd_copy(P_t *pads, Pbase_pd *targ, const Pbase_pd *src)
{
  PDCI_DISC_2P_CHECKS("Pstring_pd_copy", src, targ);
  (*targ) = (*src);
  return P_OK;
}

/* ================================================================================ */
/* EXTERNAL MISC ROUTINES */

/* helpers for enumeration types */
#define _F1 "|NoSet|NoPrint"
#define _F2 "|NoBaseCheck"
#define _F3 "|NoUserCheck"
#define _F4 "|NoWhereCheck"
#define _F5 "|NoForallCheck"

const char *
Pbase_m2str(P_t *pads, Pbase_m m)
{
  const char *s;
  switch (m) {
  case 0:    s =  "|"                ; break;
  case 1:    s =  _F1                ; break;
  case 2:    s =      _F2            ; break;
  case 3:    s =  _F1 _F2            ; break;
  case 4:    s =          _F3        ; break;
  case 5:    s =  _F1     _F3        ; break;
  case 6:    s =      _F2 _F3        ; break;
  case 7:    s =  _F1 _F2 _F3        ; break;
  case 8:    s =              _F4    ; break;
  case 9:    s =  _F1         _F4    ; break;
  case 10:   s =      _F2     _F4    ; break;
  case 11:   s =  _F1 _F2     _F4    ; break;
  case 12:   s =          _F3 _F4    ; break;
  case 13:   s =  _F1     _F3 _F4    ; break;
  case 14:   s =      _F2 _F3 _F4    ; break;
  case 15:   s =  _F1 _F2 _F3 _F4    ; break;
  case 16:   s =                  _F5; break;
  case 17:   s =  _F1             _F5; break;
  case 18:   s =      _F2         _F5; break;
  case 19:   s =  _F1 _F2         _F5; break;
  case 20:   s =          _F3     _F5; break;
  case 21:   s =  _F1     _F3     _F5; break;
  case 22:   s =      _F2 _F3     _F5; break;
  case 23:   s =  _F1 _F2 _F3     _F5; break;
  case 24:   s =              _F4 _F5; break;
  case 25:   s =  _F1         _F4 _F5; break;
  case 26:   s =      _F2     _F4 _F5; break;
  case 27:   s =  _F1 _F2     _F4 _F5; break;
  case 28:   s =          _F3 _F4 _F5; break;
  case 29:   s =  _F1     _F3 _F4 _F5; break;
  case 30:   s =      _F2 _F3 _F4 _F5; break;
  case 31:   s =  _F1 _F2 _F3 _F4 _F5; break;
  default:   s = "|*Invalid Pbase_m value*"; break;
  }
  return s+1;
}

const char *
PerrorRep2str(PerrorRep e)
{
  switch (e)
    {
    case PerrorRep_Max:
      return "PerrorRep_Max";
    case PerrorRep_Med:
      return "PerrorRep_Med";
    case PerrorRep_Min:
      return "PerrorRep_Min";
    case PerrorRep_None:
      return "PerrorRep_None";
    default:
      break;
    }
  return "*Invalid PerrorRep value*";
}

const char *
Pendian2str(Pendian_t e)
{
  switch (e)
    {
    case PbigEndian:
      return "PbigEndian";
    case PlittleEndian:
      return "PlittleEndian";
    default:
      break;
    }
  return "*Invalid Pendian value*";
}

const char *
Pcharset2str(Pcharset e)
{
  switch (e)
    {
    case Pcharset_ASCII:
      return "Pcharset_ASCII";
    case Pcharset_EBCDIC:
      return "Pcharset_EBCDIC";
    default:
      break;
    }
  return "*Invalid Pcharset value*";
}

char*
P_fmt_char(char c) {
  return fmtquote(&c, NiL, NiL, 1, 0);
}

char*
P_qfmt_char(char c) {
  return fmtquote(&c, "\'", "\'", 1, 1);
}

char*
P_fmt_str(const Pstring *s) {
  return fmtquote(s->str, NiL, NiL, s->len, 0);
}

char*
P_qfmt_str(const Pstring *s) {
  return fmtquote(s->str, "\"", "\"", s->len, 1);
}

char*
P_fmt_cstr_n(const char *s, size_t len) {
  return fmtquote(s, NiL, NiL, len, 0);
}

char*
P_fmt_cstr(const char *s) {
  return fmtquote(s, NiL, NiL, strlen(s), 0);
}

char*
P_qfmt_cstr_n(const char *s, size_t len) {
  return fmtquote(s, "\"", "\"", len, 1);
}

char*
P_qfmt_cstr(const char *s) {
  return fmtquote(s, "\"", "\"", strlen(s), 1);
}

/*
 * Note: swapmem ops documented with binary read functions
 * Here we use in-place swap, which is safe with gsf's swapmem
 */

Perror_t
P_swap_bytes(Pbyte *bytes, size_t num_bytes)
{
#ifndef NDEBUG
  if (!bytes) {
    P_WARN(&Pdefault_disc, "P_swap_bytes: param bytes must not be NULL");
    return P_ERR;
  }
#endif

  switch (num_bytes) {
  case 2:
    swapmem(1, bytes, bytes, num_bytes);
    return P_OK;
  case 4:
    swapmem(3, bytes, bytes, num_bytes);
    return P_OK;
  case 8:
    swapmem(7, bytes, bytes, num_bytes);
    return P_OK;
  }
  P_WARN1(&Pdefault_disc, "P_swap_bytes: invalid num_bytes (%d), use 2, 4, or 8", num_bytes);
  return P_ERR;
}

Sfio_t*
P_fopen(const char *string, const char *mode)
{
  Sfio_t* io;
  if (strcmp(string, "/dev/stdin")  == 0) {
    if (strcmp(mode, "r")) {
      /* not simple read mode, let sfopen decide if mode can be applied to sfstdin */
      io = sfopen(sfstdin,  NiL, mode);
      goto install_pzip;
    }
    io = sfstdin;
    goto install_pzip;
  }
  if (strcmp(string, "/dev/stdout") == 0) {
    if (strcmp(mode, "a")) {
      /* not simple append mode, let sfopen decide if mode can be applied to sfstdout */
      return sfopen(sfstdout,  NiL, mode);
    }
    return sfstdout;
  }
  if (strcmp(string, "/dev/stderr") == 0) {
    if (strcmp(mode, "a")) {
      /* not simple append mode, let sfopen decide if mode can be applied to sfstderr */
      return sfopen(sfstderr,  NiL, mode);
    }
    return sfstderr;
  }
  if (strchr(mode, 'r')) {
    io = sfopen(NiL, string, mode);
    goto install_pzip;
  }
  /* not a read mode */
  return sfopen(NiL, string, mode);

 install_pzip:
#ifdef USE_PZIP
  {
    struct stat	st;
    static Pzdisc_t pzdisc;
    if (!io) return 0;
    if (sfsize(io) || (!fstat(sffileno(io), &st) && S_ISFIFO(st.st_mode))) {
      pzdisc.errorf = errorf; /* from <error.h> */
      if (sfdcpzip(io, string, 0, &pzdisc) < 0) {
	P_SYSERR1(&Pdefault_disc, "P_fopen for file \"%s\": decompression error", string);
	sfclose(io);
	errno = 0; /* already reported system error */
	return 0;
      }
    }
  }
  return io;
#else /* decompression libraries not included, do not attempt to inflate */
  return io;
#endif
}

/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * INTERNAL FUNCTIONS (see pads-internal.h)
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

/* ================================================================================ */ 
/* INTERNAL ERROR REPORTING FUNCTIONS */

const char *P_pstate2str(Pflags_t pstate)
{
  if (pstate & P_Panic) return "Panic";
  if (pstate) return "*UnknownPStateFlags*";
  return "Normal";
}

const char *P_errCode2str(PerrCode_t code)
{
  switch (code) {
  case P_NOT_PARSED: return "P_NOT_PARSED";
  case P_NO_ERR: return "P_NO_ERR";
  case P_SKIPPED: return "P_SKIPPED";
  case P_UNEXPECTED_ERR: return "P_UNEXPECTED_ERR";
  case P_BAD_PARAM: return "P_BAD_PARAM";
  case P_SYS_ERR: return "P_SYS_ERR";
  case P_IO_ERR: return "P_IO_ERR";
  case P_CHKPOINT_ERR: return "P_CHKPOINT_ERR";
  case P_COMMIT_ERR: return "P_COMMIT_ERR";
  case P_RESTORE_ERR: return "P_RESTORE_ERR";
  case P_ALLOC_ERR: return "P_ALLOC_ERR";
  case P_FORWARD_ERR: return "P_FORWARD_ERR";
  case P_PANIC_SKIPPED: return "P_PANIC_SKIPPED";
  case P_USER_CONSTRAINT_VIOLATION: return "P_USER_CONSTRAINT_VIOLATION";
  case P_MISSING_LITERAL: return "P_MISSING_LITERAL";
  case P_ARRAY_ELEM_ERR: return "P_ARRAY_ELEM_ERR";
  case P_ARRAY_SEP_ERR: return "P_ARRAY_SEP_ERR";
  case P_ARRAY_TERM_ERR: return "P_ARRAY_TERM_ERR";
  case P_ARRAY_SIZE_ERR: return "P_ARRAY_SIZE_ERR";
  case P_ARRAY_SEP_TERM_SAME_ERR: return "P_ARRAY_SEP_TERM_SAME_ERR";
  case P_ARRAY_USER_CONSTRAINT_ERR: return "P_ARRAY_USER_CONSTRAINT_ERR";
  case P_ARRAY_MIN_BIGGER_THAN_MAX_ERR: return "P_ARRAY_MIN_BIGGER_THAN_MAX_ERR";
  case P_ARRAY_MIN_NEGATIVE: return "P_ARRAY_MIN_NEGATIVE";
  case P_ARRAY_MAX_NEGATIVE: return "P_ARRAY_MAX_NEGATIVE";
  case P_ARRAY_EXTRA_BEFORE_SEP: return "P_ARRAY_EXTRA_BEFORE_SEP";
  case P_ARRAY_EXTRA_BEFORE_TERM: return "P_ARRAY_EXTRA_BEFORE_TERM";
  case P_STRUCT_FIELD_ERR: return "P_STRUCT_FIELD_ERR";
  case P_STRUCT_EXTRA_BEFORE_SEP: return "P_STRUCT_EXTRA_BEFORE_SEP";
  case P_UNION_MATCH_ERR: return "P_UNION_MATCH_ERR";
  case P_ENUM_MATCH_ERR: return "P_ENUM_MATCH_ERR";
  case P_TYPEDEF_CONSTRAINT_ERR: return "P_TYPEDEF_CONSTRAINT_ERR";
  case P_AT_EOF: return "P_AT_EOF";
  case P_AT_EOR: return "P_AT_EOR";
  case P_EXTRA_BEFORE_EOR: return "P_EXTRA_BEFORE_EOR";
  case P_EOF_BEFORE_EOR: return "P_EOF_BEFORE_EOR";
  case P_COUNT_MAX_LIMIT: return "P_COUNT_MAX_LIMIT";
  case P_RANGE: return "P_RANGE";
  case P_INVALID_A_NUM: return "P_INVALID_A_NUM";
  case P_INVALID_E_NUM: return "P_INVALID_E_NUM";
  case P_INVALID_EBC_NUM: return "P_INVALID_EBC_NUM";
  case P_INVALID_BCD_NUM: return "P_INVALID_BCD_NUM";
  case P_INVALID_CHARSET: return "P_INVALID_CHARSET";
  case P_INVALID_WIDTH: return "P_INVALID_WIDTH";
  case P_CHAR_LIT_NOT_FOUND: return "P_CHAR_LIT_NOT_FOUND";
  case P_STR_LIT_NOT_FOUND: return "P_STR_LIT_NOT_FOUND";
  case P_REGEXP_NOT_FOUND: return "P_REGEXP_NOT_FOUND";
  case P_INVALID_REGEXP: return "P_INVALID_REGEXP";
  case P_WIDTH_NOT_AVAILABLE: return "P_WIDTH_NOT_AVAILABLE";
  case P_INVALID_TIMESTAMP: return "P_INVALID_TIMESTAMP";
  case P_INVALID_DATE: return "P_INVALID_DATE";
  case P_INVALID_TIME: return "P_INVALID_TIME";
  case P_INVALID_IP: return "P_INVALID_IP";
  case P_INVALID_IP_RANGE: return "P_INVALID_IP_RANGE";
  default: break;
  }
  return "*UNKNOWN_ERRCODE*";
}

Perror_t
PDCI_report_err(P_t *pads, int level, Ploc_t *loc,
		PerrCode_t errCode, const char *whatfn, const char *format, ...)
{
  Perror_fn   pdc_errorf;
  char       *severity = "Error";
  char       *msg      = "** unknown error code **";
  char       *infn, *tmpstr1, *tmpstr2, *tmpstr3;
  const char *unit;
  size_t      tmplen1, tmplen2, tmplen3;
  int         nullspan = 0;

  P_TRACE(pads->disc, "PDCI_report_err called");
#ifndef TRACE
  if ((pads->speclev || pads->disc->e_rep == PerrorRep_None) && P_GET_LEV(level) != P_LEV_FATAL) return P_OK;
#else
  if ((pads->disc->e_rep == PerrorRep_None) && P_GET_LEV(level) != P_LEV_FATAL) return P_OK;
  if (pads->speclev) {
    error(0, "*** SPECULATIVE MSG, NORMALLY IGNORED:");
  }
#endif
  if (!whatfn) {
    infn = "";
  } else {
    PDCI_sfstr_seek2zero(pads->tmp2);
    sfprintf(pads->tmp2, "[in %s]", whatfn);
    infn = PDCI_sfstr_use(pads->tmp2);
  }
  pdc_errorf = pads->disc->error_fn;
  if (P_GET_LEV(level) == P_LEV_FATAL) {
    severity = "FATAL error";
    if (!pdc_errorf) { /* need an error function anyway for fatal case */
      pdc_errorf = P_error;
    }
  } else if (!pdc_errorf) {
    return P_OK;
  }
  if (errCode == P_NO_ERR) {
    severity = "Note";
  }
  /* Any backwards span is treated as a null span */
  if (loc && ((loc->e.num < loc->b.num) || (loc->b.num == loc->e.num && loc->e.byte < loc->b.byte))) {
    nullspan = 1;
  }
  if (!(unit = P_io_read_unit(pads))) {
    unit = "";
  }
  PDCI_sfstr_seek2zero(pads->tmp1);
  if (pads->disc->e_rep == PerrorRep_Min) {
    if (loc) {
      pdc_errorf(NiL, level, "%s %s: %s %d byte %d: errCode %d",
		 severity, infn, unit, loc->b.num, loc->b.byte, errCode);
    } else {
      pdc_errorf(NiL, level, "%s %s: errCode %d", severity, infn, errCode);
    }
    return P_OK;
  }
  if (format && strlen(format)) {
    va_list ap;
    if (loc) {
      sfprintf(pads->tmp1, "%s %s: %s %d byte %d : ", severity, infn, unit, loc->b.num, loc->b.byte);
    } else {
      sfprintf(pads->tmp1, "%s %s: ", severity, infn);
    }
    va_start(ap, format);
    sfvprintf(pads->tmp1, format, ap);
    va_end(ap);
  } else {
    switch (errCode) {
    case P_NO_ERR:
      msg = "";
      break;
    case P_UNEXPECTED_ERR:
      msg = "XXX Unexpected error (should not happen)";
      break;
    case P_BAD_PARAM:
      msg = "Invalid argument value used in padsc library call";
      break;
    case P_SYS_ERR:
      msg = "System error";
      break;
    case P_CHKPOINT_ERR:
      msg = "Checkpoint error (misuse of padsc IO checkpoint facility)";
      break;
    case P_COMMIT_ERR:
      msg = "Commit error (misuse of padsc IO checkpoint facility)";
      break;
    case P_RESTORE_ERR:
      msg = "Restore error (misuse of padsc IO checkpoint facility)";
      break;
    case P_ALLOC_ERR:
      msg = "Memory alloc failure (out of space)";
      break;
    case P_PANIC_SKIPPED:
      msg = "Data element parsing skipped: in panic mode due to earlier error(s)";
      break;
    case P_USER_CONSTRAINT_VIOLATION:
      msg = "User constraint violation";
      break;
    case P_MISSING_LITERAL:
      msg = "Missing literal";
      break;
    case P_ARRAY_ELEM_ERR:
      msg = "Array element error";
      break;
    case P_ARRAY_SEP_ERR:
      msg = "Arrey seperator error";
      break;
    case P_ARRAY_TERM_ERR:
      msg = "Arrey terminator error";
      break;
    case P_ARRAY_SIZE_ERR:
      msg = "Array size error";
      break;
    case P_ARRAY_SEP_TERM_SAME_ERR:
      msg = "Array terminator/separator value error";
      break;
    case P_ARRAY_USER_CONSTRAINT_ERR:
      msg = "Array user constraint violation";
      break;
    case P_ARRAY_MIN_BIGGER_THAN_MAX_ERR:
      msg = "Array min bigger than array max";
      break;
    case P_ARRAY_MIN_NEGATIVE:
      msg = "Negative number used for array min";
      break;
    case P_ARRAY_MAX_NEGATIVE:
      msg = "Negative number used for array max";
      break;
    case P_ARRAY_EXTRA_BEFORE_SEP:
      msg = "Unexpected extra data before array element separator";
      break;
    case P_ARRAY_EXTRA_BEFORE_TERM:
      msg = "Unexpected extra data before array element terminator";
      break;
    case P_STRUCT_EXTRA_BEFORE_SEP:
      msg = "Unexpected extra data before field separator in struct";
      break;
    case P_STRUCT_FIELD_ERR:
      msg = "Structure field error";
      break;
    case P_UNION_MATCH_ERR:
      msg = "Union match failure";
      break;
    case P_ENUM_MATCH_ERR:
      msg = "Enum match failure";
      break;
    case P_TYPEDEF_CONSTRAINT_ERR:
      msg = "Typedef constraint error";
      break;
    case P_AT_EOF:
      msg = "Unexpected end of file (field too short?)";
      break;
    case P_AT_EOR:
      msg = "Unexpected end of record (field too short?)";
      break;
    case P_EXTRA_BEFORE_EOR:
      msg = "Unexpected extra data before EOR";
      break;
    case P_EOF_BEFORE_EOR:
      msg = "EOF encountered prior to expected EOR";
      break;
    case P_COUNT_MAX_LIMIT:
      msg = "cont_max limit hit before count routine found other terminating condition";
      break;
    case P_RANGE:
      msg = "Number out of range error";
      break;
    case P_INVALID_A_NUM:
      msg = "Invalid ASCII character encoding of a number";
      break;
    case P_INVALID_E_NUM:
      msg = "Invalid EBCDIC character encoding of a number";
      break;
    case P_INVALID_EBC_NUM:
      msg = "Invalid EBCDIC numeric encoding";
      break;
    case P_INVALID_BCD_NUM:
      msg = "Invalid BCD numeric encoding";
      break;
    case P_INVALID_CHARSET:
      msg = "Invalid Pcharset value";
      break;
    case P_INVALID_WIDTH:
      msg = "Invalid fixed width arg: does not match width of Pstring arg";
      break;
    case P_CHAR_LIT_NOT_FOUND:
      msg = "Expected character literal not found";
      break;
    case P_STR_LIT_NOT_FOUND:
      msg = "Expected string literal not found";
      break;
    case P_REGEXP_NOT_FOUND:
      msg = "Match for regular expression not found";
      break;
    case P_INVALID_REGEXP:
      msg = "Invalid regular expression";
      break;
    case P_WIDTH_NOT_AVAILABLE:
      msg = "Specified width not available (EOR/EOF encountered)";
      break;
    case P_INVALID_TIMESTAMP:
      msg = "Invalid timestamp";
      break;
    case P_INVALID_DATE:
      msg = "Invalid date";
      break;
    case P_INVALID_TIME:
      msg = "Invalid time";
      break;
    case P_INVALID_IP:
      msg = "Invalid IP address";
      break;
    case P_INVALID_IP_RANGE:
      msg = "Invalid IP address, numbers must be between 0 and 255";
      break;
    default:
      sfprintf(pads->tmp1, "** unknown error code: %d **", errCode);
      msg = "";
      break;
    }
    if (loc) {
      if (loc->b.num < loc->e.num) {
	sfprintf(pads->tmp1, "%s %s: from %s %d byte %d to %s %d byte %d: %s ",
		 severity, infn,
		 unit, loc->b.num, loc->b.byte, 
		 unit, loc->e.num, loc->e.byte,
		 msg);
      } else if (nullspan) {
	sfprintf(pads->tmp1, "%s %s: at %s %d just before byte %d: %s",
		 severity, infn,
		 unit, loc->b.num, loc->b.byte,
		 msg);
      } else if (loc->b.byte == loc->e.byte) {
	sfprintf(pads->tmp1, "%s %s: at %s %d at byte %d : %s ",
		 severity, infn,
		 unit, loc->b.num, loc->b.byte,
		 msg);
      } else {
	sfprintf(pads->tmp1, "%s %s: at %s %d from byte %d to byte %d: %s ",
		 severity, infn,
		 unit, loc->b.num, loc->b.byte, loc->e.byte,
		 msg);
      }
    } else {
      sfprintf(pads->tmp1, "%s %s: %s ", severity, infn, msg);
    }
  }
  if (loc && (pads->disc->e_rep == PerrorRep_Max)) {
    Pio_elt_t *elt1, *elt2;
    if (loc->b.num < loc->e.num) {
      if (P_OK == PDCI_io_getElt(pads, loc->b.num, &elt1)) {
	sfprintf(pads->tmp1, "\n[%s %d]", unit, loc->b.num);
	if (elt1->len == 0) {
	  sfprintf(pads->tmp1, "(**EMPTY**)>>>");
	} else {
	  tmplen1 = loc->b.byte - 1;
	  tmplen2 = elt1->len - tmplen1;
	  tmpstr1 = P_fmt_cstr_n((char*)elt1->begin,           tmplen1);
	  tmpstr2 = P_fmt_cstr_n((char*)elt1->begin + tmplen1, tmplen2);
	  sfprintf(pads->tmp1, "%s>>>%s", tmpstr1, tmpstr2);
	}
      }
      if (P_OK == PDCI_io_getElt(pads, loc->e.num, &elt2)) {
	if (!elt1) {
	  sfprintf(pads->tmp1, "\n[%s %d]: ... >>>(char pos %d) ...",
		   unit, loc->b.num, loc->b.byte);
	}
	sfprintf(pads->tmp1, "\n[%s %d]", unit, loc->e.num);
	if (elt2->len == 0) {
	  sfprintf(pads->tmp1, "(**EMPTY**)<<<");
	} else {
	  tmplen1 = loc->e.byte;
	  tmplen2 = elt2->len - tmplen1;
	  tmpstr1 = P_fmt_cstr_n((char*)elt2->begin,           tmplen1);
	  tmpstr2 = P_fmt_cstr_n((char*)elt2->begin + tmplen1, tmplen2);
	  sfprintf(pads->tmp1, "%s<<<%s", tmpstr1, tmpstr2);
	}
      }
    } else { /* same elt */
      if (P_OK == PDCI_io_getElt(pads, loc->b.num, &elt1)) {
	sfprintf(pads->tmp1, "\n[%s %d]", unit, loc->b.num);
	if (elt1->len == 0) {
	  sfprintf(pads->tmp1, ">>>(**EMPTY**)<<<");
	} else if (nullspan) {
	  tmplen1 = loc->b.byte - 1;
	  tmplen2 = elt1->len - tmplen1;
	  tmpstr1 = P_fmt_cstr_n((char*)elt1->begin,           tmplen1);
	  tmpstr2 = P_fmt_cstr_n((char*)elt1->begin + tmplen1, tmplen2);
	  sfprintf(pads->tmp1, "%s>>><<<%s", tmpstr1, tmpstr2);
	} else {
	  tmplen1 = loc->b.byte - 1;
	  tmplen3 = elt1->len - loc->e.byte;
	  tmplen2 = elt1->len - tmplen1 - tmplen3;
	  tmpstr1 = P_fmt_cstr_n((char*)elt1->begin,                     tmplen1);
	  tmpstr2 = P_fmt_cstr_n((char*)elt1->begin + tmplen1,           tmplen2);
	  tmpstr3 = P_fmt_cstr_n((char*)elt1->begin + tmplen1 + tmplen2, tmplen3);
	  sfprintf(pads->tmp1, "%s>>>%s<<<%s", tmpstr1, tmpstr2, tmpstr3);
	}
      }
    }
  }
  pdc_errorf(NiL, level, "%s", PDCI_sfstr_use(pads->tmp1));
  return P_OK;
}

/* ================================================================================ */
/* INTERNAL IO FUNCTIONS */

Perror_t
PDCI_io_install_io(P_t *pads, Sfio_t *io)
{
  PDCI_stkElt_t    *tp        = &(pads->stack[0]);
  Pio_elt_t     *next_elt;
  Void_t           *buf;

  /* XXX_TODO handle case where pads->io is already set, io_discipline already open, etc */
  pads->io = io;
  /* tell sfio to use pads->sfbuf but only let it know about sizeof(sfbuf)-1 space */
  buf = sfsetbuf(pads->io, (Void_t*)1, 0);
  if (!buf) {
    sfsetbuf(pads->io, pads->sfbuf, 1024 * 1024);
  } else if (buf == (Void_t*)pads->sfbuf) {
    /* P_WARN(pads->disc, "XXX_REMOVE pads->sfbuf has already been installed so not installing it again"); */
  } else {
    /* P_WARN(pads->disc, "XXX_REMOVE An unknown buffer has already been installed so not installing pads->sfbuf\n"
                 "  (could be due to use of sfungetc)"); */
  }
  /* AT PRESENT we only support switching io at a very simply boundary:
   *    1. no checkpoint established
   *    2. not performing a speculative read (redundant based on 1)
   *    3. no nested internal calls in progress
   *    ...
   */
  if (P_SOME_ELTS(pads->head)) {
    P_FATAL(pads->disc, "Internal error: new io is being installed when pads->head list is non-empty\n"
	      "Should not happen if IO discipline close is working properly");
  }
  if (pads->top != 0) {
    P_FATAL(pads->disc, "Switching io during IO checkpoint not supported yet");
  }
  if (pads->speclev != 0) {
    P_FATAL(pads->disc, "Switching io during speculative read not supported yet");
  }
  if (pads->inestlev != 0) {
    P_FATAL(pads->disc, "Switching io during internal call nesting not supported yet");
  }

  /* open IO discipline */
  if (P_ERR == pads->disc->io_disc->sfopen_fn(pads, pads->disc->io_disc, pads->io, pads->head)) {
    return P_ERR;
  }
  /* perform first read */
  if (P_ERR == pads->disc->io_disc->read_fn(pads, pads->disc->io_disc, 0, &next_elt)) {
    tp->elt = P_LAST_ELT(pads->head); /* IO disc may have added eof elt */
    tp->remain = 0;
    return P_ERR;
  }
  tp->elt = P_FIRST_ELT(pads->head);
  if (tp->elt == pads->head || tp->elt != next_elt) {
    P_FATAL(pads->disc, "Internal error : IO read function failure in PDCI_io_install_io");
  }
  tp->remain = tp->elt->len;
  return P_OK;
}

/* ================================================================================ */
/* PURELY INTERNAL IO FUNCTIONS */

#if 0
XXX_REMOVE
Perror_t
PDCI_io_need_K_bytes(P_t *pads, size_t K,
		     Pbyte **b_out, Pbyte **e_out,
		     int *bor_out, int *eor_out, int *eof_out)
{
  PDCI_stkElt_t    *tp       = &(pads->stack[pads->top]);
  Pio_elt_t     *elt      = tp->elt;
  Pio_elt_t     *keep_elt;
  Pio_elt_t     *next_elt;
  size_t            bytes;

  P_TRACE(pads->disc, "PDCI_io_need_K_bytes called");

  bytes      = tp->remain;
  (*bor_out) = (elt->bor && (bytes == elt->len));

  while (!(elt->eor|elt->eof) && (bytes < K)) {
    /* try for more bytes */
    if (elt->next != pads->head) { /* the easy case */
      elt = elt->next;
      bytes += elt->len;
      continue;
    }
    /* elt->next is pads->head, getting more bytes requires use of read_fn */
    keep_elt = pads->stack[0].elt;
    if (P_ERR == pads->disc->io_disc->read_fn(pads, pads->disc->io_disc, keep_elt, &next_elt)) {
      goto any_err;
    }
#ifndef NDEBUG
    if (elt->next != next_elt || next_elt == pads->head) { /* should not happen */
      P_FATAL(pads->disc, "Internal error, PDCI_io_need_K_bytes observed incorrect read_fn behavior");
      goto any_err;
    }
#endif
    elt = elt->next;
    bytes += elt->len;
  }
  /* either we hit eor or eof, or we found >= K bytes */
  (*b_out) = (tp->elt->end - tp->remain);
  if (bytes > K) {
    (*e_out)       = (*b_out) + K;
    (*eor_out)     = 0;
    (*eof_out)     = 0;
  } else {
    (*e_out)       = elt->end;
    (*eor_out)     = elt->eor;
    (*eof_out)     = elt->eof;
  }
  return P_OK;

 any_err:
   /* Error eof case.  Since K bytes not found, may as well always return P_ERR even if bytes > 0 */
  (*b_out)     = (tp->elt->end - tp->remain);
  (*e_out)     = elt->end;
  (*eof_out)   = 1;
  (*eor_out)   = 0;
  return P_ERR;
}
#endif

#if 0
Perror_t
PDCI_io_need_some_bytes(P_t *pads, PDCI_goal_t goal, size_t specific,
			Pbyte **b_out, Pbyte **e_out, Pbyte **g_out,
			int *bor_out, int *eor_out, int *eof_out)
{
  PDCI_stkElt_t    *tp       = &(pads->stack[pads->top]);
  Pio_elt_t     *elt      = tp->elt;
  Pio_elt_t     *keep_elt;
  Pio_elt_t     *next_elt;
  size_t            bytes, goal_bytes;
  int               soft_goal;

  P_TRACE(pads->disc, "PDCI_io_need_some_bytes called");

  goal_bytes = 0; /* goal is end-of-record */
  soft_goal  = 0; /* set to 1 only if we are forced to use a BUILTIN goal */
  switch (goal)
    {
    case PDCI_goal_match:
      goal_bytes = pads->disc->match_max;
      if (!goal_bytes && !pads->disc->io_disc->rec_based) {
	goal_bytes = P_BUILTIN_MATCH_MAX;
	soft_goal  = 1;
      }
      break;
    case PDCI_goal_scan:
      goal_bytes = pads->disc->scan_max;
      if (!goal_bytes && !pads->disc->io_disc->rec_based) {
	goal_bytes = P_BUILTIN_SCAN_MAX;
	soft_goal  = 1;
      }
      break;
    case PDCI_goal_panic:
      goal_bytes = pads->disc->panic_max;
      if (!goal_bytes && !pads->disc->io_disc->rec_based) {
	goal_bytes = P_BUILTIN_PANIC_MAX;
	soft_goal  = 1;
      }
      break;
    case PDCI_goal_numeric:
      goal_bytes = pads->disc->numeric_max;
      if (!goal_bytes && !pads->disc->io_disc->rec_based) {
	goal_bytes = P_BUILTIN_NUMERIC_MAX;
	soft_goal  = 1;
      }
      break;
    case PDCI_goal_specific:
      if (specific <= 0) return P_ERR;
      goal_bytes = specific;
      break;
    }

  bytes      = tp->remain;
  (*bor_out) = (elt->bor && (bytes == elt->len));

  while (!(elt->eor|elt->eof) && (soft_goal || !goal_bytes || bytes < goal_bytes)) {
    /* try for more bytes */
    if (elt->next != pads->head) { /* the easy case */
      elt = elt->next;
      bytes += elt->len;
      continue;
    }
    /* elt->next is pads->head, getting more bytes requires use of read_fn */
    /* if soft goal and it has been hit, stop now */
    if (soft_goal && (bytes >= goal_bytes)) break;
    keep_elt = pads->stack[0].elt;
    if (P_ERR == pads->disc->io_disc->read_fn(pads, pads->disc->io_disc, keep_elt, &next_elt)) {
      goto any_err;
    }
#ifndef NDEBUG
    if (elt->next != next_elt || next_elt == pads->head) { /* should not happen */
      P_FATAL(pads->disc, "Internal error, PDCI_io_need_some_bytes observed incorrect read_fn behavior");
      goto any_err;
    }
#endif
    elt = elt->next;
    bytes += elt->len;
  }
  /* either we hit eor or eof, or we found >= goal_bytes bytes */
  if (soft_goal && (bytes > goal_bytes)) {
    /* adjust goal upwards rather than not returning all the bytes we found */
    goal_bytes = bytes;
  }
  (*b_out) = (tp->elt->end - tp->remain);
  if (!goal_bytes || elt->eor) {
    /* Goal was eor and we got eor|eof, OR goal was set but we found eor first,
     * which is also acceptable as a goal. Either way, include all bytes found.
     * Since this is record-based case, set (*g_out) > (*e_out) if !eor
     */
    (*e_out)       = elt->end;
    if (elt->eor) {
      (*g_out)     = elt->end;
    } else if (goal_bytes) {
      (*g_out)     = (*b_out) + goal_bytes; /* Note (*g_out) > (*e_out) */
    } else {
      (*g_out)     = elt->end + PDCI_GOAL_HUGE; /* Note that (*g_out) > (*e_out) */
    }
    (*eor_out)     = elt->eor;
    (*eof_out)     = elt->eof;
  } else {
    /* had hard or soft goal_bytes (> 0) and eor not found.  eof may have been found */
    (*eor_out)     = 0;
    if (bytes > goal_bytes) {
      /* found more than enough (end will be prior to any eof byte) */
      (*e_out)     = (*b_out) + goal_bytes;
      (*g_out)     = (*e_out);
      (*eof_out)   = 0;
    } else if (bytes == goal_bytes) {
      /* found exactly enough (not sure if end is at eof) */
      (*e_out)     = (*b_out) + goal_bytes;
      (*g_out)     = (*e_out);
      (*eof_out)   = ((*e_out) == elt->end) ? elt->eof : 0;
    } else {
      /* did not find enough (must have hit eof) */
      (*e_out)     = elt->end;
      (*g_out)     = (*b_out) + goal_bytes; /* Note (*g_out) > (*e_out) */
      (*eof_out)   = 1;
    }
  }
  return P_OK;

 any_err:
   /* Error eof case.  Since goal not found, may as well return P_ERR even if bytes > 0 */
  (*b_out)         = (tp->elt->end - tp->remain);
  (*e_out)         = elt->end;
  if (goal_bytes) {
    (*g_out)       = (*b_out) + goal_bytes; /* Note (*g_out) > (*e_out) */
  } else {
    (*g_out)       = elt->end + PDCI_GOAL_HUGE; /* Note (*g_out) > (*e_out) */
  }
  (*eof_out)       = 1;
  (*eor_out)       = 0;
  return P_ERR;
}
#endif

Perror_t
PDCI_io_need_rec_bytes(P_t *pads, int skip_rec,
		       Pbyte **b_out, Pbyte **e_out,
		       int *eor_out, int *eof_out, size_t *skipped_bytes_out)
{
  PDCI_stkElt_t    *tp          = &(pads->stack[pads->top]);
  Pio_elt_t     *elt;
  Pio_elt_t     *next_elt;
  Pio_elt_t     *keep_elt;

#ifndef NDEBUG
  if (!pads->disc->io_disc->rec_based) {
    P_FATAL(pads->disc, "Internal error, PDCI_io_need_rec_bytes called on non-rec-based IO discipline");
  }
#endif
  (*skipped_bytes_out) = 0;
  if (skip_rec) {
    /* assumes PDCI_io_need_rec_bytes already called once and there is an elt with eor == 1 and eof == 0*/
    while (!tp->elt->eor) {
#ifndef NDEBUG
      if (tp->elt->eof || tp->elt->next == pads->head) {
	P_FATAL(pads->disc, "Internal error, PDCI_io_need_rec_bytes called in bad start state");
      }
#endif
      (*skipped_bytes_out) += tp->remain;
      tp->elt = tp->elt->next;
      tp->remain = tp->elt->len;
    }
    /* found eor elt */
#ifndef NDEBUG
    if (tp->elt->eof) {
      P_FATAL(pads->disc, "Internal error, PDCI_io_need_rec_bytes called in bad start state");
    }
#endif
    (*skipped_bytes_out) += tp->remain;
    tp->remain = 0; /* advance past rec */
    /* move top to following elt */
    /* (also moves bot when top==bot [pads->top == 0]) */
    if (tp->elt->next != pads->head) {
      tp->elt = tp->elt->next;
    } else {
      /* need to read another elt using IO discipline */
      keep_elt = pads->stack[0].elt;
      if (P_ERR == pads->disc->io_disc->read_fn(pads, pads->disc->io_disc, keep_elt, &next_elt)) {
	/* read problem, return zero length, !eor, eof */
	tp->elt      = P_LAST_ELT(pads->head); /* IO disc may have added eof elt */
	tp->remain   = 0;
	(*b_out)     = tp->elt->end;
	(*e_out)     = (*b_out);
	(*eor_out)   = 0;
	(*eof_out)   = 1;
	return P_ERR;
      }
#ifndef NDEBUG
      if (next_elt == pads->head) { /* should not happen */
	P_FATAL(pads->disc, "Internal error, P_io_need_rec_bytes observed incorrect read_fn behavior");
      }
#endif
      tp->elt = next_elt;
    }
    tp->remain = tp->elt->len;
    /* record has been skipped, tp->elt is start loc for requested bytes */
  } /* else do not skip record, tp->elt is still start lock for requested bytes */

  /* find elt with eor or eof marker, starting with tp->elt */
  elt = tp->elt;
  while (!(elt->eor|elt->eof)) {
    if (elt->next == pads->head) {
      /* need to read another elt using IO discipline */
      keep_elt = pads->stack[0].elt;
      if (P_ERR == pads->disc->io_disc->read_fn(pads, pads->disc->io_disc, keep_elt, &next_elt)) {
	/* read problem, return zero length, !eor, eof */
	(*b_out)     = elt->end;
	(*e_out)     = (*b_out);
	(*eor_out)   = 0;
	(*eof_out)   = 1;
	return P_ERR;
      }
#ifndef NDEBUG
      if (elt->next != next_elt || next_elt == pads->head) { /* should not happen */
	P_FATAL(pads->disc, "Internal error, PDCI_io_need_rec_bytes observed incorrect read_fn behavior");
      }
#endif
    }
    elt = elt->next; /* keep looking for eor|eof */
  }
  /* found eor|eof elt */
  (*b_out)     = (tp->elt->end - tp->remain);
  (*e_out)     = elt->end;
  (*eor_out)   = elt->eor;
  (*eof_out)   = elt->eof;
  return P_OK;
}

Perror_t
PDCI_io_forward(P_t *pads, size_t num_bytes)
{
  PDCI_stkElt_t    *tp        = &(pads->stack[pads->top]);
  size_t todo                 = num_bytes;
  Pio_elt_t     *keep_elt;
  Pio_elt_t     *next_elt;

  P_TRACE(pads->disc, "PDCI_io_forward called");
  /* should be able to move forward without reading new bytes or advancing past EOR/EOF */
  while (todo > 0) {
    if (tp->remain == 0) {
      if (tp->elt->eor|tp->elt->eof) {
	P_FATAL(pads->disc, "Internal error, PDCI_io_forward hit EOR OR EOF");
      }
      if (tp->elt->next == pads->head) {
	P_FATAL(pads->disc, "Internal error, PDCI_io_forward would need to read bytes from io stream");
	return P_ERR;
      }
      tp->elt = tp->elt->next;
      tp->remain = tp->elt->len;
      continue;
    }
    if (todo <= tp->remain) {
      tp->remain -= todo;
      todo = 0;
      break;
    }
    /* current IO rec gets us partway */
    todo -= tp->remain;
    tp->remain = 0;
  }
  /* success */
  if (tp->remain || (tp->elt->eor|tp->elt->eof)) {
    return P_OK;
  }
  /* at end of a non-EOR, non-EOF elt: advance now */
  if (tp->elt->next != pads->head) {
    tp->elt = tp->elt->next;
    tp->remain = tp->elt->len;
    return P_OK;
  }
  /* need to read some data -- use IO disc read_fn */
  keep_elt = pads->stack[0].elt;
  if (P_ERR == pads->disc->io_disc->read_fn(pads, pads->disc->io_disc, keep_elt, &next_elt)) {
    tp->elt = P_LAST_ELT(pads->head); /* IO disc may have added eof elt */
    tp->remain = 0;
    return P_ERR;
  }
#ifndef NDEBUG
  if (next_elt == pads->head) { /* should not happen */
    P_FATAL(pads->disc, "Internal error, PDCI_io_forward observed incorrect read_fn behavior");
    return P_ERR;
  }
#endif
  tp->elt = next_elt;
  tp->remain = tp->elt->len;
  return P_OK;
}

Perror_t
PDCI_io_getElt(P_t *pads, size_t num, Pio_elt_t **elt_out) {
  Pio_elt_t *elt;

  P_TRACE(pads->disc, "PDCI_io_getElt called");
  PDCI_NULLPARAM_CHECK("PDCI_io_getElt", elt_out);
  for (elt = P_FIRST_ELT(pads->head); elt != pads->head; elt = elt->next) {
    if (elt->num == num) {
      (*elt_out) = elt;
      return P_OK;
    }
  }
  return P_ERR;
}

#if P_CONFIG_WRITE_FUNCTIONS > 0
Pbyte*
PDCI_io_write_start(P_t *pads, Sfio_t *io, size_t *buf_len, int *set_buf, const char *whatfn)
{
  Pbyte  *buf;
  ssize_t    n, nm;

  P_TRACE(pads->disc, "PDCI_io_write_start called");
  if (!sfsetbuf(io, (Void_t *)1, 0))  {
    sfsetbuf(io, pads->outbuf, pads->outbuf_len);
    (*set_buf) = 1;
  } else {
    (*set_buf) = 0;
  }
  n = (*buf_len);
  nm = -1 * n;
  if (!(buf = (Pbyte*)sfreserve(io, nm, SF_LOCKR))) {
    PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_IO_ERR, whatfn, "sfreserve failed");
    if (*set_buf) {
      sfsetbuf(io, (Void_t*)0, 0); /* undo sfsetbuf */
    }
    return 0;
  }
  nm = sfvalue(io);
  if (nm < (*buf_len)) {
    error(0, "tried to reserve %ld bytes, got %ld bytes", (long) *buf_len, (long) nm);
    PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_IO_ERR, whatfn, "sfreserve returned insufficient bytes");
    sfwrite(io, (Void_t*)buf, 0); /* release sfreserve */
    if (*set_buf) {
      sfsetbuf(io, (Void_t*)0, 0); /* undo sfsetbuf */
    }
    return 0;
  }
  if (nm > (*buf_len)) {
    (*buf_len) = nm;
  }
  return buf;
}

ssize_t
PDCI_io_write_commit(P_t *pads, Sfio_t *io, Pbyte *buf, int set_buf, size_t num_bytes, const char *whatfn)
{
  ssize_t n;

  P_TRACE(pads->disc, "PDCI_io_write_commit called");
  n = sfwrite(io, (Void_t*)buf, num_bytes);
  if (set_buf) {
    sfsetbuf(io, (Void_t*)0, 0); /* undo sfsetbuf */
  }
  if (n != num_bytes) {
    P_WARN1(pads->disc, "%s: low-level sfwrite failure", whatfn);
    if (n > 0) {
      /* XXX_TODO try to back up ??? */
    }
    return -1;
  }
  return n;
}

void
PDCI_io_write_abort(P_t *pads, Sfio_t *io, Pbyte *buf, int set_buf, const char *whatfn)
{
  P_TRACE(pads->disc, "PDCI_io_write_abort called");
  sfwrite(io, (Void_t*)buf, 0); /* release sfreserve */
  if (set_buf) {
    sfsetbuf(io, (Void_t*)0, 0); /* undo sfsetbuf */
  }
}

ssize_t
PDCI_io_rec_write2io(P_t *pads, Sfio_t *io, Pbyte *buf, size_t rec_data_len, const char *whatfn)
{
  Pio_disc_t *iodisc = pads->disc->io_disc;
  Pbyte      *iobuf, *iobuf_cursor;
  size_t         num_bytes, iobuf_len;
  int            set_buf = 0;
  ssize_t        tlen;

  P_TRACE(pads->disc, "PDCI_io_rec_write2io called");
  if (!iodisc->rec_based) {
    P_WARN1(pads->disc, "%s: pads->disc->io_disc must support records to use this function", whatfn);
    return -1;
  }
  num_bytes = rec_data_len + iodisc->rec_obytes;
  iobuf_len = num_bytes + iodisc->rec_cbytes + 1;
  iobuf = PDCI_io_write_start(pads, io, &iobuf_len, &set_buf, whatfn);
  if (!iobuf) {
    /* write_start reported the error */
    /* don't have to abort because write_start failed */
    return -1;
  }
  iobuf_cursor = iobuf + iodisc->rec_obytes;
  memcpy(iobuf_cursor, buf, rec_data_len);
  iobuf_cursor += rec_data_len;
  if (-1 == (tlen = iodisc->rec_close_fn(pads, iodisc, iobuf_cursor, iobuf, num_bytes))) {
    P_WARN1(pads->disc, "%s: internal error, failed to write record", whatfn);
    PDCI_io_write_abort(pads, io, iobuf, set_buf, whatfn);
    return -1;
  }
  iobuf_len = num_bytes + tlen;
  return PDCI_io_write_commit(pads, io, iobuf, iobuf_len, set_buf, whatfn);
}

ssize_t
PDCI_io_rec_open_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full, const char *whatfn)
{
  Pio_disc_t *iodisc = pads->disc->io_disc;

  P_TRACE(pads->disc, "PDCI_io_rec_open_write2buf called");
  if (!iodisc->rec_based) {
    P_WARN1(pads->disc, "%s: pads->disc->io_disc must support records to use this function", whatfn);
    return -1;
  }
  if (buf_len < iodisc->rec_obytes) {
    (*buf_full) = 1;
    return -1;
  }
  return iodisc->rec_obytes;
}

ssize_t
PDCI_io_rec_close_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			    Pbyte *rec_start, size_t num_bytes, const char *whatfn)
{
  Pio_disc_t *iodisc = pads->disc->io_disc;

  P_TRACE(pads->disc, "PDCI_io_rec_close_write2buf called");
  if (!iodisc->rec_based) {
    P_WARN1(pads->disc, "%s: pads->disc->io_disc must support records to use this function", whatfn);
    return -1;
  }
  if (buf_len < iodisc->rec_cbytes) {
    (*buf_full) = 1;
    return -1;
  }
  return iodisc->rec_close_fn(pads, iodisc, buf, rec_start, num_bytes);
}

ssize_t
PDCI_io_rblk_write2io(P_t *pads, Sfio_t *io, Pbyte *buf, size_t blk_data_len, Puint32 num_recs, const char *whatfn)
{
  Pio_disc_t *iodisc = pads->disc->io_disc;
  Pbyte      *iobuf, *iobuf_cursor;
  size_t         num_bytes, iobuf_len;
  int            set_buf = 0;
  ssize_t        tlen;

  P_TRACE(pads->disc, "PDCI_io_rblk_write2io called");
  if (!iodisc->has_rblks) {
    P_WARN1(pads->disc, "%s: pads->disc->io_disc must support record blocks to use this function", whatfn);
    return -1;
  }
  num_bytes = blk_data_len + iodisc->blk_obytes;
  iobuf_len = num_bytes + iodisc->blk_cbytes + 1;
  iobuf = PDCI_io_write_start(pads, io, &iobuf_len, &set_buf, whatfn);
  if (!iobuf) {
    /* write_start reported the error */
    /* don't have to abort because write_start failed */
    return -1;
  }
  iobuf_cursor = iobuf + iodisc->blk_obytes;
  memcpy(iobuf_cursor, buf, blk_data_len);
  iobuf_cursor += blk_data_len;
  if (-1 == (tlen = iodisc->blk_close_fn(pads, iodisc, iobuf_cursor, iobuf, num_bytes, num_recs))) {
    P_WARN1(pads->disc, "%s: internal error, failed to write block of records", whatfn);
    PDCI_io_write_abort(pads, io, iobuf, set_buf, whatfn);
    return -1;
  }
  iobuf_len = num_bytes + tlen;
  return PDCI_io_write_commit(pads, io, iobuf, iobuf_len, set_buf, whatfn);
}

ssize_t
PDCI_io_rblk_open_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full, const char *whatfn)
{
  Pio_disc_t *iodisc = pads->disc->io_disc;

  P_TRACE(pads->disc, "PDCI_io_rblk_open_write2buf called");
  if (!iodisc->has_rblks) {
    P_WARN1(pads->disc, "%s: pads->disc->io_disc must support record blocks to use this function", whatfn);
    return -1;
  }
  if (buf_len < iodisc->blk_obytes) {
    (*buf_full) = 1;
    return -1;
  }
  return iodisc->blk_obytes;
}

ssize_t
PDCI_io_rblk_close_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			     Pbyte *blk_start, size_t num_bytes, Puint32 num_recs, const char *whatfn)
{
  Pio_disc_t *iodisc = pads->disc->io_disc;

  P_TRACE(pads->disc, "PDCI_io_rblk_close_write2buf called");
  if (!iodisc->has_rblks) {
    P_WARN1(pads->disc, "%s: pads->disc->io_disc must support record blocks to use this function", whatfn);
    return -1;
  }
  if (buf_len < iodisc->blk_cbytes) {
    (*buf_full) = 1;
    return -1;
  }
  return iodisc->blk_close_fn(pads, iodisc, buf, blk_start, num_bytes, num_recs);
}

ssize_t
PDCI_io_rec_fmt2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
		    Pcharset char_set, const char *whatfn)
{
  Pio_disc_t *iodisc = pads->disc->io_disc;

  P_TRACE(pads->disc, "PDCI_io_rec_fmt2buf called");
  if (!iodisc->rec_based) {
    P_WARN1(pads->disc, "%s: pads->disc->io_disc must support records to use this function", whatfn);
    return -1;
  }
  if (buf_len < 1) {
    (*buf_full) = 1;
    return -1;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      *buf = P_ASCII_NEWLINE;
      break;
    case Pcharset_EBCDIC:
      *buf = P_EBCDIC_NEWLINE;
      break;
    default:
      goto invalid_charset;
    }
  return 1;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;
}

#endif /* P_CONFIG_WRITE_FUNCTIONS */

/* ================================================================================ */
/* CHARSET INTERNAL SCAN FUNCTIONS */

#if P_CONFIG_READ_FUNCTIONS > 0

Perror_t
PDCI_char_lit_scan1(P_t *pads, Pchar f, int eat_f, int panic,
		    size_t *offset_out, Pcharset char_set, const char *whatfn)
{
  Pbyte       *p1;
  PDCI_IO_NEED_BYTES_SETUP_SCAN_OR_PANIC(panic);

  PDCI_IODISC_1P_CHECKS(whatfn, offset_out);
  P_TRACE5(pads->disc, "PDCI_char_lit_scan1 args: f %s eat_f %d panic %d, char_set = %s, whatfn = %s",
	     P_qfmt_char(f), eat_f, panic, Pcharset2str(char_set), whatfn);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      f = P_mod_ae_tab[(int)f]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  (*offset_out) = 0;
  PDCI_IO_NEED_BYTES(return P_ERR);
  p1 = begin;
  while (1) {
    if (p1 == end) return P_ERR;
    /* p1 < end */
    if (f == (*p1)) {
      (*offset_out) = (p1-begin);
      if (eat_f) {
	p1++; /* advance beyond char found */
      }
      PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
      return P_OK;
    }
    p1++;
  }

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return P_ERR;

 fatal_forward_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_FORWARD_ERR, whatfn, "IO_forward error");
  return P_ERR;
}

Perror_t
PDCI_char_lit_scan2(P_t *pads, Pchar f, Pchar s, int eat_f, int eat_s, int panic,
		    int *f_found_out, size_t *offset_out, Pcharset char_set, const char *whatfn)
{
  Pbyte       *p1;
  PDCI_IO_NEED_BYTES_SETUP_SCAN_OR_PANIC(panic);

  PDCI_IODISC_2P_CHECKS(whatfn, f_found_out, offset_out);
  P_TRACE7(pads->disc, "PDCI_char_lit_scan2 args: f %s s %s eat_f %d eat_s %d, panic %d, char_set = %s, whatfn = %s",
	     P_qfmt_char(f), P_qfmt_char(s), eat_f, eat_s, panic, Pcharset2str(char_set), whatfn);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      f = P_mod_ae_tab[(int)f]; /* convert to EBCDIC char */
      s = P_mod_ae_tab[(int)s]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  (*offset_out) = 0;
  PDCI_IO_NEED_BYTES(return P_ERR);
  p1 = begin;
  while (1) {
    if (p1 == end) return P_ERR;
    /* p1 < end */
    if (f == (*p1)) {
      (*f_found_out) = 1;
      (*offset_out) = (p1-begin);
      if (eat_f) {
	p1++; /* advance beyond char found */
      }
      PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
      return P_OK;
    }
    if (s == (*p1)) {
      (*f_found_out) = 0;
      (*offset_out) = (p1-begin);
      if (eat_s) {
	p1++; /* advance beyond char found */
      }
      PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
      return P_OK;
    }
    p1++;
  }

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return P_ERR;

 fatal_forward_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_FORWARD_ERR, whatfn, "IO_forward error");
  return P_ERR;
}

Perror_t
PDCI_str_lit_scan1(P_t *pads, const Pstring *f,
		   int eat_f, int panic,
		   size_t *offset_out, Pcharset char_set,
		   const char *whatfn) 
{
  Pstring      *tmp_f = (Pstring*)f;
  size_t        width;
  Pbyte        *p1;
  PDCI_IO_NEED_BYTES_SETUP_SCAN_OR_PANIC(panic);

  PDCI_IODISC_2P_CHECKS(whatfn, f, offset_out);

  P_TRACE5(pads->disc, "PDCI_str_lit_scan args: f = %s eat_f = %d panic %d, char_set = %s, whatfn = %s",
	     P_qfmt_str(f), eat_f, panic, Pcharset2str(char_set), whatfn);
  (*offset_out) = 0;
  width = f->len;
#ifndef NDEBUG
  if (width == 0) {
    if (pads->speclev == 0) {
      P_WARN1(pads->disc, "%s: empty find string specified", whatfn);
    }
    return P_ERR;
  }
#endif
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_f = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_f, f->str, width);
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_NEED_BYTES(return P_ERR);
  p1 = begin;
  while (1) {
    if (p1 + width > end) return P_ERR;
    /* p1 + width <= end */
    if (strncmp((char*)p1, tmp_f->str, width) == 0) {
      (*offset_out) = (p1-begin);
      if (eat_f) {
	p1 += width; /* advance beyond f */
      }
      PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
      return P_OK;
    }
    p1++;
  }

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return P_ERR;

 fatal_forward_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_FORWARD_ERR, whatfn, "IO_forward error");
  return P_ERR;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return P_ERR;
}

Perror_t
PDCI_str_lit_scan2(P_t *pads, const Pstring *f, const Pstring *s,
		   int eat_f, int eat_s, int panic,
		   int *f_found_out, size_t *offset_out, Pcharset char_set,
		   const char *whatfn) 
{
  Pstring      *tmp_f = (Pstring*)f;
  Pstring      *tmp_s = (Pstring*)s;
  size_t        fwidth, swidth;
  Pbyte        *p1;
  PDCI_IO_NEED_BYTES_SETUP_SCAN_OR_PANIC(panic);

  PDCI_IODISC_4P_CHECKS(whatfn, f, s, f_found_out, offset_out);

  P_TRACE7(pads->disc, "PDCI_str_lit_scan args: f = %s s = %s eat_f = %d eat_s = %d, panic %d, char_set = %s, whatfn = %s",
	     P_qfmt_str(f), P_qfmt_str(s), eat_f, eat_s, panic, Pcharset2str(char_set), whatfn);
  (*offset_out) = 0;
  fwidth = f->len;
  swidth = s->len;
#ifndef NDEBUG
  if (fwidth == 0) {
    if (pads->speclev == 0) {
      P_WARN1(pads->disc, "%s: empty f string specified", whatfn);
    }
    return P_ERR;
  }
  if (swidth == 0) {
    if (pads->speclev == 0) {
      P_WARN1(pads->disc, "%s: empty s string specified", whatfn);
    }
    return P_ERR;
  }
#endif
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_f = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_f, f->str, fwidth);
      tmp_s = &pads->stmp2;
      PDCI_A2E_STR_CPY(tmp_s, s->str, swidth);
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_NEED_BYTES(return P_ERR);
  p1 = begin;
  while (1) {
    if (p1 + fwidth > end) return P_ERR;
    /* p1 + fwidth <= end */
    if (strncmp((char*)p1, tmp_f->str, fwidth) == 0) {
      (*f_found_out) = 1;
      (*offset_out) = (p1-begin);
      if (eat_f) {
	p1 += fwidth; /* advance beyond f */
      }
      PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
      return P_OK;
    }
    if ((p1 + swidth <= end) &&
	strncmp((char*)p1, tmp_s->str, swidth) == 0) {
      (*f_found_out) = 0;
      (*offset_out) = (p1-begin);
      if (eat_s) {
	p1 += swidth; /* advance beyond s */
      }
      PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
      return P_OK;
    }
    p1++;
  }

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return P_ERR;

 fatal_forward_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_FORWARD_ERR, whatfn, "IO_forward error");
  return P_ERR;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return P_ERR;
}

Perror_t
PDCI_re_scan1(P_t *pads, Pregexp_t *f,
	      int eat_f, int panic,
	      size_t *offset_out, Pcharset char_set,
	      const char *whatfn) 
{
  regflags_t    e_flags;
  Pbyte        *p1;
  int           bor;
  PDCI_IO_NEED_BYTES_SETUP_SCAN_OR_PANIC(panic);
  bor = elt->bor && (bytes == elt->len);

  PDCI_IODISC_2P_CHECKS(whatfn, f, offset_out);

  P_TRACE4(pads->disc, "PDCI_re_scan args: eat_f = %d panic %d, char_set = %s, whatfn = %s",
	     eat_f, panic, Pcharset2str(char_set), whatfn);
  (*offset_out) = 0;
  if (!f->valid) {
    if (pads->speclev == 0) {
      P_WARN1(pads->disc, "%s: invalid regular expression, f->valid is zero", whatfn);
    }
    return P_ERR;
  }
  PDCI_IO_NEED_BYTES(return P_ERR);
  if (end-begin == 0 && !eor) {
    /* must be at eof, do not want to match anything (not even /$/) */
    return P_ERR;
  }
  e_flags = 0; /* do not pin left when we do a scan */
  if (!bor) {
    e_flags |= REG_NOTBOL;
  }
  if (!eor) {
    e_flags |= REG_NOTEOL;
  }
  if (PDCI_regexp_match(pads, f, begin, end, e_flags, char_set)) return P_ERR;
  /* found */
  (*offset_out) = f->match[0].rm_so;
  if (eat_f) {
    p1 = begin + f->match[0].rm_eo; /* if rm_eo is 1 then last char in match is at begin */
  } else {
    p1 = begin + f->match[0].rm_so; /* if rm_so is zero then match occurred at begin */
  }
  PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
  return P_OK;

 fatal_forward_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_FORWARD_ERR, whatfn, "IO_forward error");
  return P_ERR;
}

Perror_t
PDCI_re_scan2(P_t *pads, Pregexp_t *f, Pregexp_t *s,
	      int eat_f, int eat_s, int panic,
	      int *f_found_out, size_t *offset_out, Pcharset char_set,
	      const char *whatfn) 
{
  regflags_t    e_flags;
  Pbyte        *p1;
  int           bor;
  PDCI_IO_NEED_BYTES_SETUP_SCAN_OR_PANIC(panic);
  bor = elt->bor && (bytes == elt->len);

  PDCI_IODISC_4P_CHECKS(whatfn, f, s, f_found_out, offset_out);

  P_TRACE5(pads->disc, "PDCI_re_scan args: eat_f = %d, eat_s = %d, panic %d, char_set = %s, whatfn = %s",
	     eat_f, eat_s, panic, Pcharset2str(char_set), whatfn);
  (*offset_out) = 0;
  if (!f->valid) {
    if (pads->speclev == 0) {
      P_WARN1(pads->disc, "%s: invalid regular expression, f->valid is zero", whatfn);
    }
    return P_ERR;
  }
  if (!s->valid) {
    if (pads->speclev == 0) {
      P_WARN1(pads->disc, "%s: invalid regular expression, s->valid is zero", whatfn);
    }
    return P_ERR;
  }
  PDCI_IO_NEED_BYTES(return P_ERR);
  if (end-begin == 0 && !eor) {
    /* must be at eof, do not want to match anything (not even /$/) */
    return P_ERR;
  }
  e_flags = 0; /* do not pin left when we do a scan */
  if (!bor) {
    e_flags |= REG_NOTBOL;
  }
  if (!eor) {
    e_flags |= REG_NOTEOL;
  }
  if (PDCI_regexp_match(pads, f, begin, end, e_flags, char_set)) {
    /* no f match */
    if (PDCI_regexp_match(pads, s, begin, end, e_flags, char_set)) {
      /* neither f or s match */
      return P_ERR;
    }
    /* s match */
    (*f_found_out) = 0;
    (*offset_out) = s->match[0].rm_so;
    if (eat_s) {
      p1 = begin + s->match[0].rm_eo; /* if rm_eo is 1 then last char in match is at begin */
    } else {
      p1 = begin + s->match[0].rm_so; /* if rm_so is zero then match occurred at begin */
    }
  } else {
    /* f match */
    if (f->match[0].rm_so &&
	!PDCI_regexp_match(pads, s, begin, end, e_flags, char_set) &&
	s->match[0].rm_so < f->match[0].rm_so) {
      /* s match that begins earlier than f match */
      (*f_found_out) = 0;
      (*offset_out) = s->match[0].rm_so;
      if (eat_s) {
	p1 = begin + s->match[0].rm_eo; /* if rm_eo is 1 then last char in match is at begin */
      } else {
	p1 = begin + s->match[0].rm_so; /* if rm_so is zero then match occurred at begin */
      }
    } else {
      /* f match is the best or only match */
      (*f_found_out) = 1;
      (*offset_out) = f->match[0].rm_so;
      if (eat_f) {
	p1 = begin + f->match[0].rm_eo; /* if rm_eo is 1 then last char in match is at begin */
      } else {
	p1 = begin + f->match[0].rm_so; /* if rm_so is zero then match occurred at begin */
      }
    }
  }
  PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
  return P_OK;

 fatal_forward_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_FORWARD_ERR, whatfn, "IO_forward error");
  return P_ERR;
}

Perror_t
PDCI_cstr_lit_scan1(P_t *pads, const char *f,
		    int eat_f, int panic,
		    size_t *offset_out, Pcharset char_set,
		    const char *whatfn)
{
  Pstring fS;

  PDCI_IODISC_2P_CHECKS(whatfn, f, offset_out);
  P_STRING_INIT_CSTR(fS, f);
  return PDCI_str_lit_scan1(pads, &fS, eat_f, panic, offset_out, char_set, whatfn);
}

Perror_t
PDCI_cstr_lit_scan2(P_t *pads, const char *f, const char *s,
		    int eat_f, int eat_s, int panic,
		    int *f_found_out, size_t *offset_out, Pcharset char_set,
		    const char *whatfn)
{
  Pstring fS, sS;

  PDCI_IODISC_4P_CHECKS(whatfn, f, s, f_found_out, offset_out);
  P_STRING_INIT_CSTR(fS, f);
  P_STRING_INIT_CSTR(sS, s);
  return PDCI_str_lit_scan2(pads, &fS, &sS, eat_f, eat_s, panic, f_found_out, offset_out, char_set, whatfn);
}

#endif /* P_CONFIG_READ_FUNCTIONS */

/* ================================================================================ */
/* CHARSET INTERNAL MATCH FUNCTIONS */

#if P_CONFIG_READ_FUNCTIONS > 0

Perror_t
PDCI_char_lit_match(P_t *pads, Pchar f, int eat_f,
		    Pcharset char_set, const char *whatfn)
{
  PDCI_IO_NEED_K_BYTES_SETUP;

  PDCI_IODISC_0P_CHECKS(whatfn);
  P_TRACE4(pads->disc, "PDCI_char_lit_match args: f %s eat_f %d char_set = %s, whatfn = %s",
	     P_qfmt_char(f), eat_f, Pcharset2str(char_set), whatfn);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      f = P_mod_ae_tab[(int)f]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_NEED_K_BYTES(1, goto fatal_nb_io_err);
  if (end-begin != 1) return P_ERR;
  if (f == (*begin)) {
    if (eat_f) {
      PDCI_IO_FORWARD(1, goto fatal_forward_err);
    }
    return P_OK;
  }
  /* not found */
  return P_ERR;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return P_ERR;

 fatal_nb_io_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_IO_ERR, whatfn, "IO error (nb)");
  return P_ERR;

 fatal_forward_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_FORWARD_ERR, whatfn, "IO_forward error");
  return P_ERR;
}

Perror_t
PDCI_str_lit_match(P_t *pads, const Pstring *f, int eat_f,
		   Pcharset char_set, const char *whatfn) 
{
  Pstring      *tmp_f = (Pstring*)f;
  size_t        width;
  PDCI_IO_NEED_K_BYTES_SETUP;

  PDCI_IODISC_1P_CHECKS(whatfn, f);

  P_TRACE4(pads->disc, "PDCI_str_lit_match args: f = %s eat_f = %d char_set = %s, whatfn = %s",
	     P_qfmt_str(f), eat_f, Pcharset2str(char_set), whatfn);
  width = f->len;
#ifndef NDEBUG
  if (width == 0) {
    if (pads->speclev == 0) {
      P_WARN1(pads->disc, "%s: empty find string specified", whatfn);
    }
    return P_ERR;
  }
#endif
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_f = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_f, f->str, width);
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
  if (end-begin != width) return P_ERR;
  if (strncmp((char*)begin, tmp_f->str, width) == 0) {
    if (eat_f) {
      PDCI_IO_FORWARD(width, goto fatal_forward_err);
    }
    return P_OK;
  }
  /* not found */ 
  return P_ERR;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return P_ERR;

 fatal_nb_io_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_IO_ERR, whatfn, "IO error (nb)");
  return P_ERR;

 fatal_forward_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_FORWARD_ERR, whatfn, "IO_forward error");
  return P_ERR;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return P_ERR;
}

Perror_t
PDCI_re_match(P_t *pads, Pregexp_t *f, int eat_f,
	      Pcharset char_set, const char *whatfn)
{
  regflags_t    e_flags;
  int           bor;
  PDCI_IO_NEED_BYTES_SETUP_MATCH;
  bor = elt->bor && (bytes == elt->len);

  PDCI_IODISC_1P_CHECKS(whatfn, f);

  P_TRACE3(pads->disc, "PDCI_re_match args: eat_f = %d char_set = %s, whatfn = %s",
	   eat_f, Pcharset2str(char_set), whatfn);
  if (!f->valid) {
    if (pads->speclev == 0) {
      P_WARN1(pads->disc, "%s: invalid regular expression, f->valid is zero", whatfn);
    }
    return P_ERR;
  }
  PDCI_IO_NEED_BYTES(return P_ERR);
  if (end-begin == 0 && !eor) {
    /* must be at eof, do not want to match anything (not even /$/) */
    return P_ERR;
  }
  e_flags = REG_LEFT; /* pin left when we do an inclusive match */
  if (!bor) {
    e_flags |= REG_NOTBOL;
  }
  if (!eor) {
    e_flags |= REG_NOTEOL;
  }
  if (PDCI_regexp_match(pads, f, begin, end, e_flags, char_set)) return P_ERR;
  /* found */
  if (eat_f) {
    size_t width = f->match[0].rm_eo; /* if rm_eo is 1 then last char in match is at begin */
    PDCI_IO_FORWARD(width, goto fatal_forward_err);
  }
  return P_OK;

 fatal_forward_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_FORWARD_ERR, whatfn, "IO_forward error");
  return P_ERR;
}

Perror_t
PDCI_cstr_re_match(P_t *pads, const char *f, int eat_f,
		   Pcharset char_set, const char *whatfn)
{
  Perror_t    res;
  P_REGEXP_DECL_NULL(compiled_exp);

  PDCI_IODISC_1P_CHECKS(whatfn, f);
  if (P_ERR == PDCI_regexp_compile_cstr(pads, f, &compiled_exp, "Pcstr_re_match arg", whatfn)) {
    goto bad_exp;
  }
  res = PDCI_re_match(pads, &compiled_exp, eat_f, char_set, whatfn);
  PDCI_regexp_cleanup(pads, &compiled_exp, whatfn);
  return res;

 bad_exp:
  /* regexp_compile already issued a warning */
  return P_ERR;
}

Perror_t
PDCI_cstr_lit_match(P_t *pads, const char *f, int eat_f,
		    Pcharset char_set, const char *whatfn)
{
  Pstring fS;

  PDCI_IODISC_1P_CHECKS(whatfn, f);
  P_STRING_INIT_CSTR(fS, f);
  return PDCI_str_lit_match(pads, &fS, eat_f, char_set, whatfn);
}

#endif /* P_CONFIG_READ_FUNCTIONS */

/* ================================================================================ */
/* CHARSET INTERNAL READ ROUTINES */

#if P_CONFIG_READ_FUNCTIONS > 0

Perror_t
PDCI_char_lit_read(P_t *pads, const Pbase_m *m, Pchar c,
		   Pbase_pd *pd, Pchar *c_out, Pcharset char_set,
		   const char *whatfn)
{
  PDCI_IO_NEED_K_BYTES_SETUP;

  PDCI_IODISC_3P_CHECKS(whatfn, m, pd, c_out);
  PDCI_READFN_PD_INIT(pads, pd);
  P_TRACE3(pads->disc, "PDCI_char_lit_read called, arg: %s, char_set %s, whatfn = %s",
	     P_qfmt_char(c), Pcharset2str(char_set), whatfn);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      c = P_mod_ae_tab[(int)c]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_NEED_K_BYTES(1, goto fatal_nb_io_err);
  if (end-begin != 1) goto at_eor_or_eof_err;
  if (P_Test_NotSynCheck(*m) || (c == (*begin))) {
    PDCI_IO_FORWARD(1, goto fatal_forward_err);
    (*c_out) = c;
    return P_OK;  /* IO cursor is one beyond c */
  }
  goto not_found;

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 at_eor_or_eof_err:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, eor ? P_AT_EOR : P_AT_EOF);

 not_found:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_CHAR_LIT_NOT_FOUND);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);

 fatal_forward_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO_forward error", P_FORWARD_ERR);
}

Perror_t
PDCI_str_lit_read(P_t *pads, const Pbase_m *m, const Pstring *s,
		  Pbase_pd *pd, Pstring *s_out, Pcharset char_set, const char *whatfn)
{
  Pstring      *es = (Pstring*)s;
  size_t        width;
  PDCI_IO_NEED_K_BYTES_SETUP;

  PDCI_IODISC_4P_CHECKS(whatfn, m, pd, s, s_out);
  PDCI_READFN_PD_INIT(pads, pd);
  P_TRACE3(pads->disc, "PDCI_str_lit_read called, arg: %s, char_set %s, whatfn = %s",
	     P_qfmt_str(s), Pcharset2str(char_set), whatfn);
  width = s->len;
  PDCI_READFN_WIDTH_CHECK(whatfn, "string literal", width);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      es = &pads->stmp1;
      PDCI_A2E_STR_CPY(es, s->str, width);
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
  if (end-begin != width)     goto width_not_avail;
  if (P_Test_NotSynCheck(*m) || (strncmp((char*)begin, es->str, width) == 0)) {
    error(0, "Copying literal character.");
    switch (char_set)
      {
      case Pcharset_ASCII:
	PDCI_A_STR_SET(m, s_out, begin, width);
	break;
      case Pcharset_EBCDIC:
	PDCI_STR_CPY_ON_SET(m, s_out, s->str, width);
	break;
      default:
	goto invalid_charset;
      }
    PDCI_IO_FORWARD(width, goto fatal_forward_err);
    return P_OK;    /* found it */
  }
  goto not_found;

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 width_not_avail:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_WIDTH_NOT_AVAILABLE);

 not_found:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, width-1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_STR_LIT_NOT_FOUND);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);

 fatal_forward_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO_forward error", P_FORWARD_ERR);

 fatal_alloc_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "Memory alloc error", P_ALLOC_ERR);
}

Perror_t
PDCI_cstr_lit_read(P_t *pads, const Pbase_m *m, const char *s, 
		   Pbase_pd *pd, Pstring *s_out, Pcharset char_set, const char *whatfn)
{
  Pstring  p_s;

  PDCI_IODISC_4P_CHECKS(whatfn, m, pd, s, s_out);
  P_STRING_INIT_CSTR(p_s, s);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  return PDCI_str_lit_read(pads, m, &p_s, pd, s_out, char_set, whatfn);
}

Perror_t
PDCI_countX_read(P_t *pads, const Pbase_m *m,
		 Pbase_pd *pd, Pint32 *res_out, Pcharset char_set, const char *whatfn, Puint8 x, int eor_required, size_t count_max)
{
  Pint32       count = 0;
  Pbyte       *p1;
  PDCI_IO_NEED_BYTES_SETUP_SPECIFIC;

  PDCI_IODISC_3P_CHECKS(whatfn, m, pd, res_out);
  PDCI_READFN_PD_INIT(pads, pd);
  P_TRACE5(pads->disc, "PDCI_countX_read called, args: x = %s eor_required = %d, count_max = %lld, char_set %s, whatfn = %s",
	     P_qfmt_char(x), eor_required, (long long)count_max, Pcharset2str(char_set), whatfn);
  (*res_out) = 0;
  if (!pads->disc->io_disc->rec_based && !count_max) {
    goto bad_param;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      x = P_mod_ae_tab[(int)x]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_NEED_BYTES_SPECIFIC(count_max, goto fatal_nb_io_err);
  p1 = begin;
  while (!(eor|eof)) {
    if (p1 == end) goto hit_limit;
    if (x == (*p1)) {
      count++;
    }
    p1++;
  }
  if (!eor && eor_required) { /* EOF encountered first, error */
    PDCI_READFN_BEGINLOC(pads, pd->loc);
    PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
    PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_EOF_BEFORE_EOR);
  }
  (*res_out) = count;
  return P_OK;

 bad_param:
  if (pads->speclev == 0) {
    P_WARN1(pads->disc, "%s: countX_read must have scan_max > 0 with a non-record-based IO discipline", whatfn);
  }
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_BAD_PARAM);

 hit_limit:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_COUNT_MAX_LIMIT);

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);
}

Perror_t
PDCI_countXtoY_read(P_t *pads, const Pbase_m *m,
		    Pbase_pd *pd, Pint32 *res_out, Pcharset char_set, const char *whatfn, Puint8 x, Puint8 y, size_t count_max)
{
  Pint32       count = 0;
  Pbyte       *p1;
  PDCI_IO_NEED_BYTES_SETUP_SPECIFIC;

  PDCI_IODISC_3P_CHECKS(whatfn, m, pd, res_out);
  PDCI_READFN_PD_INIT(pads, pd);
  P_TRACE5(pads->disc, "PDCI_countXtoY_read called, args: x = %s y = %s, count_max %lld, char_set %s, whatfn = %s",
	     P_qfmt_char(x), P_qfmt_char(y), (long long)count_max, Pcharset2str(char_set), whatfn);
  (*res_out) = 0;
  if (!pads->disc->io_disc->rec_based && !count_max) {
    goto bad_param;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      x = P_mod_ae_tab[(int)x]; /* convert to EBCDIC char */
      y = P_mod_ae_tab[(int)y]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_NEED_BYTES_SPECIFIC(count_max, goto fatal_nb_io_err);
  p1 = begin;
  while (!(eor|eof)) {
    if (p1 == end) goto hit_limit;
    if (y == (*p1)) { /* success */
      (*res_out) = count;
      return P_OK;
    }
    if (x == (*p1)) {
      count++;
    }
    p1++;
  }
  goto not_found; /* hit eor or eof, y not found */

 bad_param:
  if (pads->speclev == 0) {
    P_WARN1(pads->disc, "%s: countXtoY_read must have scan_max > 0 with a non-record-based IO discipline", whatfn);
  }
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_BAD_PARAM);

 hit_limit:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_COUNT_MAX_LIMIT);

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 not_found:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_CHAR_LIT_NOT_FOUND);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);
}

Perror_t
PDCI_timestamp_FW_read(P_t *pads,
		       const Pbase_m *m,
		       Pbase_pd *pd,
		       Puint32 *res_out,
		       Pcharset char_set,
		       const char *whatfn,
		       const char *format_descr,
		       const char *tzone_descr,
		       PerrCode_t errCode,
		       int just_time,
		       const char *format,
		       Tm_zone_t *tzone,
		       size_t width)
{
  Pstring     *s;
  PDCI_IODISC_3P_CHECKS(whatfn, m, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_timestamp_FW_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_FW_read(pads, m, pd, s, char_set, whatfn, width)) {
    return P_ERR;
  }
  PDCI_FINISH_TIMESTAMP_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_timestamp_read(P_t *pads,
		    const Pbase_m *m,
		    Pbase_pd *pd,
		    Puint32 *res_out,
		    Pcharset char_set,
		    const char *whatfn,
		    const char *format_descr,
		    const char *tzone_descr,
		    PerrCode_t errCode,
		    int just_time,
		    const char *format,
		    Tm_zone_t *tzone,
		    Pchar stopChar)
{
  Pstring     *s;
  PDCI_IODISC_3P_CHECKS(whatfn, m, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE5(pads->disc, "PDCI_timestamp_read called, args: stopChar %s char_set %s, whatfn = %s, format = %s, tzone = %s",
	   P_qfmt_char(stopChar), Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_read(pads, m, pd, s, char_set, whatfn, stopChar)) {
    return P_ERR;
  }
  PDCI_FINISH_TIMESTAMP_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_timestamp_ME_read(P_t *pads,
		       const Pbase_m *m,
		       Pbase_pd *pd,
		       Puint32 *res_out,
		       Pcharset char_set,
		       const char *whatfn,
		       const char *format_descr,
		       const char *tzone_descr,
		       PerrCode_t errCode,
		       int just_time,
		       const char *format,
		       Tm_zone_t *tzone,
		       const char *matchRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, matchRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_timestamp_ME_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_ME_read(pads, m, pd, s, char_set, whatfn, matchRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_TIMESTAMP_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_timestamp_CME_read(P_t *pads,
			const Pbase_m *m,
			Pbase_pd *pd,
			Puint32 *res_out,
			Pcharset char_set,
			const char *whatfn,
			const char *format_descr,
			const char *tzone_descr,
			PerrCode_t errCode,
			int just_time,
			const char *format,
			Tm_zone_t *tzone,
			Pregexp_t *matchRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, matchRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_timestamp_CME_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_CME_read(pads, m, pd, s, char_set, whatfn, matchRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_TIMESTAMP_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_timestamp_SE_read(P_t *pads,
		       const Pbase_m *m,
		       Pbase_pd *pd,
		       Puint32 *res_out,
		       Pcharset char_set,
		       const char *whatfn,
		       const char *format_descr,
		       const char *tzone_descr,
		       PerrCode_t errCode,
		       int just_time,
		       const char *format,
		       Tm_zone_t *tzone,
		       const char *stopRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, stopRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_timestamp_SE_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_SE_read(pads, m, pd, s, char_set, whatfn, stopRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_TIMESTAMP_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_timestamp_CSE_read(P_t *pads,
			const Pbase_m *m,
			Pbase_pd *pd,
			Puint32 *res_out,
			Pcharset char_set,
			const char *whatfn,
			const char *format_descr,
			const char *tzone_descr,
			PerrCode_t errCode,
			int just_time,
			const char *format,
			Tm_zone_t *tzone,
			Pregexp_t *stopRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, stopRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_timestamp_CSE_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_CSE_read(pads, m, pd, s, char_set, whatfn, stopRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_TIMESTAMP_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_date_FW_read(P_t *pads,
		  const Pbase_m *m,
		  Pbase_pd *pd,
		  Puint32 *res_out,
		  Pcharset char_set,
		  const char *whatfn,
		  const char *format_descr,
		  const char *tzone_descr,
		  PerrCode_t errCode,
		  int just_time,
		  const char *format,
		  Tm_zone_t *tzone,
		  size_t width)
{
  Pstring     *s;
  PDCI_IODISC_3P_CHECKS(whatfn, m, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_date_FW_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_FW_read(pads, m, pd, s, char_set, whatfn, width)) {
    return P_ERR;
  }
  PDCI_FINISH_DATE_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_date_read(P_t *pads,
	       const Pbase_m *m,
	       Pbase_pd *pd,
	       Puint32 *res_out,
	       Pcharset char_set,
	       const char *whatfn,
	       const char *format_descr,
	       const char *tzone_descr,
	       PerrCode_t errCode,
	       int just_time,
	       const char *format,
	       Tm_zone_t *tzone,
	       Pchar stopChar)
{
  Pstring     *s;
  PDCI_IODISC_3P_CHECKS(whatfn, m, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE5(pads->disc, "PDCI_date_read called, args: stopChar %s char_set %s, whatfn = %s, format = %s, tzone = %s",
	   P_qfmt_char(stopChar), Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_read(pads, m, pd, s, char_set, whatfn, stopChar)) {
    return P_ERR;
  }
  PDCI_FINISH_DATE_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_date_ME_read(P_t *pads,
		  const Pbase_m *m,
		  Pbase_pd *pd,
		  Puint32 *res_out,
		  Pcharset char_set,
		  const char *whatfn,
		  const char *format_descr,
		  const char *tzone_descr,
		  PerrCode_t errCode,
		  int just_time,
		  const char *format,
		  Tm_zone_t *tzone,
		  const char *matchRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, matchRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_date_ME_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_ME_read(pads, m, pd, s, char_set, whatfn, matchRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_DATE_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_date_CME_read(P_t *pads,
		   const Pbase_m *m,
		   Pbase_pd *pd,
		   Puint32 *res_out,
		   Pcharset char_set,
		   const char *whatfn,
		   const char *format_descr,
		   const char *tzone_descr,
		   PerrCode_t errCode,
		   int just_time,
		   const char *format,
		   Tm_zone_t *tzone,
		   Pregexp_t *matchRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, matchRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_date_CME_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_CME_read(pads, m, pd, s, char_set, whatfn, matchRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_DATE_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_date_SE_read(P_t *pads,
		  const Pbase_m *m,
		  Pbase_pd *pd,
		  Puint32 *res_out,
		  Pcharset char_set,
		  const char *whatfn,
		  const char *format_descr,
		  const char *tzone_descr,
		  PerrCode_t errCode,
		  int just_time,
		  const char *format,
		  Tm_zone_t *tzone,
		  const char *stopRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, stopRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_date_SE_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_SE_read(pads, m, pd, s, char_set, whatfn, stopRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_DATE_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_date_CSE_read(P_t *pads,
		   const Pbase_m *m,
		   Pbase_pd *pd,
		   Puint32 *res_out,
		   Pcharset char_set,
		   const char *whatfn,
		   const char *format_descr,
		   const char *tzone_descr,
		   PerrCode_t errCode,
		   int just_time,
		   const char *format,
		   Tm_zone_t *tzone,
		   Pregexp_t *stopRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, stopRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_date_CSE_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_CSE_read(pads, m, pd, s, char_set, whatfn, stopRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_DATE_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_time_FW_read(P_t *pads,
		  const Pbase_m *m,
		  Pbase_pd *pd,
		  Puint32 *res_out,
		  Pcharset char_set,
		  const char *whatfn,
		  const char *format_descr,
		  const char *tzone_descr,
		  PerrCode_t errCode,
		  int just_time,
		  const char *format,
		  Tm_zone_t *tzone,
		  size_t width)
{
  Pstring     *s;
  PDCI_IODISC_3P_CHECKS(whatfn, m, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_time_FW_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_FW_read(pads, m, pd, s, char_set, whatfn, width)) {
    return P_ERR;
  }
  PDCI_FINISH_TIME_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_time_read(P_t *pads,
	       const Pbase_m *m,
	       Pbase_pd *pd,
	       Puint32 *res_out,
	       Pcharset char_set,
	       const char *whatfn,
	       const char *format_descr,
	       const char *tzone_descr,
	       PerrCode_t errCode,
	       int just_time,
	       const char *format,
	       Tm_zone_t *tzone,
	       Pchar stopChar)
{
  Pstring     *s;
  PDCI_IODISC_3P_CHECKS(whatfn, m, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE5(pads->disc, "PDCI_time_read called, args: stopChar %s char_set %s, whatfn = %s, format = %s, tzone = %s",
	   P_qfmt_char(stopChar), Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_read(pads, m, pd, s, char_set, whatfn, stopChar)) {
    return P_ERR;
  }
  PDCI_FINISH_TIME_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_time_ME_read(P_t *pads,
		  const Pbase_m *m,
		  Pbase_pd *pd,
		  Puint32 *res_out,
		  Pcharset char_set,
		  const char *whatfn,
		  const char *format_descr,
		  const char *tzone_descr,
		  PerrCode_t errCode,
		  int just_time,
		  const char *format,
		  Tm_zone_t *tzone,
		  const char *matchRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, matchRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_time_ME_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_ME_read(pads, m, pd, s, char_set, whatfn, matchRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_TIME_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_time_CME_read(P_t *pads,
		   const Pbase_m *m,
		   Pbase_pd *pd,
		   Puint32 *res_out,
		   Pcharset char_set,
		   const char *whatfn,
		   const char *format_descr,
		   const char *tzone_descr,
		   PerrCode_t errCode,
		   int just_time,
		   const char *format,
		   Tm_zone_t *tzone,
		   Pregexp_t *matchRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, matchRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_time_CME_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_CME_read(pads, m, pd, s, char_set, whatfn, matchRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_TIME_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_time_SE_read(P_t *pads,
		  const Pbase_m *m,
		  Pbase_pd *pd,
		  Puint32 *res_out,
		  Pcharset char_set,
		  const char *whatfn,
		  const char *format_descr,
		  const char *tzone_descr,
		  PerrCode_t errCode,
		  int just_time,
		  const char *format,
		  Tm_zone_t *tzone,
		  const char *stopRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, stopRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_time_SE_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_SE_read(pads, m, pd, s, char_set, whatfn, stopRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_TIME_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_time_CSE_read(P_t *pads,
		   const Pbase_m *m,
		   Pbase_pd *pd,
		   Puint32 *res_out,
		   Pcharset char_set,
		   const char *whatfn,
		   const char *format_descr,
		   const char *tzone_descr,
		   PerrCode_t errCode,
		   int just_time,
		   const char *format,
		   Tm_zone_t *tzone,
		   Pregexp_t *stopRegexp)
{
  Pstring     *s;
  PDCI_IODISC_4P_CHECKS(whatfn, m, stopRegexp, pd, res_out);
  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  s = &pads->stmp1;
  P_TRACE4(pads->disc, "PDCI_time_CSE_read called, args: char_set %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);
  /* Following call does a Pbase_pd_init_no_err(pd) */
  if (P_ERR == PDCI_string_CSE_read(pads, m, pd, s, char_set, whatfn, stopRegexp)) {
    return P_ERR;
  }
  PDCI_FINISH_TIME_READ(m, format, tzone, errCode, just_time);
}

Perror_t
PDCI_ip_read(P_t *pads, const Pbase_m *m,
	     Pbase_pd *pd, Puint32 *res_out, Pcharset char_set, const char *whatfn)
{
  Puint32      addr = 0;
  Pbyte       *p1;
  Pbyte       *part_start;
  Pbyte       *range_err_start = 0;
  Pbyte       *range_err_end   = 0;
  int          zero = '0', nine = '9', dot = '.';
  int          digits;
  int          byte = 0;
  int          parts = 0;
  PDCI_IO_NEED_BYTES_SETUP_MATCH;

  PDCI_IODISC_3P_CHECKS(whatfn, m, pd, res_out);
  P_TRACE2(pads->disc, "PDCI_ip_read called, args: char_set %s, whatfn = %s",
	   Pcharset2str(char_set), whatfn);
  PDCI_READFN_PD_INIT(pads, pd);

  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      zero = P_mod_ae_tab[zero]; /* convert to EBCDIC char */
      nine = P_mod_ae_tab[nine]; /* convert to EBCDIC char */
      dot  = P_mod_ae_tab[dot];  /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }

  PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
  if (begin == end) {
    goto at_eor_or_eof_err;
  }
  p1 = begin;
  if (P_Test_Ignore(*m)) {
    /* move beyond anything that looks like an ip address, return P_ERR if none such */
    if (!((*p1) >= zero && (*p1) <= nine)) {
      return P_ERR; /* did not find an ip address */
    }
    /* skip up to four parts with up to 3 digits each, move IO cursor, return P_OK */
    while (parts < 4) {
      parts++;
      digits = 0;
      while (((*p1) >= zero && (*p1) <= nine) && digits < 3) {
	p1++;
	digits++;
	if (p1 == end && !(eor|eof)) {
	  /* did not find end of ip address within goal_bytes (normally P_BUILTIN_MATCH_MAX) */
	  return P_ERR;
	}
      }
      if ((*p1) != dot) break;
      // found a dot after some digits, skip it
      p1++;
      if (!((*p1) >= zero && (*p1) <= nine)) break;
      // found another part, continue loop
    }
    // successfully skipped over up to four parts and optional trailing dot
    PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
    return P_OK;

  } else { /* !P_Test_Ignore(*m) */

    if (!((*p1) >= zero && (*p1) <= nine)) {
      p1++;  /* include first char as the error loc */
      goto invalid; /* did not find an ip address */
    }
    /* parse up to four parts with up to 3 digits each, move IO cursor, return P_OK */
    while (parts < 4) {
      part_start = p1;
      if (parts > 0) {
	// byte is folded in after each loop iter completes
	// including just after while loop
	addr = addr << 8;
	addr += byte;
      }
      parts++;
      byte = 0;
      digits = 0;
      while (((*p1) >= zero && (*p1) <= nine) && digits < 3) {
	byte *= 10;
	byte += (*p1) - zero;
	p1++;
	digits++;
	if (p1 == end && !(eor|eof)) {
	  /* did not find end of ip address within goal_bytes (normally P_BUILTIN_MATCH_MAX) */
	  goto invalid;
	}
      }
      if (byte > 255 && !range_err_start) {
	range_err_start = part_start;
	range_err_end   = p1;
	byte = 255;
      }
      if ((*p1) != dot) break;
      // found a dot after some digits, skip it
      p1++;
      if (!((*p1) >= zero && (*p1) <= nine)) break;
      // found another part, continue loop
    }
    // Successfully skipped over up to four parts and optional trailing dot.
    // The final byte has not been added to addr yet.
    // TODO: unless it is the first part,
    // we think it is added at the end, but we are not sure.
    switch (parts) {
    case 1:
      addr = byte;
      addr = addr << 24;
      break;
    case 2:
      addr = addr << 24;
      addr += byte;
      break;
    case 3:
      addr = addr << 16;
      addr += byte;
      break;
    case 4:
      addr = addr << 8;
      addr += byte;
      break;
    }
    PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
    if (range_err_start && P_Test_SemCheck(*m)) goto invalid_range;
    if (P_Test_Set(*m)) {
      (*res_out) = addr;
    }
    return P_OK;
  }

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 at_eor_or_eof_err:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, eor ? P_AT_EOR : P_AT_EOF);

 invalid:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_IP);

 invalid_range:
  PDCI_READFN_BEGINLOC_MINUSK(pads, pd->loc, p1 - range_err_start);
  PDCI_READFN_ENDLOC_MINUSK(pads, pd->loc, (p1 - range_err_end) + 1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_IP_RANGE);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);

 fatal_forward_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO_forward error", P_FORWARD_ERR);
}

Perror_t
PDCI_char_read(P_t *pads, const Pbase_m *m,
	       Pbase_pd *pd, Pchar *c_out, Pcharset char_set,
	       const char *whatfn)
{
  PDCI_IO_NEED_K_BYTES_SETUP;

  PDCI_IODISC_2P_CHECKS(whatfn, m, pd);
  PDCI_READFN_PD_INIT(pads, pd);
  P_TRACE2(pads->disc, "PDCI_char_read called, char_set = %s, whatfn = %s",
	     Pcharset2str(char_set), whatfn);
  PDCI_IO_NEED_K_BYTES(1, goto fatal_nb_io_err);
  if (end-begin != 1)     goto width_not_avail;
  if (c_out && P_Test_Set(*m)) {
    switch (char_set)
      {
      case Pcharset_ASCII:
	(*c_out) = *begin;
	break;
      case Pcharset_EBCDIC:
	(*c_out) = P_mod_ea_tab[(int)(*begin)];
	break;
      default:
	goto invalid_charset;
      }
  }
  PDCI_IO_FORWARD(1, goto fatal_forward_err);
  return P_OK;

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 width_not_avail:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_WIDTH_NOT_AVAILABLE);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);

 fatal_forward_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO_forward error", P_FORWARD_ERR);
}

Perror_t
PDCI_string_FW_read(P_t *pads, const Pbase_m *m,
		    Pbase_pd *pd, Pstring *s_out, Pcharset char_set,
		    const char *whatfn, size_t width)
{
  PDCI_IO_NEED_K_BYTES_SETUP;

  PDCI_IODISC_2P_CHECKS(whatfn, m, pd);
  PDCI_READFN_PD_INIT(pads, pd);
  P_TRACE2(pads->disc, "PDCI_string_FW_read called, char_set = %s, whatfn = %s",
	     Pcharset2str(char_set), whatfn);
  PDCI_READFN_WIDTH_CHECK_ZERO_OK(whatfn, "string", width);

  /* ensure there are width chars available */
  PDCI_IO_NEED_K_BYTES(width, goto fatal_nb_io_err);
  if (width == 0) {
    s_out->str = (char*)begin;
    s_out->len = 0;
    return P_OK;
  }
  if (end-begin != width) goto width_not_avail;
  switch (char_set)
    {
    case Pcharset_ASCII:
      PDCI_A_STR_SET(m, s_out, begin, width);
      break;
    case Pcharset_EBCDIC:
      PDCI_E_STR_SET(m, s_out, begin, width);
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_FORWARD(width, goto fatal_forward_err);
  return P_OK;

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 width_not_avail:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_WIDTH_NOT_AVAILABLE);

 fatal_alloc_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "Memory alloc error", P_ALLOC_ERR);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);

 fatal_forward_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO_forward error", P_FORWARD_ERR);
}

Perror_t
PDCI_string_read(P_t *pads, const Pbase_m *m,
		 Pbase_pd *pd, Pstring *s_out, Pcharset char_set,
		 const char *whatfn, Pchar stopChar)
{
  Pbyte        *p1;
  PDCI_IO_NEED_BYTES_SETUP_SCAN;

  PDCI_IODISC_2P_CHECKS(whatfn, m, pd);
  PDCI_READFN_PD_INIT(pads, pd);
  P_TRACE2(pads->disc, "PDCI_string_read called, char_set = %s, whatfn = %s",
	     Pcharset2str(char_set), whatfn);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      stopChar = P_mod_ae_tab[(int)stopChar]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
  p1 = begin;
  while (1) {
    if (p1 == end) {
      /* a NULL stopChar is allowed to match at eor or eof */
      if (!stopChar && (eor|eof)) break; /* found */
      goto not_found;
    }
    if (stopChar == (*p1)) break; /* found */
    p1++;
  }
  /* termination condition found */
  switch (char_set)
    {
    case Pcharset_ASCII:
      PDCI_A_STR_SET(m, s_out, begin, p1-begin);
      break;
    case Pcharset_EBCDIC:
      PDCI_E_STR_SET(m, s_out, begin, p1-begin);
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
  return P_OK;

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 not_found:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, p1-begin-1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_CHAR_LIT_NOT_FOUND);

 fatal_alloc_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "Memory alloc error", P_ALLOC_ERR);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);

 fatal_forward_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO_forward error", P_FORWARD_ERR);
}

Perror_t
PDCI_string_ME_read(P_t *pads, const Pbase_m *m,
		    Pbase_pd *pd, Pstring *s_out, Pcharset char_set,
		    const char *whatfn, const char *matchRegexp)
{
  Perror_t    res;
  P_REGEXP_DECL_NULL(compiled_exp);

  PDCI_IODISC_3P_CHECKS(whatfn, m, matchRegexp, pd);
  PDCI_READFN_PD_INIT(pads, pd);
  if (P_ERR == PDCI_regexp_compile_cstr(pads, matchRegexp, &compiled_exp, "Pstring_ME arg", whatfn)) {
    goto bad_exp;
  }
  res = PDCI_string_CME_read(pads, m, pd, s_out, char_set, whatfn, &compiled_exp);
  PDCI_regexp_cleanup(pads, &compiled_exp, whatfn);
  return res;

 bad_exp:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  /* regexp_compile already issued a warning */
  PDCI_READFN_RET_ERRCODE_NOWARN(P_INVALID_REGEXP);
}

Perror_t
PDCI_string_CME_read(P_t *pads, const Pbase_m *m,
		     Pbase_pd *pd, Pstring *s_out, Pcharset char_set,
		     const char *whatfn, Pregexp_t *matchRegexp)
{
  regflags_t   e_flags;
  Pbyte       *p1;
  int           bor;
  PDCI_IO_NEED_BYTES_SETUP_MATCH;
  bor = elt->bor && (bytes == elt->len);

  PDCI_IODISC_3P_CHECKS(whatfn, m, matchRegexp, pd);
  PDCI_READFN_PD_INIT(pads, pd);
  P_TRACE2(pads->disc, "PDCI_string_CME_read called, char_set = %s, whatfn = %s",
	     Pcharset2str(char_set), whatfn);
  PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
  if (end-begin == 0 && !eor) {
    /* must be at eof, do not want to match anything (not even /$/) */
    goto not_found;
  }
  e_flags = REG_LEFT; /* pin left when we do an inclusive match */
  if (!bor) {
    e_flags |= REG_NOTBOL;
  }
  if (!eor) {
    e_flags |= REG_NOTEOL;
  }
  if (PDCI_regexp_match(pads, matchRegexp, begin, end, e_flags, char_set)) goto not_found;
  /* found, set p1 to just beyond last char to include */
  /*   p1 = begin + (exp->match[0].rm_eo - exp->match[0].rm_so); */
  p1 = begin + matchRegexp->match[0].rm_eo; /* rm_so must be zero due to pin-left */
  switch (char_set) 
    {
    case Pcharset_ASCII:
      PDCI_A_STR_SET(m, s_out, begin, p1-begin);
      break;
    case Pcharset_EBCDIC:
      PDCI_E_STR_SET(m, s_out, begin, p1-begin);
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
  return P_OK;

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 not_found:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_REGEXP_NOT_FOUND);

 fatal_alloc_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "Memory alloc error", P_ALLOC_ERR);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);

 fatal_forward_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO_forward error", P_FORWARD_ERR);
}

Perror_t
PDCI_string_SE_read(P_t *pads, const Pbase_m *m,
		    Pbase_pd *pd, Pstring *s_out, Pcharset char_set,
		    const char *whatfn, const char *stopRegexp)
{
  P_REGEXP_DECL_NULL(compiled_exp);
  Perror_t    res;

  PDCI_IODISC_3P_CHECKS(whatfn, m, stopRegexp, pd);
  PDCI_READFN_PD_INIT(pads, pd);
  if (P_ERR == PDCI_regexp_compile_cstr(pads, stopRegexp, &compiled_exp, "Pstring_SE arg", whatfn)) {
    goto bad_exp;
  }
  res = PDCI_string_CSE_read(pads, m, pd, s_out, char_set, whatfn, &compiled_exp);
  PDCI_regexp_cleanup(pads, &compiled_exp, whatfn);
  return res;

 bad_exp:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  /* regexp_compile already issued a warning */
  PDCI_READFN_RET_ERRCODE_NOWARN(P_INVALID_REGEXP);
}

Perror_t
PDCI_string_CSE_read(P_t *pads, const Pbase_m *m,
		     Pbase_pd *pd, Pstring *s_out, Pcharset char_set,
		     const char *whatfn, Pregexp_t *stopRegexp)
{
  regflags_t   e_flags;
  Pbyte       *p1;
  int           bor;
  PDCI_IO_NEED_BYTES_SETUP_SCAN;
  bor = elt->bor && (bytes == elt->len);

  PDCI_IODISC_3P_CHECKS(whatfn, m, stopRegexp, pd);
  PDCI_READFN_PD_INIT(pads, pd);
  P_TRACE2(pads->disc, "PDCI_string_CSE_read called, char_set = %s, whatfn = %s",
	     Pcharset2str(char_set), whatfn);
  PDCI_IO_NEED_BYTES(goto fatal_nb_io_err);
  if (end-begin == 0 && !eor) {
    /* must be at eof, do not want to match anything (not even /$/) */
    goto not_found;
  }
  e_flags = 0; /* do not pin left when we do a terminating match */
  if (!bor) {
    e_flags |= REG_NOTBOL;
  }
  if (!eor) {
    e_flags |= REG_NOTEOL;
  }
  if (PDCI_regexp_match(pads, stopRegexp, begin, end, e_flags, char_set)) goto not_found;
  /* found, set p1 to just beyond last char to include == first char in match*/
  p1 = begin + stopRegexp->match[0].rm_so; /* if rm_so is zero then match occurred at begin */
  switch (char_set) 
    {
    case Pcharset_ASCII:
      PDCI_A_STR_SET(m, s_out, begin, p1-begin);
      break;
    case Pcharset_EBCDIC:
      PDCI_E_STR_SET(m, s_out, begin, p1-begin);
      break;
    default:
      goto invalid_charset;
    }
  PDCI_IO_FORWARD(p1-begin, goto fatal_forward_err);
  return P_OK;

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 not_found:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_PLUSK(pads, pd->loc, end-begin-1);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_REGEXP_NOT_FOUND);

 fatal_alloc_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "Memory alloc error", P_ALLOC_ERR);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);

 fatal_forward_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO_forward error", P_FORWARD_ERR);
}

#endif /* P_CONFIG_READ_FUNCTIONS */

/* ================================================================================ */
/* CHARSET INTERNAL WRITE ROUTINES */

#if P_CONFIG_WRITE_FUNCTIONS > 0

ssize_t
PDCI_char_lit_write2io(P_t *pads, Sfio_t *io, Pchar c,
		       Pcharset char_set, const char *whatfn)
{
  PDCI_DISC_1P_CHECKS_RET_SSIZE(whatfn, io);
  P_TRACE3(pads->disc, "PDCI_char_lit_write2io args: c %s, char_set = %s, whatfn = %s",
	     P_qfmt_char(c), Pcharset2str(char_set), whatfn);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      c = P_mod_ae_tab[(int)c]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  if (c != sfputc(io, c)) {
    P_WARN1(pads->disc, "%s: low-level sfputc failure", whatfn);
    return -1;
  }
  return 1;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;
}

ssize_t
PDCI_char_lit_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full, Pchar c,
			Pcharset char_set, const char *whatfn)
{
  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, buf, buf_full);
  P_TRACE3(pads->disc, "PDCI_char_lit_write2buf args: c %s, char_set = %s, whatfn = %s",
	     P_qfmt_char(c), Pcharset2str(char_set), whatfn);
  if (1 > buf_len) {
    (*buf_full) = 1;
    return -1;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      c = P_mod_ae_tab[(int)c]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  *buf = c;
  return 1;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;
}

ssize_t
PDCI_char_lit_write_xml_2io(P_t *pads, Sfio_t *io, Pchar c, const char *tag, int indent, const char *whatfn)
{
  PDCI_DISC_1P_CHECKS_RET_SSIZE(whatfn, io);
  P_TRACE2(pads->disc, "PDCI_char_lit_write_xml_2io args: c %s, whatfn = %s", P_qfmt_char(c), whatfn);
  PDCI_BASELIT_XML_OUT2IO("Pchar_lit", "%s", P_fmt_char(c));
}

ssize_t
PDCI_char_lit_write_xml_2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full, Pchar c,
			     const char *tag, int indent, const char *whatfn)
{
  ssize_t writelen;
  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, buf, buf_full);
  P_TRACE2(pads->disc, "PDCI_char_lit_write_xml_2buf args: c %s, whatfn = %s", P_qfmt_char(c), whatfn);
  PDCI_BASELIT_XML_OUT2BUF("Pchar_lit", "%s", P_fmt_char(c));
}

ssize_t
PDCI_str_lit_write2io(P_t *pads, Sfio_t *io, const Pstring *s,
		      Pcharset char_set, const char *whatfn)
{
  ssize_t         n;
  Pstring     *tmp_s = (Pstring*)s;

  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, s);
  P_TRACE3(pads->disc, "PDCI_str_lit_write2io args: s %s, char_set = %s, whatfn = %s",
	     P_qfmt_str(s), Pcharset2str(char_set), whatfn);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s->str, s->len);
      break;
    default:
      goto invalid_charset;
    }
  n = sfwrite(io, (Void_t*)tmp_s->str, tmp_s->len);
  if (n != tmp_s->len) {
    P_WARN1(pads->disc, "%s: low-level sfwrite failure", whatfn);
    if (n > 0) {
      /* XXX_TODO try to back up ??? */
    }
    return -1;
  }
  return n;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_str_lit_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full, const Pstring *s,
		       Pcharset char_set, const char *whatfn)
{
  Pstring     *tmp_s = (Pstring*)s;

  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, s);
  P_TRACE3(pads->disc, "PDCI_str_lit_write2buf args: s %s, char_set = %s, whatfn = %s",
	     P_qfmt_str(s), Pcharset2str(char_set), whatfn);
  if (tmp_s->len > buf_len) {
    (*buf_full) = 1;
    return -1;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s->str, s->len);
      break;
    default:
      goto invalid_charset;
    }
  memcpy(buf, tmp_s->str, tmp_s->len);
  return tmp_s->len;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_str_lit_write_xml_2io(P_t *pads, Sfio_t *io, const Pstring *s, const char *tag, int indent, const char *whatfn)
{
  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, s);
  P_TRACE2(pads->disc, "PDCI_str_lit_write_xml_2io args: s %s, whatfn = %s", P_qfmt_str(s), whatfn);
  PDCI_BASELIT_XML_OUT2IO("Pstr_lit", "%s", P_fmt_str(s));
}

ssize_t
PDCI_str_lit_write_xml_2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full, const Pstring *s,
			    const char *tag, int indent, const char *whatfn)
{
  ssize_t writelen;
  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, s);
  P_TRACE2(pads->disc, "PDCI_str_lit_write_xml_2buf args: s %s, whatfn = %s", P_qfmt_str(s), whatfn);
  PDCI_BASELIT_XML_OUT2BUF("Pstr_lit", "%s", P_fmt_str(s));
}

ssize_t
PDCI_cstr_lit_write2io(P_t *pads, Sfio_t *io, const char *s,
		       Pcharset char_set, const char *whatfn)
{
  ssize_t         n;
  Pstring      stack_s;
  Pstring     *tmp_s = &stack_s;

  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, s);
  P_TRACE3(pads->disc, "PDCI_cstr_lit_write2io args: s %s, char_set = %s, whatfn = %s",
	     P_qfmt_cstr(s), Pcharset2str(char_set), whatfn);
  stack_s.str = (char*)s;
  stack_s.len = strlen(s);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s, stack_s.len);
      break;
    default:
      goto invalid_charset;
    }
  n = sfwrite(io, (Void_t*)tmp_s->str, tmp_s->len);
  if (n != tmp_s->len) {
    P_WARN1(pads->disc, "%s: low-level sfwrite failure", whatfn);
    if (n > 0) {
      /* XXX_TODO try to back up ??? */
    }
    return -1;
  }
  return n;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_cstr_lit_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full, const char *s,
			Pcharset char_set, const char *whatfn)
{
  Pstring      stack_s;
  Pstring     *tmp_s = &stack_s;

  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, s);
  P_TRACE3(pads->disc, "PDCI_cstr_lit_write2buf args: s %s, char_set = %s, whatfn = %s",
	     P_qfmt_cstr(s), Pcharset2str(char_set), whatfn);
  stack_s.str = (char*)s;
  stack_s.len = strlen(s);
  if (stack_s.len > buf_len) {
    (*buf_full) = 1;
    return -1;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s, stack_s.len);
      break;
    default:
      goto invalid_charset;
    }
  memcpy(buf, tmp_s->str, tmp_s->len);
  return tmp_s->len;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_cstr_lit_write_xml_2io(P_t *pads, Sfio_t *io, const char *s, const char *tag, int indent, const char *whatfn)
{
  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, s);
  P_TRACE2(pads->disc, "PDCI_cstr_lit_write_xml_2io args: s %s, whatfn = %s", P_qfmt_cstr(s), whatfn);
  PDCI_BASELIT_XML_OUT2IO("Pcstr_lit", "%s", P_fmt_cstr(s));
}

ssize_t
PDCI_cstr_lit_write_xml_2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full, const char *s,
			     const char *tag, int indent, const char *whatfn)
{
  ssize_t writelen;
  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, s);
  P_TRACE2(pads->disc, "PDCI_cstr_lit_write_xml_2buf args: s %s, whatfn = %s", P_qfmt_cstr(s), whatfn);
  PDCI_BASELIT_XML_OUT2BUF("Pcstr_lit", "%s", P_fmt_cstr(s));
}

ssize_t
PDCI_char_write2io(P_t *pads, Sfio_t *io, Pbase_pd *pd, Pbyte *val,
		   Pcharset char_set, const char *whatfn)
{
  Pchar         c;
  Pinv_val_fn   fn;

  PDCI_DISC_1P_CHECKS_RET_SSIZE(whatfn, io);
  P_TRACE3(pads->disc, "PDCI_char_write2io args: c %s, char_set = %s, whatfn = %s",
	     P_qfmt_char(*val), Pcharset2str(char_set), whatfn);
  if (pd->errCode == P_NO_ERR) {
    c = *val;
  } else {
    fn = PDCI_GET_INV_VAL_FN(pads, "Pchar");
    if (!fn || (P_ERR == P_invoke_inv_val_fn(fn, pads, (void*)pd, (void*)&c))) {
      c = (pd->errCode == P_USER_CONSTRAINT_VIOLATION) ? *val : P_CHAR_DEF_INV_VAL;
    }
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      c = P_mod_ae_tab[(int)c]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  if (c != sfputc(io, c)) {
    P_WARN1(pads->disc, "%s: low-level sfputc failure", whatfn);
    return -1;
  }
  return 1;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;
}

ssize_t
PDCI_char_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
		    Pbase_pd *pd, Pbyte *val,
		    Pcharset char_set, const char *whatfn)
{
  Pchar         c;
  Pinv_val_fn   fn;

  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, buf, buf_full);
  P_TRACE3(pads->disc, "PDCI_char_write2buf args: c %s, char_set = %s, whatfn = %s",
	     P_qfmt_char(*val), Pcharset2str(char_set), whatfn);
  if (1 > buf_len) {
    (*buf_full) = 1;
    return -1;
  }
  if (pd->errCode == P_NO_ERR) {
    c = *val;
  } else {
    fn = PDCI_GET_INV_VAL_FN(pads, "Pchar");
    if (!fn || (P_ERR == P_invoke_inv_val_fn(fn, pads, (void*)pd, (void*)&c))) {
      c = (pd->errCode == P_USER_CONSTRAINT_VIOLATION) ? *val : P_CHAR_DEF_INV_VAL;
    }
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      c = P_mod_ae_tab[(int)c]; /* convert to EBCDIC char */
      break;
    default:
      goto invalid_charset;
    }
  *buf = c;
  return 1;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;
}

ssize_t
PDCI_char_write_xml_2io(P_t *pads, Sfio_t *io, Pbase_pd *pd, Pbyte *val,
			const char *tag, int indent, const char *whatfn)
{
  Pchar         c;
  Pinv_val_fn   fn;

  PDCI_DISC_1P_CHECKS_RET_SSIZE(whatfn, io);
  P_TRACE2(pads->disc, "PDCI_char_write_xml_2io args: c %s, whatfn = %s", P_qfmt_char(*val), whatfn);
  if (pd->errCode == P_NO_ERR) {
    c = *val;
  } else {
    fn = PDCI_GET_INV_VAL_FN(pads, "Pchar");
    if (!fn || (P_ERR == P_invoke_inv_val_fn(fn, pads, (void*)pd, (void*)&c))) {
      c = (pd->errCode == P_USER_CONSTRAINT_VIOLATION) ? *val : P_CHAR_DEF_INV_VAL;
    }
  }
  PDCI_BASEVAL_XML_OUT2IO("Pchar", "%s", P_fmt_char(c));
}

ssize_t
PDCI_char_write_xml_2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			 Pbase_pd *pd, Pbyte *val,
			 const char *tag, int indent, const char *whatfn)
{
  ssize_t       writelen;
  Pchar         c;
  Pinv_val_fn   fn;

  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, buf, buf_full);
  P_TRACE2(pads->disc, "PDCI_char_write_xml_2buf args: c %s, whatfn = %s", P_qfmt_char(*val), whatfn);
  if (pd->errCode == P_NO_ERR) {
    c = *val;
  } else {
    fn = PDCI_GET_INV_VAL_FN(pads, "Pchar");
    if (!fn || (P_ERR == P_invoke_inv_val_fn(fn, pads, (void*)pd, (void*)&c))) {
      c = (pd->errCode == P_USER_CONSTRAINT_VIOLATION) ? *val : P_CHAR_DEF_INV_VAL;
    }
  }
  PDCI_BASEVAL_XML_OUT2BUF("Pchar", "%s", P_fmt_char(c));
}

ssize_t
PDCI_string_FW_write2io(P_t *pads, Sfio_t *io,
			Pbase_pd *pd, Pstring *s,
			Pcharset char_set, const char *whatfn, size_t width)
{
  ssize_t       n;
  Pstring      *tmp_s = (Pstring*)s;
  Pinv_val_fn   fn;

  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, s);
  P_TRACE3(pads->disc, "PDCI_string_FW_write2io args: s %s, char_set = %s, whatfn = %s",
	     P_qfmt_str(s), Pcharset2str(char_set), whatfn);

  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, "Pstring_FW");
    if (!fn || (P_ERR == P_invoke_inv_val_fn(fn, pads, (void*)pd, (void*)s, width))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	PDCI_STRFILL(s, P_CHAR_DEF_INV_VAL, width);
      }
    }
  }
  if (s->len != width) {
    goto invalid_width;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s->str, s->len);
      break;
    default:
      goto invalid_charset;
    }
  n = sfwrite(io, (Void_t*)tmp_s->str, tmp_s->len);
  if (n != tmp_s->len) {
    P_WARN1(pads->disc, "%s: low-level sfwrite failure", whatfn);
    if (n > 0) {
      /* XXX_TODO try to back up ??? */
    }
    return -1;
  }
  return n;

 invalid_width:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_WIDTH, whatfn, 0);
  return -1;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_string_FW_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			 Pbase_pd *pd, Pstring *s,
			 Pcharset char_set, const char *whatfn, size_t width)
{
  Pstring      *tmp_s = (Pstring*)s;
  Pinv_val_fn   fn;

  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, s);
  P_TRACE3(pads->disc, "PDCI_string_FW_write2buf args: s %s, char_set = %s, whatfn = %s",
	     P_qfmt_str(s), Pcharset2str(char_set), whatfn);

  if (width > buf_len) {
    (*buf_full) = 1;
    return -1;
  }
  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, "Pstring_FW");
    if (!fn || (P_ERR == P_invoke_inv_val_fn(fn, pads, (void*)pd, (void*)s, width))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	PDCI_STRFILL(s, P_CHAR_DEF_INV_VAL, width);
      }
    }
  }
  if (s->len != width) {
    goto invalid_width;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s->str, s->len);
      break;
    default:
      goto invalid_charset;
    }
  memcpy(buf, tmp_s->str, tmp_s->len);
  return tmp_s->len;

 invalid_width:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_WIDTH, whatfn, 0);
  return -1;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_string_FW_write_xml_2io(P_t *pads, Sfio_t *io,
			     Pbase_pd *pd, Pstring *s,
			     const char *tag, int indent, const char *whatfn, size_t width)
{
  Pinv_val_fn   fn;

  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, s);
  P_TRACE2(pads->disc, "PDCI_string_FW_write_xml_2io args: s %s, whatfn = %s", P_qfmt_str(s), whatfn);

  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, "Pstring_FW");
    if (!fn || (P_ERR == P_invoke_inv_val_fn(fn, pads, (void*)pd, (void*)s, width))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	PDCI_STRFILL(s, P_CHAR_DEF_INV_VAL, width);
      }
    }
  }
  if (s->len != width) {
    goto invalid_width;
  }
  PDCI_BASEVAL_XML_OUT2IO("Pstring_FW", "%s", P_fmt_str(s));

 invalid_width:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_WIDTH, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_string_FW_write_xml_2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			      Pbase_pd *pd, Pstring *s,
			      const char *tag, int indent, const char *whatfn, size_t width)
{
  ssize_t       writelen;
  Pinv_val_fn   fn;

  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, s);
  P_TRACE2(pads->disc, "PDCI_string_FW_write_xml_2buf args: s %s, whatfn = %s", P_qfmt_str(s), whatfn);

  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, "Pstring_FW");
    if (!fn || (P_ERR == P_invoke_inv_val_fn(fn, pads, (void*)pd, (void*)s, width))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	PDCI_STRFILL(s, P_CHAR_DEF_INV_VAL, width);
      }
    }
  }
  if (s->len != width) {
    goto invalid_width;
  }
  PDCI_BASEVAL_XML_OUT2BUF("Pstring_FW", "%s", P_fmt_str(s));

 invalid_width:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_WIDTH, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_string_write2io(P_t *pads, Sfio_t *io, Pbase_pd *pd, Pstring *s,
		     Pcharset char_set, const char *inv_type, const char *whatfn, ...)
{
  ssize_t       n;
  Pstring      *tmp_s = (Pstring*)s;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, s);
  P_TRACE3(pads->disc, "PDCI_string_write2io args: s %s, char_set = %s, whatfn = %s",
	     P_qfmt_str(s), Pcharset2str(char_set), whatfn);
  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, whatfn);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)s, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	s->len = 0;
      }
    }
    va_end(type_args);
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s->str, s->len);
      break;
    default:
      goto invalid_charset;
    }
  n = sfwrite(io, (Void_t*)tmp_s->str, tmp_s->len);
  if (n != tmp_s->len) {
    P_WARN1(pads->disc, "%s: low-level sfwrite failure", whatfn);
    if (n > 0) {
      /* XXX_TODO try to back up ??? */
    }
    return -1;
  }
  return n;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_string_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
		      Pbase_pd *pd, Pstring *s,
		      Pcharset char_set, const char *inv_type, const char *whatfn, ...)
{
  Pstring      *tmp_s = (Pstring*)s;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, s);
  P_TRACE3(pads->disc, "PDCI_string_write2buf args: s %s, char_set = %s, whatfn = %s",
	     P_qfmt_str(s), Pcharset2str(char_set), whatfn);
  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, whatfn);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)s, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	s->len = 0;
      }
    }
    va_end(type_args);
  }
  if (tmp_s->len > buf_len) {
    (*buf_full) = 1;
    return -1;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s->str, s->len);
      break;
    default:
      goto invalid_charset;
    }
  memcpy(buf, tmp_s->str, tmp_s->len);
  return tmp_s->len;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_string_write_xml_2io(P_t *pads, Sfio_t *io, Pbase_pd *pd, Pstring *s,
			  const char *tag, int indent, const char *inv_type, const char *whatfn, ...)
{
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, s);
  P_TRACE2(pads->disc, "PDCI_string_write_xml_2io args: s %s, whatfn = %s", P_qfmt_str(s), whatfn);
  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, whatfn);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)s, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	s->len = 0;
      }
    }
    va_end(type_args);
  }
  PDCI_BASEVAL_XML_OUT2IO(inv_type, "%s", P_fmt_str(s));
}

ssize_t
PDCI_string_write_xml_2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			   Pbase_pd *pd, Pstring *s,
			   const char *tag, int indent, const char *inv_type, const char *whatfn, ...)
{
  ssize_t       writelen;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, s);
  P_TRACE2(pads->disc, "PDCI_string_write_xml_2buf args: s %s, whatfn = %s", P_qfmt_str(s), whatfn);
  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, whatfn);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)s, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	s->len = 0;
      }
    }
    va_end(type_args);
  }
  PDCI_BASEVAL_XML_OUT2BUF(inv_type, "%s", P_fmt_str(s));
}

ssize_t
PDCI_date_time_FW_write2io(P_t *pads,
			   Sfio_t *io,
			   Pbase_pd *pd,
			   Puint32 *d,
			   Pcharset char_set,
			   const char *inv_type,
			   const char *whatfn,
			   const char *format_descr,
			   const char *tzone_descr,
			   const char *format,
			   Tm_zone_t *tzone,
			   size_t width,
			   ...)
{
  ssize_t       n;
  Pstring       s;
  Pstring      *tmp_s = &s;
  Pbyte         space;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, d);
  P_TRACE4(pads->disc, "PDCI_date_time_FW_write2io args: char_set = %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);

  tmset(tzone);

  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, width);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)d, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	(*d) = 0;
      }
    }
    va_end(type_args);
  }
  s.str = fmttime(format, (time_t)(*d));
  s.len = strlen(s.str);
#if 0
  /* XXX_TODO: output format can differ from input format, so we cannot check if */
  /* output width is equal to input width, unless (1) the input and output formats are identical */
  /* and (2) the input format has no alternations.  At the moment, however, we are */
  /* not passed the input format, so we cannot do any check at all */
  if (tmp_s->len > width) { /* format does not fit in width, give up */
    PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_WIDTH, whatfn, 0);
    return -1;
  }
#endif
  switch (char_set)
    {
    case Pcharset_ASCII:
      space = P_ASCII_SPACE;
      break;
    case Pcharset_EBCDIC:
      space = P_EBCDIC_SPACE;
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s.str, s.len);
      break;
    default:
      goto invalid_charset;
    }
  n = sfwrite(io, (Void_t*)tmp_s->str, tmp_s->len);
  if (n != tmp_s->len) {
    P_WARN1(pads->disc, "%s: low-level sfwrite failure", whatfn);
    if (n > 0) {
      /* XXX_TODO try to back up ??? */
    }
    return -1;
  }
#if 0
  /* if format does not fill the FW, add spaces. */
  /* does not make sense to do this since the out format may have nothing to do with the FW */
  while (n < width) {
    if (-1 == sfputc(io, space)) {
      P_WARN1(pads->disc, "%s: low-level sfputc failure", whatfn);
      if (n > 0) {
	/* XXX_TODO try to back up ??? */
      }
      return -1;
    }
    n++;
  }
#endif
  return n;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_date_time_FW_write2buf(P_t *pads,
			    Pbyte *buf,
			    size_t buf_len,
			    int *buf_full,
			    Pbase_pd *pd,
			    Puint32 *d,
			    Pcharset char_set,
			    const char *inv_type,
			    const char *whatfn,
			    const char *format_descr,
			    const char *tzone_descr,
			    const char *format,
			    Tm_zone_t *tzone,
			    size_t width,
			    ...)
{
  Pstring       s;
  Pstring      *tmp_s = &s;
  Pbyte         space;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, d);
  P_TRACE4(pads->disc, "PDCI_date_time_FW_write2buf args: char_set = %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);

  tmset(tzone);

  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, width);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)d, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	(*d) = 0;
      }
    }
    va_end(type_args);
  }
  s.str = fmttime(format, (time_t)(*d));
  s.len = strlen(s.str);
#if 0
  /* XXX_TODO: output format can differ from input format, so we cannot check if */
  /* output width is equal to input width, unless (1) the input and output formats are identical */
  /* and (2) the input format has no alternations.  At the moment, however, we are */
  /* not passed the input format, so we cannot do any check at all */
  if (tmp_s->len > width) { /* format does not fit in width, give up */
    PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_WIDTH, whatfn, 0);
    return -1;
  }
#endif
  if (tmp_s->len > buf_len) {
    (*buf_full) = 1;
    return -1;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      space = P_ASCII_SPACE;
      break;
    case Pcharset_EBCDIC:
      space = P_EBCDIC_SPACE;
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s.str, s.len);
      break;
    default:
      goto invalid_charset;
    }
  memcpy(buf, tmp_s->str, tmp_s->len);
#if 0
  {
    Pbyte *buf2, *buf_end;
    /* if format does not fill the FW, add spaces. */
    /* does not make sense to do this since the out format may have nothing to do with the FW */
    buf2 = buf + tmp_s->len;
    buf_end = buf + width;
    while (buf2 < buf_end) {
      *buf2++ = space;
    }
  }
#endif
  return tmp_s->len;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_date_time_write2io(P_t *pads,
			Sfio_t *io,
			Pbase_pd *pd,
			Puint32 *d,
			Pcharset char_set,
			const char *inv_type,
			const char *whatfn,
			const char *format_descr,
			const char *tzone_descr,
			const char *format,
			Tm_zone_t *tzone,
			...)
{
  ssize_t       n;
  Pstring       s;
  Pstring      *tmp_s = &s;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, d);
  P_TRACE4(pads->disc, "PDCI_date_time_write2io args: char_set = %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);

  tmset(tzone);

  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, tzone);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)d, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	(*d) = 0;
      }
    }
    va_end(type_args);
  }
  s.str = fmttime(format, (time_t)(*d));
  s.len = strlen(s.str);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s.str, s.len);
      break;
    default:
      goto invalid_charset;
    }
  n = sfwrite(io, (Void_t*)tmp_s->str, tmp_s->len);
  if (n != tmp_s->len) {
    P_WARN1(pads->disc, "%s: low-level sfwrite failure", whatfn);
    if (n > 0) {
      /* XXX_TODO try to back up ??? */
    }
    return -1;
  }
  return n;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_date_time_write2buf(P_t *pads,
			 Pbyte *buf,
			 size_t buf_len,
			 int *buf_full,
			 Pbase_pd *pd,
			 Puint32 *d,
			 Pcharset char_set,
			 const char *inv_type,
			 const char *whatfn,
			 const char *format_descr,
			 const char *tzone_descr,
			 const char *format,
			 Tm_zone_t *tzone,
			 ...)
{
  Pstring       s;
  Pstring      *tmp_s = &s;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, d);
  P_TRACE4(pads->disc, "PDCI_date_time_write2buf args: char_set = %s, whatfn = %s, format = %s, tzone = %s",
	   Pcharset2str(char_set), whatfn, format, tzone_descr);

  tmset(tzone);

  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, tzone);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)d, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	(*d) = 0;
      }
    }
    va_end(type_args);
  }
  s.str = fmttime(format, (time_t)(*d));
  s.len = strlen(s.str);
  if (tmp_s->len > buf_len) {
    (*buf_full) = 1;
    return -1;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s.str, s.len);
      break;
    default:
      goto invalid_charset;
    }
  memcpy(buf, tmp_s->str, tmp_s->len);
  return tmp_s->len;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_date_time_write_xml_2io(P_t *pads,
			     Sfio_t *io,
			     Pbase_pd *pd,
			     Puint32 *d,
			     const char *tag,
			     int indent,
			     const char *inv_type,
			     const char *whatfn,
			     const char *format_descr,
			     const char *tzone_descr,
			     const char *format,
			     Tm_zone_t *tzone,
			     ...)
{
  Pstring       s;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, d);
  P_TRACE3(pads->disc, "PDCI_date_time_write2io args: whatfn = %s, format = %s, tzone = %s",
	   whatfn, format, tzone_descr);

  tmset(tzone);

  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, tzone);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)d, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	(*d) = 0;
      }
    }
    va_end(type_args);
  }
  s.str = fmttime(format, (time_t)(*d));
  s.len = strlen(s.str);
  PDCI_BASEVAL_XML_OUT2IO(inv_type, "%s", P_fmt_str(&s));
}

ssize_t
PDCI_date_time_write_xml_2buf(P_t *pads,
			      Pbyte *buf,
			      size_t buf_len,
			      int *buf_full,
			      Pbase_pd *pd,
			      Puint32 *d,
			      const char *tag,
			      int indent,
			      const char *inv_type,
			      const char *whatfn,
			      const char *format_descr,
			      const char *tzone_descr,
			      const char *format,
			      Tm_zone_t *tzone,
			      ...)
{
  ssize_t       writelen;
  Pstring       s;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_ARG_OR_DISC_ELT_CHECK(format, format_descr, whatfn);
  PDCI_ARG_OR_DISC_ELT_CHECK(tzone, tzone_descr, whatfn);
  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, d);
  P_TRACE3(pads->disc, "PDCI_date_time_write_xml_2buf args: whatfn = %s, format = %s, tzone = %s",
	   whatfn, format, tzone_descr);

  tmset(tzone);

  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, tzone);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)d, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	(*d) = 0;
      }
    }
    va_end(type_args);
  }
  s.str = fmttime(format, (time_t)(*d));
  s.len = strlen(s.str);
  PDCI_BASEVAL_XML_OUT2BUF(inv_type, "%s", P_fmt_str(&s));
}

ssize_t
PDCI_ip_write2io(P_t *pads, Sfio_t *io, Pbase_pd *pd, Puint32 *d,
		 Pcharset char_set, const char *inv_type, const char *whatfn, ...)
{
  ssize_t       n;
  Pstring       s;
  Pstring      *tmp_s = &s;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, d);
  P_TRACE2(pads->disc, "PDCI_ip_write2io args: char_set = %s, whatfn = %s",
	   Pcharset2str(char_set), whatfn);
  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, whatfn);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)d, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	(*d) = 0;
      }
    }
    va_end(type_args);
  }
  s.str = fmtip4((*d), -1);
  s.len = strlen(s.str);
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s.str, s.len);
      break;
    default:
      goto invalid_charset;
    }
  n = sfwrite(io, (Void_t*)tmp_s->str, tmp_s->len);
  if (n != tmp_s->len) {
    P_WARN1(pads->disc, "%s: low-level sfwrite failure", whatfn);
    if (n > 0) {
      /* XXX_TODO try to back up ??? */
    }
    return -1;
  }
  return n;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_ip_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
		  Pbase_pd *pd, Puint32 *d,
		  Pcharset char_set, const char *inv_type, const char *whatfn, ...)
{
  Pstring       s;
  Pstring      *tmp_s = &s;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, d);
  P_TRACE2(pads->disc, "PDCI_ip_write2buf args: char_set = %s, whatfn = %s",
	     Pcharset2str(char_set), whatfn);
  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, whatfn);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)d, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	(*d) = 0;
      }
    }
    va_end(type_args);
  }
  s.str = fmtip4((*d), -1);
  s.len = strlen(s.str);
  if (tmp_s->len > buf_len) {
    (*buf_full) = 1;
    return -1;
  }
  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      tmp_s = &pads->stmp1;
      PDCI_A2E_STR_CPY(tmp_s, s.str, s.len);
      break;
    default:
      goto invalid_charset;
    }
  memcpy(buf, tmp_s->str, tmp_s->len);
  return tmp_s->len;

 invalid_charset:
  PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_CHARSET, whatfn, 0);
  return -1;

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, whatfn, "Memory alloc error");
  return -1;
}

ssize_t
PDCI_ip_write_xml_2io(P_t *pads, Sfio_t *io, Pbase_pd *pd, Puint32 *d,
		      const char *tag, int indent, const char *inv_type, const char *whatfn, ...)
{
  Pstring       s;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_DISC_2P_CHECKS_RET_SSIZE(whatfn, io, d);
  P_TRACE1(pads->disc, "PDCI_ip_write2io args: whatfn = %s", whatfn);
  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, whatfn);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)d, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	(*d) = 0;
      }
    }
    va_end(type_args);
  }
  s.str = fmtip4((*d), -1);
  s.len = strlen(s.str);
  PDCI_BASEVAL_XML_OUT2IO(inv_type, "%s", P_fmt_str(&s));
}

ssize_t
PDCI_ip_write_xml_2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
		       Pbase_pd *pd, Puint32 *d,
		       const char *tag, int indent, const char *inv_type, const char *whatfn, ...)
{
  ssize_t       writelen;
  Pstring       s;
  Pinv_val_fn   fn;
  va_list       type_args;

  PDCI_DISC_3P_CHECKS_RET_SSIZE(whatfn, buf, buf_full, d);
  P_TRACE1(pads->disc, "PDCI_ip_write_xml_2buf args: whatfn = %s", whatfn);
  if (pd->errCode != P_NO_ERR) {
    fn = PDCI_GET_INV_VAL_FN(pads, inv_type);
    va_start(type_args, whatfn);
    if (!fn || (P_ERR == fn(pads, (void*)pd, (void*)d, type_args))) {
      if (pd->errCode != P_USER_CONSTRAINT_VIOLATION) {
	(*d) = 0;
      }
    }
    va_end(type_args);
  }
  s.str = fmtip4((*d), -1);
  s.len = strlen(s.str);
  PDCI_BASEVAL_XML_OUT2BUF(inv_type, "%s", P_fmt_str(&s));
}

/* MISC WRITE FUNCTIONS */

ssize_t
PDCI_countX_write2io(P_t *pads, Sfio_t *io,
		     Pbase_pd *pd, Pint32  *val, Pcharset char_set, const char *whatfn,
		     Puint8 x, int eor_required, size_t count_max)
{
  return 0;
}

ssize_t
PDCI_countX_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
		      Pbase_pd *pd, Pint32  *val, Pcharset char_set, const char *whatfn,
		      Puint8 x, int eor_required, size_t count_max)
{
  return 0;
}

ssize_t
PDCI_countXtoY_write2io(P_t *pads, Sfio_t *io,
			Pbase_pd *pd, Pint32  *val, Pcharset char_set, const char *whatfn,
			Puint8 x, Puint8 y, size_t count_max)
{
  return 0;
}

ssize_t
PDCI_countXtoY_write2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			 Pbase_pd *pd, Pint32  *val, Pcharset char_set, const char *whatfn,
			 Puint8 x, Puint8 y, size_t count_max)
{
  return 0;

}

ssize_t
PDCI_countX_write_xml_2io(P_t *pads, Sfio_t *io,
			  Pbase_pd *pd, Pint32  *val, const char *tag, int indent,
			  const char *whatfn,
			  Puint8 x, int eor_required, size_t count_max)
{
  return 0;
}

ssize_t
PDCI_countX_write_xml_2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			   Pbase_pd *pd, Pint32  *val, const char *tag, int indent,
			   const char *whatfn,
			   Puint8 x, int eor_required, size_t count_max)
{
  return 0;
}

ssize_t
PDCI_countXtoY_write_xml_2io(P_t *pads, Sfio_t *io,
			     Pbase_pd *pd, Pint32  *val, const char *tag, int indent,
			     const char *whatfn,
			     Puint8 x, Puint8 y, size_t count_max)
{
  return 0;
}

ssize_t
PDCI_countXtoY_write_xml_2buf(P_t *pads, Pbyte *buf, size_t buf_len, int *buf_full,
			      Pbase_pd *pd, Pint32  *val, const char *tag, int indent,
			      const char *whatfn,
			      Puint8 x, Puint8 y, size_t count_max)
{
  return 0;

}
#endif /* P_CONFIG_WRITE_FUNCTIONS */

/* ================================================================================ */
/* INTERNAL MISC ROUTINES */

#if defined(__GNUC__) && (__GNUC__ == 4)
/*
 * sfstruse and sfstrseek both use '?' conditional exprs that can
 * return NULL.  The newest gcc does not like such exprs appearing in
 * argument positions that expect const void*, even if casting is
 * used.  As a workaround, we provide the following wrappers.
 */ 
char* PDCI_sfstr_use(Sfio_t* io) {
  return sfstruse(io);
}

char* PDCI_sfstr_seek2zero(Sfio_t* f) {
  return sfstrseek(f, 0, SEEK_SET);
}
#endif

Perror_t
PDCI_regexp_compile_cstr(P_t *pads, const char *regexp_str, Pregexp_t *regexp,
			 const char *err_prefix, const char *whatfn)
{
  regflags_t    c_flags;
  size_t        len;
  char          delim;
  const char   *end, *rdelim, *regexp_end;
  int           cret;

  PDCI_DISC_2P_CHECKS(whatfn, regexp_str, regexp);
  if (regexp->valid) { /* cleanup before installing a new compiled regexp */
    regfree(&(regexp->preg));
    regexp->valid = 0;
  }
  len = strlen(regexp_str);
  regexp_end = regexp_str + len - 1;
  if (len < 3) {
    PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_REGEXP, whatfn,
		    "%s regular expression %s: expr of length %d cannot be a valid regexp",
		    err_prefix, P_qfmt_cstr_n(regexp_str, len), (int)len);
    goto any_err;
  }
  delim = regexp_str[0];
  if (delim == regexp_str[1]) {
    PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_REGEXP, whatfn,
		    "%s regular expression %s: invalid (empty pattern)",
		    err_prefix, P_qfmt_cstr_n(regexp_str, len));
    goto any_err;
  }
  for (rdelim = regexp_end; *rdelim != delim; rdelim--);
  if (rdelim == regexp_str) {
    PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_REGEXP, whatfn,
		    "%s regular expression %s: beginning delimiter %s has no ending %s",
		    err_prefix, P_qfmt_cstr_n(regexp_str, len), P_qfmt_char(delim), P_qfmt_char(delim));
    goto any_err;
  }
  /* initalize c_flags */
  cret = 0;
  c_flags = (REG_AUGMENTED|REG_EXTENDED|REG_DELIMITED|REG_MUSTDELIM|REG_LENIENT|REG_ESCAPE|REG_SPAN|REG_MULTIREF);
  for (end = regexp_end; end > rdelim; end--) {
    if (*end == 'i') {
      /*
       * Do case-insensitive pattern matching.
       */
      c_flags |= REG_ICASE;
      continue;
    }
#if 0
    /* need to work out the right semantics for this */
    if (*end == 'm') {
      /* 
       * Treat a record (or data region for discipline norec) containing
       * newlines as a set of records for the purposes of
       * matching "^" and "$".  That is, use newlines (as well as record boundaries)
       * as the boundaries delimited start ("^") or ("$") points.
       * Further, allow matching anywhere in the record scope (for record-based
       * discipline) or up to the first newline (for non-record-based discipline).
       * [XXX scope for norec case not implemented!]
       */
      c_flags |= REG_NEWLINE;
      continue;
    }
#endif
#if 0
    /* on by default since newlines not the same thing as records */
    if (*end == 's') {
      /*
       * Treat string as single line.  That is, change "." to
       * match any character whatsoever, even a newline, which
       * normally it would not match.
       */
      c_flags |= REG_SPAN;
      continue;
    }
#endif
    if (*end == 'x') {
      /*
       * Extend your pattern's legibility by permitting whitespace
       * and comments.
       *
       * Tells the regular expression parser to ignore whitespace that
       * is neither backslashed nor within a character class You can
       * use this to break up your regular expression into (slightly)
       * more readable parts.  The "#" character is also treated as a
       * metacharacter introducing a comment.  This also means that if
       * you want real whitespace or "#" characters in the pattern
       * (outside a character class, where they are unaffected by
       * "/x"), you'll either have to escape them or encode them using
       * octal or hex escapes.  Be careful not to include the pattern
       * delimiter in the comment -- there is no way of knowing you
       * did not intend to close the pattern early. 
       */
      c_flags |= REG_COMMENT;
      continue;
    }
    if (*end == 'f') {
      /*
       * First match found will do. 
       */
      c_flags |= REG_FIRST;
      continue;
    }
    if (*end == '?') {
      /*
       * Minimal match.
       */
      c_flags |= REG_MINIMAL;
      continue;
    }
    if (*end == 'l') {
      /*
       * No operators (treat entire regexp as a literal).
       */
      c_flags |= REG_LITERAL;
      continue;
    }
    PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_REGEXP, whatfn,
		    "%s regular expression %s: bad pattern modifier char: %s",
		    err_prefix, P_qfmt_cstr_n(regexp_str, len), P_qfmt_char(*end));
    cret = 1;
  }
  if (cret) goto any_err;
  cret = regcomp(&(regexp->preg), regexp_str, c_flags);
  if (cret) {
    PDCI_report_err(pads, P_WARN_FLAGS, 0, P_INVALID_REGEXP, whatfn,
		    "%s regular expression %s: invalid",
		    err_prefix, P_qfmt_cstr_n(regexp_str, len));
    goto any_err;
  }
  regexp->valid = 1;
  return P_OK;

 any_err:
  regexp->valid = 0;
  return P_ERR;
}

/* XXX_FIX change this when gsf provides a regncomp */
Perror_t
PDCI_regexp_compile(P_t *pads, const Pstring *regexp_str, Pregexp_t *regexp,
		    const char *err_prefix, const char *whatfn)
{
  PDCI_DISC_2P_CHECKS(whatfn, regexp_str, regexp);
  PDCI_sfstr_seek2zero((pads)->tmp2);
  sfprintf((pads)->tmp2, "%.*s", regexp_str->len, regexp_str->str);
  return PDCI_regexp_compile_cstr(pads, PDCI_sfstr_use(pads->tmp2), regexp, err_prefix, whatfn);
}

Perror_t
PDCI_regexp_cleanup(P_t *pads, Pregexp_t *regexp, const char *whatfn)
{
  PDCI_DISC_1P_CHECKS(whatfn, regexp);
  if (regexp->valid) {
    regfree(&(regexp->preg));
    regexp->valid = 0;
  }
  return P_OK;
}

int
PDCI_regexp_match(P_t *pads, Pregexp_t *regexp, Pbyte *begin, Pbyte *end,
		  regflags_t e_flags, Pcharset char_set)
{
  const char  *tmp_match_str = (const char*)begin;
  Pstring     *tmp;

  switch (char_set)
    {
    case Pcharset_ASCII:
      break;
    case Pcharset_EBCDIC:
      /* alloc the ASCII-converted chars in a temporary space */
      tmp = &pads->stmp1;
      PDCI_E2A_STR_CPY(tmp, begin, end-begin);
      tmp_match_str = tmp->str;
      break;
    default:
      /* should not get here, calling function should already have vetted char_set */
      return 0;
    }

  /* execute the compiled re against match_str.str */
#ifdef DEBUG_REGEX
  return regnexec(&(regexp->preg), tmp_match_str, end-begin, regexp->preg.re_nsub+1, regexp->match, e_flags);
#else
  return regnexec(&(regexp->preg), tmp_match_str, end-begin, 1, regexp->match, e_flags);
#endif

 fatal_alloc_err:
  PDCI_report_err(pads, P_FATAL_FLAGS, 0, P_ALLOC_ERR, "PDCI_regexp_match", "Memory alloc error");
  return 0;
}

Pbyte*
PDCI_findfirst(const Pbyte *begin, const Pbyte *end, Pbyte b)
{
  begin--;
  while (++begin < end) {
    if (*begin == b) return (Pbyte*)begin;
  }
  return 0;
}

Pbyte*
PDCI_findlast(const Pbyte *begin, const Pbyte *end, Pbyte b)
{
  while (--end >= begin) {
    if (*end == b) return (Pbyte*)end;
  }
  return 0;
}

int
PDCI_Plongest_chkErr(Puint32 nerr, int *consume)
{
  if (nerr) {
    *consume = 0;
    return 1;
  }
  return 0;
}

/* ================================================================================ */
