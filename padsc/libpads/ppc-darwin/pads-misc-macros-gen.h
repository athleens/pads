#ifdef _USE_PROTO
#pragma prototyped
#endif
/*
 * WARNING: GENERATED FILE.  Do not edit this file, edit /Users/kfisher/pads/padsc/libpads/pads.c instead. 
 */

#ifndef __PADS_MISC_MACROS_GEN_H__
#define __PADS_MISC_MACROS_GEN_H__

/*
 * Macros that help implement accum functions
 * 
 * Kathleen Fisher, Robert Gruber
 * AT&T Labs Research
 */

#include "pads-config.h"

#define PDCI_A2INT_GEN(fn_name, targ_type, int_min, int_max, Pstring2int_fn) \
targ_type \
fn_name(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  int digit; \
  int  neg = 0, range_err = 0; \
  targ_type res = 0; \
 \
  while (PDCI_is_a_space(*bytes)) { \
    bytes++; \
  } \
  if (*bytes == '+') { \
    bytes++; \
  } else if (*bytes == '-') { \
    bytes++; \
    neg = 1; \
  } \
  if (!PDCI_is_a_digit(*bytes)) { \
    (*ptr_out) = (Pbyte*)bytes; \
    errno = EINVAL; \
    return 0; \
  } \
  while ((digit = PDCI_ascii_digit[*bytes]) != -1) { \
    if (res < int_min ## _DIV10) { \
      range_err = 1; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    if (res < int_min + digit) { \
      range_err = 1; \
    } \
    res -= digit; \
    bytes++; \
  } \
  (*ptr_out) = (Pbyte*)bytes; \
  if (range_err) { \
    errno = ERANGE; \
    return neg ? int_min : int_max; \
  } \
  errno = 0; \
  return neg ? res : - res; \
} \
 \
targ_type \
fn_name ## _max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) \
{ \
  int digit; \
  int  neg = 0, range_err = 0; \
  targ_type res = 0; \
 \
  while (max_bytes > 0 && PDCI_is_a_space(*bytes)) { \
    bytes++; \
    max_bytes--; \
  } \
  if (max_bytes == 0) { \
    errno = EINVAL; \
    return 0; \
  } \
  if (*bytes == '+') { \
    bytes++; \
    max_bytes--; \
  } else if (*bytes == '-') { \
    bytes++; \
    max_bytes--; \
    neg = 1; \
  } \
  if (max_bytes == 0) { \
    errno = EINVAL; \
    return 0; \
  } \
  if (!PDCI_is_a_digit(*bytes)) { \
    (*ptr_out) = (Pbyte*)bytes; \
    errno = EINVAL; \
    return 0; \
  } \
  while (max_bytes > 0 && ((digit = PDCI_ascii_digit[*bytes]) != -1)) { \
    if (res < int_min ## _DIV10) { \
      range_err = 1; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    if (res < int_min + digit) { \
      range_err = 1; \
    } \
    res -= digit; \
    bytes++; \
    max_bytes--; \
  } \
  (*ptr_out) = (Pbyte*)bytes; \
  if (range_err) { \
    errno = ERANGE; \
    return neg ? int_min : int_max; \
  } \
  errno = 0; \
  return neg ? res : - res; \
} \
 \
targ_type \
Pstring2int_fn(const Pstring *s) \
{ \
  Pbyte *bytes, *ptr; \
  size_t max_bytes; \
  targ_type res; \
 \
  if (!s) { \
    errno = EINVAL; \
    return 0; \
  } \
  ptr = bytes = (Pbyte*)s->str; \
  max_bytes = s->len; \
  res = fn_name ## _max_bytes(bytes, max_bytes, &ptr); \
  if (errno) return res; \
  while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) { \
    ptr++; \
  } \
  if (ptr - bytes != max_bytes) { \
    errno = EINVAL; \
    return 0; \
  } \
  return res; \
} \
 \
targ_type \
fn_name ## _norange(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  int digit; \
  int  neg = 0; \
  targ_type res = 0; \
 \
  while (PDCI_is_a_space(*bytes)) { \
    bytes++; \
  } \
  if (*bytes == '+') { \
    bytes++; \
  } else if (*bytes == '-') { \
    bytes++; \
    neg = 1; \
  } \
  if (!PDCI_is_a_digit(*bytes)) { \
    (*ptr_out) = (Pbyte*)bytes; \
    errno = EINVAL; \
    return 0; \
  } \
  while ((digit = PDCI_ascii_digit[*bytes]) != -1) { \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    res -= digit; \
    bytes++; \
  } \
  (*ptr_out) = (Pbyte*)bytes; \
  errno = 0; \
  return neg ? res : - res; \
} \

#define PDCI_A2UINT_GEN(fn_name, targ_type, int_max, Pstring2int_fn) \
targ_type \
fn_name(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  int digit; \
  int  range_err = 0; \
  targ_type res = 0; \
 \
  while (PDCI_is_a_space(*bytes)) { \
    bytes++; \
  } \
  if (*bytes == '+') { \
    bytes++; \
  } else if (*bytes == '-') { \
    bytes++; \
    range_err = 1; \
  } \
  if (!PDCI_is_a_digit(*bytes)) { \
    (*ptr_out) = (Pbyte*)bytes; \
    errno = EINVAL; \
    return 0; \
  } \
  while ((digit = PDCI_ascii_digit[*bytes]) != -1) { \
    if (res > int_max ## _DIV10) { \
      range_err = 1; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    if (res > int_max - digit) { \
      range_err = 1; \
    } \
    res += digit; \
    bytes++; \
  } \
  (*ptr_out) = (Pbyte*)bytes; \
  if (range_err) { \
    errno = ERANGE; \
    return int_max; \
  } \
  errno = 0; \
  return res; \
} \
 \
targ_type \
fn_name ## _max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) \
{ \
  int digit; \
  int  range_err = 0; \
  targ_type res = 0; \
 \
  while (max_bytes > 0 && PDCI_is_a_space(*bytes)) { \
    bytes++; \
    max_bytes--; \
  } \
  if (max_bytes == 0) { \
    errno = EINVAL; \
    return 0; \
  } \
  if (*bytes == '+') { \
    bytes++; \
    max_bytes--; \
  } else if (*bytes == '-') { \
    bytes++; \
    max_bytes--; \
    range_err = 1; \
  } \
  if (max_bytes == 0) { \
    errno = EINVAL; \
    return 0; \
  } \
  if (!PDCI_is_a_digit(*bytes)) { \
    (*ptr_out) = (Pbyte*)bytes; \
    errno = EINVAL; \
    return 0; \
  } \
  while (max_bytes > 0 && ((digit = PDCI_ascii_digit[*bytes]) != -1)) { \
    if (res > int_max ## _DIV10) { \
      range_err = 1; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    if (res > int_max - digit) { \
      range_err = 1; \
    } \
    res += digit; \
    bytes++; \
    max_bytes--; \
  } \
  (*ptr_out) = (Pbyte*)bytes; \
  if (range_err) { \
    errno = ERANGE; \
    return int_max; \
  } \
  errno = 0; \
  return res; \
} \
 \
targ_type \
Pstring2int_fn(const Pstring *s) \
{ \
  Pbyte *bytes, *ptr; \
  size_t max_bytes; \
  targ_type res; \
 \
  if (!s) { \
    errno = EINVAL; \
    return 0; \
  } \
  ptr = bytes = (Pbyte*)s->str; \
  max_bytes = s->len; \
  res = fn_name ## _max_bytes(bytes, max_bytes, &ptr); \
  if (errno) return res; \
  while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) { \
    ptr++; \
  } \
  if (ptr - bytes != max_bytes) { \
    errno = EINVAL; \
    return 0; \
  } \
  return res; \
} \
 \
targ_type \
fn_name ## _norange(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  int digit; \
  targ_type res = 0; \
 \
  while (PDCI_is_a_space(*bytes)) { \
    bytes++; \
  } \
  if (*bytes == '+') { \
    bytes++; \
  } \
  if (!PDCI_is_a_digit(*bytes)) { \
    (*ptr_out) = (Pbyte*)bytes; \
    errno = EINVAL; \
    return 0; \
  } \
  while ((digit = PDCI_ascii_digit[*bytes]) != -1) { \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    res += digit; \
    bytes++; \
  } \
  (*ptr_out) = (Pbyte*)bytes; \
  errno = 0; \
  return res; \
} \

#define PDCI_NUM2A_GEN(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w) \
ssize_t \
rev_fn_name ## _buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type i) \
{ \
  ssize_t writelen; \
 \
  errno = 0; \
  PDCI_sfstr_seek2zero(pads->tmp1); \
  sfpr_macro(writelen, pads->tmp1, fmt, i); \
  if (writelen <= 0) { \
    return -1; \
  } \
  if (writelen > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    return -1; \
  } \
  memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen); \
  return writelen; \
} \
 \
ssize_t \
rev_fn_name ## _FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type i, size_t width) \
{ \
  ssize_t writelen; \
 \
  errno = 0; \
  if (width > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    return -1; \
  } \
  PDCI_sfstr_seek2zero(pads->tmp1); \
  sfpr_macro_w(writelen, pads->tmp1, wfmt, width, i); \
  if (writelen != width) { \
    return -1; \
  } \
  memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen); \
  return writelen; \
} \
 \
ssize_t \
rev_fn_name ## _io(P_t *pads, Sfio_t *io, targ_type i) \
{ \
  ssize_t writelen; \
 \
  errno = 0; \
  sfpr_macro(writelen, io, fmt, i); \
  return writelen; \
} \
 \
ssize_t \
rev_fn_name ## _FW_io(P_t *pads, Sfio_t *io, targ_type i, size_t width) \
{ \
  ssize_t writelen; \
 \
  errno = 0; \
  PDCI_sfstr_seek2zero(pads->tmp1); \
  sfpr_macro_w(writelen, pads->tmp1, wfmt, width, i); \
  if (writelen != width) { \
    return -1; \
  } \
  return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen); \
} \

#define PDCI_E2INT_GEN(fn_name, targ_type, int_min, int_max) \
targ_type \
fn_name(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  int digit; \
  int  neg = 0, range_err = 0; \
  targ_type res = 0; \
 \
  while (PDCI_is_e_space(*bytes)) { \
    bytes++; \
  } \
  if (*bytes == P_EBCDIC_PLUS) { \
    bytes++; \
  } else if (*bytes == P_EBCDIC_MINUS) { \
    bytes++; \
    neg = 1; \
  } \
  if (!PDCI_is_e_digit(*bytes)) { \
    (*ptr_out) = (Pbyte*)bytes; \
    errno = EINVAL; \
    return 0; \
  } \
  while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) { \
    if (res < int_min ## _DIV10) { \
      range_err = 1; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    if (res < int_min + digit) { \
      range_err = 1; \
    } \
    res -= digit; \
    bytes++; \
  } \
  (*ptr_out) = (Pbyte*)bytes; \
  if (range_err) { \
    errno = ERANGE; \
    return neg ? int_min : int_max; \
  } \
  errno = 0; \
  return neg ? res : - res; \
} \
 \
targ_type \
fn_name ## _norange(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  int digit; \
  int  neg = 0; \
  targ_type res = 0; \
 \
  while (PDCI_is_e_space(*bytes)) { \
    bytes++; \
  } \
  if (*bytes == P_EBCDIC_PLUS) { \
    bytes++; \
  } else if (*bytes == P_EBCDIC_MINUS) { \
    bytes++; \
    neg = 1; \
  } \
  if (!PDCI_is_e_digit(*bytes)) { \
    (*ptr_out) = (Pbyte*)bytes; \
    errno = EINVAL; \
    return 0; \
  } \
  while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) { \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    res -= digit; \
    bytes++; \
  } \
  (*ptr_out) = (Pbyte*)bytes; \
  errno = 0; \
  return neg ? res : - res; \
} \

#define PDCI_E2UINT_GEN(fn_name, targ_type, int_max) \
targ_type \
fn_name(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  int digit; \
  int range_err = 0; \
  targ_type res = 0; \
 \
  while (PDCI_is_e_space(*bytes)) { \
    bytes++; \
  } \
  if (*bytes == P_EBCDIC_PLUS) { \
    bytes++; \
  } else if (*bytes == P_EBCDIC_MINUS) { \
    bytes++; \
    range_err = 1; \
  } \
  if (!PDCI_is_e_digit(*bytes)) { \
    (*ptr_out) = (Pbyte*)bytes; \
    errno = EINVAL; \
    return 0; \
  } \
  while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) { \
    if (res > int_max ## _DIV10) { \
      range_err = 1; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    if (res > int_max - digit) { \
      range_err = 1; \
    } \
    res += digit; \
    bytes++; \
  } \
  (*ptr_out) = (Pbyte*)bytes; \
  if (range_err) { \
    errno = ERANGE; \
    return int_max; \
  } \
  errno = 0; \
  return res; \
} \
 \
targ_type \
fn_name ## _norange(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  int digit; \
  targ_type res = 0; \
 \
  while (PDCI_is_e_space(*bytes)) { \
    bytes++; \
  } \
  if (*bytes == P_EBCDIC_PLUS) { \
    bytes++; \
  } \
  if (!PDCI_is_e_digit(*bytes)) { \
    (*ptr_out) = (Pbyte*)bytes; \
    errno = EINVAL; \
    return 0; \
  } \
  while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) { \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    res += digit; \
    bytes++; \
  } \
  (*ptr_out) = (Pbyte*)bytes; \
  errno = 0; \
  return res; \
} \

#define PDCI_NUM2E_GEN(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w) \
ssize_t \
rev_fn_name ## _buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type i) \
{ \
  ssize_t  j, writelen; \
  char    *buf; \
 \
  errno = 0; \
  PDCI_sfstr_seek2zero(pads->tmp1); \
  sfpr_macro(writelen, pads->tmp1, fmt, i); \
  if (writelen <= 0) { \
    return -1; \
  } \
  if (writelen > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    return -1; \
  } \
  buf = PDCI_sfstr_use(pads->tmp1); \
  for (j = 0; j < writelen; j++) { \
    outbuf[j] = P_mod_ae_tab[(int)(buf[j])]; \
  } \
  return writelen; \
} \
 \
ssize_t \
rev_fn_name ## _FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type i, size_t width) \
{ \
  ssize_t  j, writelen; \
  char    *buf; \
 \
  errno = 0; \
  if (width > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    return -1; \
  } \
  PDCI_sfstr_seek2zero(pads->tmp1); \
  sfpr_macro_w(writelen, pads->tmp1, wfmt, width, i); \
  if (writelen != width) { \
    return -1; \
  } \
  buf = PDCI_sfstr_use(pads->tmp1); \
  for (j = 0; j < writelen; j++) { \
    outbuf[j] = P_mod_ae_tab[(int)(buf[j])]; \
  } \
  return writelen; \
} \
 \
ssize_t \
rev_fn_name ## _io (P_t *pads, Sfio_t *io, targ_type i) \
{ \
  ssize_t  j, writelen; \
  char    *buf; \
 \
  errno = 0; \
  PDCI_sfstr_seek2zero(pads->tmp1); \
  sfpr_macro(writelen, pads->tmp1, fmt, i); \
  if (-1 == writelen) return -1; \
  buf = PDCI_sfstr_use(pads->tmp1); \
  for (j = 0; j < writelen; j++) { \
    buf[j] = P_mod_ae_tab[(int)(buf[j])]; \
  } \
  return sfwrite(io, buf, writelen); \
} \
 \
ssize_t \
rev_fn_name ## _FW_io (P_t *pads, Sfio_t *io, targ_type i, size_t width) \
{ \
  ssize_t  j, writelen; \
  char    *buf; \
 \
  errno = 0; \
  PDCI_sfstr_seek2zero(pads->tmp1); \
  sfpr_macro_w(writelen, pads->tmp1, wfmt, width, i); \
  if (writelen != width) { \
    return -1; \
  } \
  buf = PDCI_sfstr_use(pads->tmp1); \
  for (j = 0; j < writelen; j++) { \
    buf[j] = P_mod_ae_tab[(int)(buf[j])]; \
  } \
  return sfwrite(io, buf, writelen); \
} \

#define PDCI_INT1_2B_GEN(rev_fn_name, targ_type) \
ssize_t \
rev_fn_name ## _buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type i) \
{ \
  if (!outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    errno = EDOM; \
    return -1; \
  } \
  /* on-disk order always same as in-memory rep */ \
  outbuf[0] = *((Pbyte*)(&i)); \
  errno = 0; \
  return 1; \
} \
 \
ssize_t \
rev_fn_name ## _io(P_t *pads, Sfio_t *io, targ_type i) \
{ \
  Pbyte *ibytes = (Pbyte*)(&i); \
  /* on-disk order always same as in-memory rep */ \
  errno = 0; \
  return sfwrite(io, ibytes, 1); \
} \

#define PDCI_INT2B_GEN(rev_fn_name, targ_type, num_bytes) \
ssize_t \
rev_fn_name ## _buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type i) \
{ \
  Pbyte *ibytes = (Pbyte*)(&i); \
 \
  if (num_bytes > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    errno = EDOM; \
    return -1; \
  } \
  if (pads->m_endian == pads->disc->d_endian) { \
    /* on-disk order same as in-memory rep */ \
    memcpy(outbuf, ibytes, num_bytes); \
  } else { \
    /* must reverse the order */ \
    int n = num_bytes; \
    while (--n >= 0) { \
      outbuf[n] = *ibytes++; \
    } \
  } \
  errno = 0; \
  return num_bytes; \
} \
 \
ssize_t \
rev_fn_name ## _io(P_t *pads, Sfio_t *io, targ_type i) \
{ \
  Pbyte *ibytes = (Pbyte*)(&i); \
 \
  errno = 0; \
  if (pads->m_endian == pads->disc->d_endian) { \
    /* on-disk order same as in-memory rep */ \
    return sfwrite(io, ibytes, num_bytes); \
  } \
  { \
    /* else must reverse the order */ \
    Pbyte  sb[num_bytes]; \
    int n = num_bytes; \
    while (--n >= 0) { \
      sb[n] = *ibytes++; \
    } \
    return sfwrite(io, sb, num_bytes); \
  } \
} \

#define PDCI_EBC2INT_GEN(fn_name, rev_fn_name, targ_type, higher_targ_type, int_min, int_max, nd_max, act_nd_max) \
targ_type \
fn_name(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) \
{ \
  Pint32 n = num_digits; \
  targ_type res = 0; \
  int neg, digit; \
 \
  (*ptr_out) = (Pbyte*)bytes + n; \
  if (n == 0 || n > nd_max) { \
    errno = EDOM; \
    return int_min; \
  } \
  neg = ((bytes[n-1]&0xF0) == 0xD0); /* look at sign nibble; C,F >=0; D < 0 */ \
  while (--n >= 0) { \
    if ((digit = (0xF & *bytes)) > 9) { \
      errno = EINVAL; \
      return 0; \
    } \
    if (res < int_min ## _DIV10) { \
      goto range_err; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    if (res < int_min + digit) { \
      goto range_err; \
    } \
    res -= digit; \
    bytes++; \
  } \
  errno = 0; \
  return neg ? res : - res; \
 range_err: \
  errno = ERANGE; \
  return neg ? int_min : int_max; \
} \
 \
targ_type \
fn_name ## _norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) \
{ \
  Pint32 n = num_digits; \
  targ_type res = 0; \
  int neg, digit; \
 \
  (*ptr_out) = (Pbyte*)bytes + n; \
  if (n == 0 || n > nd_max) { \
    errno = EDOM; \
    return int_min; \
  } \
  neg = ((bytes[n-1]&0xF0) == 0xD0); /* look at sign nibble; C,F >=0; D < 0 */ \
  while (--n >= 0) { \
    if ((digit = (0xF & *bytes)) > 9) { \
      errno = EINVAL; \
      return 0; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    res -= digit; \
    bytes++; \
  } \
  errno = 0; \
  return neg ? res : - res; \
} \
 \
ssize_t \
rev_fn_name ## _buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type i_in, Puint32 num_digits) \
{ \
  Pint32 n = num_digits; \
  Pbyte  ebc[30]; \
  targ_type lim; \
  higher_targ_type     i      = i_in; \
 \
  if (num_digits > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    errno = EDOM; \
    return -1; \
  } \
  if (n == 0 || n > nd_max) { \
    errno = EDOM; \
    return -1; \
  } \
  if (n < act_nd_max) { \
    lim = PDCI_10toThe[n]; \
    if (i >= lim || (-i) >= lim) { \
      errno = ERANGE; \
      return -1; \
    } \
  } \
  if (i < 0) { \
    i = -i; \
    while (--n >= 0) { \
      ebc[n] = 0xF0 | (i % 10); \
      i /= 10; \
    } \
    ebc[num_digits-1] &= 0xDF; /* force sign nibble to negative */ \
  } else { \
    while (--n >= 0) { \
      ebc[n] = 0xF0 | (i % 10); \
      i /= 10; \
    } \
  } \
  errno = 0; \
  memcpy(outbuf, ebc, num_digits); \
  return num_digits; \
} \
 \
ssize_t \
rev_fn_name ## _io (P_t *pads, Sfio_t *io, targ_type i_in, Puint32 num_digits) \
{ \
  Pint32 n = num_digits; \
  Pbyte  ebc[30]; \
  targ_type lim; \
  higher_targ_type i     = i_in; \
 \
  if (n == 0 || n > nd_max) { \
    errno = EDOM; \
    return -1; \
  } \
  if (n < act_nd_max) { \
    lim = PDCI_10toThe[n]; \
    if (i >= lim || (-i) >= lim) { \
      errno = ERANGE; \
      return -1; \
    } \
  } \
  if (i < 0) { \
    i = -i; \
    while (--n >= 0) { \
      ebc[n] = 0xF0 | (i % 10); \
      i /= 10; \
    } \
    ebc[num_digits-1] &= 0xDF; /* force sign nibble to negative */ \
  } else { \
    while (--n >= 0) { \
      ebc[n] = 0xF0 | (i % 10); \
      i /= 10; \
    } \
  } \
  errno = 0; \
  return sfwrite(io, ebc, num_digits); \
} \

#define PDCI_EBC2UINT_GEN(fn_name, rev_fn_name, targ_type, int_max, nd_max) \
targ_type \
fn_name(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) \
{ \
  Pint32 n = num_digits; \
  targ_type res = 0; \
  int digit; \
 \
  (*ptr_out) = (Pbyte*)bytes + n; \
  if (n == 0 || n > nd_max) { \
    errno = EDOM; \
    return int_max; \
  } \
  if ((bytes[n-1]&0xF0) == 0xD0) { /* look at sign nibble; C,F >=0; D < 0 */ \
    goto range_err; \
  } \
  while (--n >= 0) { \
    if ((digit = (0xF & *bytes)) > 9) { \
      errno = EINVAL; \
      return 0; \
    } \
    if (res > int_max ## _DIV10) { \
      goto range_err; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    if (res > int_max - digit) { \
      goto range_err; \
    } \
    res += digit; \
    bytes++; \
  } \
  errno = 0; \
  return res; \
 range_err: \
  errno = ERANGE; \
  return int_max; \
} \
 \
targ_type \
fn_name ## _norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) \
{ \
  Pint32 n = num_digits; \
  targ_type res = 0; \
  int digit; \
 \
  (*ptr_out) = (Pbyte*)bytes + n; \
  if (n == 0 || n > nd_max) { \
    errno = EDOM; \
    return int_max; \
  } \
  while (--n >= 0) { \
    if ((digit = (0xF & *bytes)) > 9) { \
      errno = EINVAL; \
      return 0; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    res += digit; \
    bytes++; \
  } \
  errno = 0; \
  return res; \
} \
 \
ssize_t \
rev_fn_name ## _buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type u, Puint32 num_digits) \
{ \
  Pint32 n = num_digits; \
  Pbyte  ebc[30]; \
  targ_type lim; \
 \
  if (num_digits > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    errno = EDOM; \
    return -1; \
  } \
  if (n == 0 || n > nd_max) { \
    errno = EDOM; \
    return -1; \
  } \
  if (n < nd_max) { \
    lim = PDCI_10toThe[n]; \
    if (u >= lim) { \
      errno = ERANGE; \
      return -1; \
    } \
  } \
  while (--n >= 0) { \
    ebc[n] = 0xF0 | (u % 10); \
    u /= 10; \
  } \
  errno = 0; \
  memcpy(outbuf, ebc, num_digits); \
  return num_digits; \
} \
 \
ssize_t \
rev_fn_name ## _io (P_t *pads, Sfio_t *io, targ_type u, Puint32 num_digits) \
{ \
  Pint32 n = num_digits; \
  Pbyte  ebc[30]; \
  targ_type lim; \
 \
  if (n == 0 || n > nd_max) { \
    errno = EDOM; \
    return -1; \
  } \
  if (n < nd_max) { \
    lim = PDCI_10toThe[n]; \
    if (u >= lim) { \
      errno = ERANGE; \
      return -1; \
    } \
  } \
  while (--n >= 0) { \
    ebc[n] = 0xF0 | (u % 10); \
    u /= 10; \
  } \
  errno = 0; \
  return sfwrite(io, ebc, num_digits); \
} \

#define PDCI_BCD2INT_GEN(fn_name, rev_fn_name, targ_type, higher_targ_type, int_min, int_max, nd_max, act_nd_max) \
targ_type \
fn_name(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) \
{ \
  int  digit, two_digits; \
  int  neg = 0; \
  Pint32 num_bytes = ((num_digits+2)/2); /* XXX_CHECK */ \
  targ_type res = 0; \
 \
  (*ptr_out) = (Pbyte*)bytes + num_bytes; \
  neg = ((num_digits % 2 == 1) && ((bytes[num_bytes-1]&0xF) == 0xD)); /* look at sign nibble; C,F >=0; D < 0 */ \
  if (num_digits == 0 || num_digits > nd_max) { \
    errno = EDOM; \
    return int_min; \
  } \
  while (num_digits >= 2) { \
    if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) { \
      (*ptr_out) = (Pbyte*)bytes; \
      errno = EINVAL; \
      return 0; \
    } \
    if (res < int_min ## _DIV100) { \
      goto range_err; \
    } \
    res *= 100; \
    if (res < int_min + two_digits) { \
      goto range_err; \
    } \
    res -= two_digits; \
    bytes++; \
    num_digits -= 2; \
  } \
  if (num_digits) { \
    if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) { \
      errno = EINVAL; \
      return 0; \
    } \
    if (res < int_min ## _DIV10) { \
      goto range_err; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    if (res < int_min + digit) { \
      goto range_err; \
    } \
    res -= digit; \
    bytes++; \
  } \
  errno = 0; \
  return neg ? res : - res; \
 range_err: \
  errno = ERANGE; \
  return neg ? int_min : int_max; \
} \
 \
targ_type \
fn_name ## _norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) \
{ \
  int  digit, two_digits; \
  int  neg = 0; \
  Pint32 num_bytes = ((num_digits+2)/2); /* XXX_CHECK */ \
  targ_type res = 0; \
 \
  (*ptr_out) = (Pbyte*)bytes + num_bytes; \
  neg = ((num_digits % 2 == 1) && ((bytes[num_bytes-1]&0xF) == 0xD)); /* look at sign nibble; C,F >=0; D < 0 */ \
  if (num_digits == 0 || num_digits > nd_max) { \
    errno = EDOM; \
    return int_min; \
  } \
  while (num_digits >= 2) { \
    if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) { \
      (*ptr_out) = (Pbyte*)bytes; \
      errno = EINVAL; \
      return 0; \
    } \
    res *= 100; \
    res -= two_digits; \
    bytes++; \
    num_digits -= 2; \
  } \
  if (num_digits) { \
    if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) { \
      errno = EINVAL; \
      return 0; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    res -= digit; \
    bytes++; \
  } \
  errno = 0; \
  return neg ? res : - res; \
} \
 \
ssize_t \
rev_fn_name ## _buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type i_in, Puint32 num_digits) \
{ \
  Pbyte  bcd[30]; \
  Pint32 num_bytes; \
  int       x, n; \
  int       odd_digits = (num_digits % 2 == 1); \
  targ_type lim; \
  higher_targ_type i     = i_in; \
 \
  num_bytes = ((num_digits+2)/2); /* XXX_CHECK */ \
  if (num_bytes > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    errno = EDOM; \
    return -1; \
  } \
  if (num_digits == 0 || num_digits > nd_max) { \
    errno = EDOM; \
    return -1; \
  } \
  if (num_digits < act_nd_max) { \
    lim = PDCI_10toThe[num_digits]; \
    if (i >= lim || (-i) >= lim) { \
      errno = ERANGE; \
      return -1; \
    } \
  } \
  n = num_bytes - 1; \
  if (i < 0) { \
    if (!odd_digits) {  /* must use odd number of digits for negative number */ \
      errno = EDOM; \
      return -1; \
    } \
    i = -i; \
    bcd[n--] = ((i%10)<<4) | 0xD; /* force sign nibble to negative */ \
    i /= 10; \
    while (n >= 0) { \
      x = i % 100; \
      i /= 100; \
      bcd[n--] = (x%10) | ((x/10)<<4); \
    } \
  } else { /* i positive */ \
    if (odd_digits) { \
      bcd[n--] = ((i%10)<<4); \
      i /= 10; \
    } else { /* for even number of digits, last byte is not used; set it to zero to be safe */ \
      bcd[n--] = 0; \
    } \
    while (n >= 0) { \
      x = i % 100; \
      i /= 100; \
      bcd[n--] = (x%10) | ((x/10)<<4); \
    } \
  } \
  errno = 0; \
  memcpy(outbuf, bcd, num_bytes); \
  return num_bytes; \
} \
 \
ssize_t \
rev_fn_name ## _io (P_t *pads, Sfio_t *io, targ_type i_in, Puint32 num_digits) \
{ \
  Pbyte  bcd[30]; \
  Pint32 num_bytes; \
  int       x, n; \
  int       odd_digits = (num_digits % 2 == 1); \
  targ_type lim; \
  higher_targ_type i     = i_in; \
 \
  if (num_digits == 0 || num_digits > nd_max) { \
    errno = EDOM; \
    return -1; \
  } \
  if (num_digits < act_nd_max) { \
    lim = PDCI_10toThe[num_digits]; \
    if (i >= lim || (-i) >= lim) { \
      errno = ERANGE; \
      return -1; \
    } \
  } \
  num_bytes = ((num_digits+2)/2); /* XXX_CHECK */ \
  n = num_bytes - 1; \
  if (i < 0) { \
    if (!odd_digits) {  /* must use odd number of digits for negative number */ \
      errno = EDOM; \
      return -1; \
    } \
    i = -i; \
    bcd[n--] = ((i%10)<<4) | 0xD; /* force sign nibble to negative */ \
    i /= 10; \
    while (n >= 0) { \
      x = i % 100; \
      i /= 100; \
      bcd[n--] = (x%10) | ((x/10)<<4); \
    } \
  } else { /* i positive */ \
    if (odd_digits) { \
      bcd[n--] = ((i%10)<<4); \
      i /= 10; \
    } else { /* for even number of digits, last byte is not used; set it to zero to be safe */ \
      bcd[n--] = 0; \
    } \
    while (n >= 0) { \
      x = i % 100; \
      i /= 100; \
      bcd[n--] = (x%10) | ((x/10)<<4); \
    } \
  } \
  errno = 0; \
  return sfwrite(io, bcd, num_bytes); \
} \

#define PDCI_BCD2UINT_GEN(fn_name, rev_fn_name, targ_type, int_max, nd_max) \
targ_type \
fn_name(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) \
{ \
  int  digit, two_digits; \
  Pint32 num_bytes = ((num_digits+2)/2); /* XXX_CHECK */ \
  targ_type res = 0; \
 \
  (*ptr_out) = (Pbyte*)bytes + num_bytes; \
  if (num_digits == 0 || num_digits > nd_max) { \
    errno = EDOM; \
    return int_max; \
  } \
  while (num_digits >= 2) { \
    if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) { \
      (*ptr_out) = (Pbyte*)bytes; \
      errno = EINVAL; \
      return 0; \
    } \
    if (res > int_max ## _DIV100) { \
      goto range_err; \
    } \
    res *= 100; \
    if (res > int_max - two_digits) { \
      goto range_err; \
    } \
    res += two_digits; \
    bytes++; \
    num_digits -= 2; \
  } \
  if (num_digits) { \
    if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) { \
      errno = EINVAL; \
      return 0; \
    } \
    if (res > int_max ## _DIV10) { \
      goto range_err; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    if (res > int_max - digit) { \
      goto range_err; \
    } \
    res += digit; \
    bytes++; \
  } \
  errno = 0; \
  return res; \
 range_err: \
  errno = ERANGE; \
  return int_max; \
} \
 \
targ_type \
fn_name ## _norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) \
{ \
  int  digit, two_digits; \
  Pint32 num_bytes = ((num_digits+2)/2); /* XXX_CHECK */ \
  targ_type res = 0; \
 \
  (*ptr_out) = (Pbyte*)bytes + num_bytes; \
  if (num_digits == 0 || num_digits > nd_max) { \
    errno = EDOM; \
    return int_max; \
  } \
  while (num_digits >= 2) { \
    if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) { \
      (*ptr_out) = (Pbyte*)bytes; \
      errno = EINVAL; \
      return 0; \
    } \
    res *= 100; \
    res += two_digits; \
    bytes++; \
    num_digits -= 2; \
  } \
  if (num_digits) { \
    if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) { \
      errno = EINVAL; \
      return 0; \
    } \
    res = (res << 3) + (res << 1); /* res *= 10 */ \
    res += digit; \
    bytes++; \
  } \
  errno = 0; \
  return res; \
} \
 \
ssize_t \
rev_fn_name ## _buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type u, Puint32 num_digits) \
{ \
  Pbyte  bcd[30]; \
  Pint32 num_bytes; \
  int       x, n; \
  targ_type lim; \
 \
  num_bytes = ((num_digits+2)/2); /* XXX_CHECK */ \
  if (num_bytes > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    errno = EDOM; \
    return -1; \
  } \
  if (num_digits == 0 || num_digits > nd_max) { \
    errno = EDOM; \
    return -1; \
  } \
  if (num_digits < nd_max) { \
    lim = PDCI_10toThe[num_digits]; \
    if (u >= lim) { \
      errno = ERANGE; \
      return -1; \
    } \
  } \
  n = num_bytes - 1; \
  if (num_digits % 2 == 1) { \
    bcd[n--] = ((u%10)<<4); \
    u /= 10; \
  } else { /* for even number of digits, last byte is not used; set it to zero to be safe */ \
    bcd[n--] = 0; \
  } \
  while (n >= 0) { \
    x = u % 100; \
    u /= 100; \
    bcd[n--] = (x%10) | ((x/10)<<4); \
  } \
  errno = 0; \
  memcpy(outbuf, bcd, num_bytes); \
  return num_bytes; \
} \
 \
ssize_t \
rev_fn_name ## _io (P_t *pads, Sfio_t *io, targ_type u, Puint32 num_digits) \
{ \
  Pbyte  bcd[30]; \
  Pint32 num_bytes; \
  int       x, n; \
  targ_type lim; \
 \
  if (num_digits == 0 || num_digits > nd_max) { \
    errno = EDOM; \
    return -1; \
  } \
  if (num_digits < nd_max) { \
    lim = PDCI_10toThe[num_digits]; \
    if (u >= lim) { \
      errno = ERANGE; \
      return -1; \
    } \
  } \
  num_bytes = ((num_digits+2)/2); /* XXX_CHECK */ \
  n = num_bytes - 1; \
  if (num_digits % 2 == 1) { \
    bcd[n--] = ((u%10)<<4); \
    u /= 10; \
  } else { /* for even number of digits, last byte is not used; set it to zero to be safe */ \
    bcd[n--] = 0; \
  } \
  while (n >= 0) { \
    x = u % 100; \
    u /= 100; \
    bcd[n--] = (x%10) | ((x/10)<<4); \
  } \
  errno = 0; \
  return sfwrite(io, bcd, num_bytes); \
} \

#define PDCI_SB2INT_GEN(fn_name, rev_fn_name, targ_type, sb_endian, int_min, int_max, nb_max) \
targ_type \
fn_name(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) \
{ \
  Pint32 n = num_bytes; \
  targ_type res = 0; \
  Pbyte *resbytes = (Pbyte*)(&res); \
 \
  (*ptr_out) = (Pbyte*)bytes + num_bytes; \
  if (n == 0 || n > nb_max) { \
    errno = EDOM; \
    return int_min; \
  } \
  if (pads->m_endian == sb_endian) { \
    /* on-disk order same as in-memory rep */ \
    memcpy(resbytes , bytes, n); \
  } else { \
    /* must reverse the order */ \
    while (--n >= 0) { \
      resbytes[n] = *bytes++; \
    } \
  } \
  errno = 0; \
  if (pads->m_endian == PbigEndian){ \
    /* High-order byte of value from bytes is aligned with high-order byte of res. \
       Shift res so that value and res are aligned at on low-order byte. \
       nb_max - n is number of bytes. Multiply x 8 = # bits. */ \
    res = res >> ((nb_max - num_bytes) * 8); \
  } \
  return res; \
} \
 \
ssize_t \
rev_fn_name ## _buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type i, Puint32 num_bytes) \
{ \
  Pint32 n = num_bytes; \
  Pbyte *ibytes = (Pbyte*)(&i); \
 \
  if (num_bytes > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    errno = EDOM; \
    return -1; \
  } \
  if (n == 0 || n > 8) { \
    errno = EDOM; \
    return -1; \
  }; \
  if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) { \
    errno = ERANGE; \
    return -1; \
  } \
  if (pads->m_endian == PbigEndian){ \
    /* Shift i so that the high-order byte of the value it contains is aligned with i's high-order byte. \
       nb_max - n is number of bytes. Multiply x 8 = # bits. */ \
    i <<= ((nb_max - num_bytes) * 8); \
  } \
  if (pads->m_endian == sb_endian) { \
    /* on-disk order same as in-memory rep. */ \
    memcpy(outbuf, ibytes, num_bytes); \
  } else { \
    /* must reverse the order */ \
    while (--n >= 0) { \
      outbuf[n] = *ibytes++; \
    } \
  } \
  errno = 0; \
  return num_bytes; \
} \
 \
ssize_t \
rev_fn_name ## _io (P_t *pads, Sfio_t *io, targ_type i, Puint32 num_bytes) \
{ \
  Pint32 n = num_bytes; \
  Pbyte *ibytes = (Pbyte*)(&i); \
 \
  if (n == 0 || n > 8) { \
    errno = EDOM; \
    return -1; \
  }; \
  if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) { \
    errno = ERANGE; \
    return -1; \
  } \
  if (pads->m_endian == PbigEndian){ \
    /* Shift i so that the high-order byte of the value it contains is aligned with i's high-order byte. \
       nb_max - n is number of bytes. Multiply x 8 = # bits. */ \
    i <<= ((nb_max - num_bytes) * 8); \
  } \
  errno = 0; \
  if (pads->m_endian == sb_endian) { \
    /* on-disk order same as in-memory rep */ \
    return sfwrite(io, ibytes, n); \
  } \
  { \
    /* else must reverse the order */ \
    Pbyte  sb[30]; \
    while (--n >= 0) { \
      sb[n] = *ibytes++; \
    } \
    return sfwrite(io, sb, num_bytes); \
  } \
} \

#define PDCI_SB2UINT_GEN(fn_name, rev_fn_name, targ_type, sb_endian, int_max, nb_max) \
targ_type \
fn_name(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) \
{ \
  Pint32 n = num_bytes; \
  targ_type res = 0; \
  Pbyte *resbytes = (Pbyte*)(&res); \
 \
  (*ptr_out) = (Pbyte*)bytes + n; \
  if (n == 0 || n > nb_max) { \
    errno = EDOM; \
    return int_max; \
  } \
  if (pads->m_endian == sb_endian) { \
    /* on-disk order same as in-memory rep */ \
    memcpy(resbytes, bytes, n); \
  } else { \
    /* must reverse the order */ \
    while (--n >= 0) { \
      resbytes[n] = *bytes++; \
    } \
  } \
  errno = 0; \
  if (pads->m_endian == PbigEndian){ \
    /* High-order byte of value from bytes is aligned with high-order byte of res. \
       Shift res so that value and res are aligned at on low-order byte. \
       nb_max - n is number of bytes. Multiply x 8 = # bits. */ \
    res = res >> ((nb_max - num_bytes) * 8); \
  } \
  return res; \
} \
 \
ssize_t \
rev_fn_name ## _buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, targ_type u, Puint32 num_bytes) \
{ \
  Pint32 n = num_bytes; \
  Pbyte *ubytes = (Pbyte*)(&u); \
 \
  if (num_bytes > outbuf_len) { \
    if (outbuf_full) { (*outbuf_full) = 1; } \
    errno = EDOM; \
    return -1; \
  } \
  if (n == 0 || n > 8) { \
    errno = EDOM; \
    return -1; \
  }; \
  if (u > P_UMAX_FOR_NB[n]) { \
    errno = ERANGE; \
    return -1; \
  } \
  if (pads->m_endian == PbigEndian){ \
    /* Shift u so that the high-order byte of the value it contains is aligned with u's high-order byte. \
       nb_max - n is number of bytes. Multiply x 8 = # bits. */ \
    u <<= ((nb_max - num_bytes) * 8); \
  } \
  if (pads->m_endian == sb_endian) { \
    /* on-disk order same as in-memory rep */ \
    memcpy(outbuf, ubytes, num_bytes); \
  } else { \
    /* must reverse the order */ \
    while (--n >= 0) { \
      outbuf[n] = *ubytes++; \
    } \
  } \
  errno = 0; \
  return num_bytes; \
} \
 \
ssize_t \
rev_fn_name ## _io (P_t *pads, Sfio_t *io, targ_type u, Puint32 num_bytes) \
{ \
  Pint32 n = num_bytes; \
  Pbyte *ubytes = (Pbyte*)(&u); \
 \
  if (n == 0 || n > 8) { \
    errno = EDOM; \
    return -1; \
  }; \
  if (u > P_UMAX_FOR_NB[n]) { \
    errno = ERANGE; \
    return -1; \
  } \
  if (pads->m_endian == PbigEndian){ \
    /* Shift u so that the high-order byte of the value it contains is aligned with u's high-order byte. \
       nb_max - n is number of bytes. Multiply x 8 = # bits. */ \
    u <<= ((nb_max - num_bytes) * 8); \
  } \
  errno = 0; \
  if (pads->m_endian == sb_endian) { \
    /* on-disk order same as in-memory rep */ \
    return sfwrite(io, ubytes, n); \
  } \
  { \
    /* else must reverse the order */ \
    Pbyte sb[30]; \
    while (--n >= 0) { \
      sb[n] = *ubytes++; \
    } \
    return sfwrite(io, sb, num_bytes); \
  } \
} \

#define PDCI_A2FLOAT_GEN(fn_name, targ_type, float_min, float_max, Pstring2float_fn) \
targ_type \
fn_name(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  Pbyte* ptr; \
  _ast_fltmax_t d; \
 \
  /* skip spaces so that ptr == bytes means failed conversion */ \
  while (PDCI_is_a_space(*bytes)) { \
    bytes++; \
  } \
  errno = 0; \
  d = strtold((const char *)bytes, (char**)&ptr); \
  if (ptr >= bytes) { \
    (*ptr_out) = ptr; \
  } else { \
    (*ptr_out) = (Pbyte*)bytes; \
  } \
  if (ptr == bytes) { \
    errno = EINVAL; \
    return 0; \
  } \
  if ((errno == ERANGE && d < 0) || (d < float_min)) { \
    errno = ERANGE; \
    return float_min; \
  } \
  if ((errno == ERANGE) || (d > float_max)) { \
    errno = ERANGE; \
    return float_max; \
  } \
  return (targ_type)d; \
} \
 \
targ_type \
fn_name ## _norange(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  Pbyte* ptr; \
  _ast_fltmax_t d; \
 \
  /* skip spaces so that ptr == bytes means failed conversion */ \
  while (PDCI_is_a_space(*bytes)) { \
    bytes++; \
  } \
  errno = 0; \
  d = strtold((const char *)bytes, (char**)&ptr); \
  if (ptr >= bytes) { \
    (*ptr_out) = ptr; \
  } else { \
    (*ptr_out) = (Pbyte*)bytes; \
  } \
  if (ptr == bytes) { \
    errno = EINVAL; \
    return 0; \
  } \
  /* ignore all range errors, return potentially bogus wrapped/cast value */ \
  errno = 0;  \
  return (targ_type)d; \
} \
 \
targ_type \
fn_name ## _max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) \
{ \
 \
  Pbyte* ptr; \
  _ast_fltmax_t d; \
 \
  /* skip spaces so that ptr == bytes means failed conversion */ \
  while (max_bytes > 0 && PDCI_is_a_space(*bytes)) { \
    bytes++; \
    max_bytes--; \
  } \
  if (max_bytes == 0) { \
    errno = EINVAL; \
    return 0; \
  } \
  errno = 0; \
  d = strntold((const char *)bytes, max_bytes, (char**)&ptr); \
  if (ptr >= bytes) { \
    (*ptr_out) = ptr; \
  } else { \
    (*ptr_out) = (Pbyte*)bytes; \
  } \
  if (ptr == bytes) { \
    errno = EINVAL; \
    return 0; \
  } \
  if ((errno == ERANGE && d < 0) || (d < float_min)) { \
    errno = ERANGE; \
    return float_min; \
  } \
  if ((errno == ERANGE) || (d > float_max)) { \
    errno = ERANGE; \
    return float_max; \
  } \
  return (targ_type)d; \
} \
 \
targ_type \
Pstring2float_fn(const Pstring *s) \
{ \
  Pbyte *bytes, *ptr; \
  size_t max_bytes; \
  targ_type res; \
 \
  if (!s) { \
    errno = EINVAL; \
    return 0; \
  } \
  ptr = bytes = (Pbyte*)s->str; \
  max_bytes = s->len; \
  res = fn_name ## _max_bytes(bytes, max_bytes, &ptr); \
  if (errno) { \
    return res; \
  } \
  while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) { \
    ptr++; \
  } \
  if (ptr - bytes != max_bytes) { \
    errno = EINVAL; \
    return 0; \
  } \
  return res; \
} \

#define PDCI_E2FLOAT_GEN(fn_name, targ_type, float_min, float_max) \
targ_type \
fn_name(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  Sfio_t        *tmpstr; \
  char          *ascii_bytes, *ascii_ptr; \
  _ast_fltmax_t  d; \
 \
  if (!(tmpstr = sfstropen())) {  \
    P_FATAL(&Pdefault_disc, "sfstropen failed in " PDCI_MacroArg2String(fn_name)); \
  } \
 \
  while (PDCI_is_e_space(*bytes)) { \
    bytes++; \
  } \
  /* XXX_TODO should either add enough chars here to support e notation plus INF/INFINITY and (NAN) or disallow those forms for ASCII above */ \
  while ((*bytes) == P_EBCDIC_PLUS || (*bytes) == P_EBCDIC_MINUS || (*bytes) == P_EBCDIC_DOT || PDCI_is_e_digit(*bytes)) { \
    sfputc(tmpstr, P_mod_ea_tab[(int)(*bytes)]); \
    bytes++; \
  } \
  ascii_bytes = PDCI_sfstr_use(tmpstr); \
  errno = 0; \
  d = strtold((const char *)ascii_bytes, &ascii_ptr); \
  if (ascii_ptr >= ascii_bytes) { \
    (*ptr_out) = (Pbyte*)bytes + (ascii_ptr - ascii_bytes); \
  } else { \
    (*ptr_out) = (Pbyte*)bytes; \
  } \
  sfstrclose(tmpstr); \
  if (ascii_ptr == ascii_bytes) { \
    errno = EINVAL; \
    return 0; \
  } \
  if ((errno == ERANGE && d < 0) || (d < float_min)) { \
    errno = ERANGE; \
    return float_min; \
  } \
  if ((errno == ERANGE) || (d > float_max)) { \
    errno = ERANGE; \
    return float_max; \
  } \
  return (targ_type)d; \
} \
 \
targ_type \
fn_name ## _norange(const Pbyte *bytes, Pbyte **ptr_out) \
{ \
  Sfio_t        *tmpstr; \
  char          *ascii_bytes, *ascii_ptr; \
  _ast_fltmax_t  d; \
 \
  if (!(tmpstr = sfstropen())) {  \
    P_FATAL(&Pdefault_disc, "sfstropen failed in " PDCI_MacroArg2String(fn_name)); \
  } \
 \
  while (PDCI_is_e_space(*bytes)) { \
    bytes++; \
  } \
  /* XXX_TODO should either add enough chars here to support e notation plus INF/INFINITY and (NAN) or disallow those forms for ASCII above */ \
  while ((*bytes) == P_EBCDIC_PLUS || (*bytes) == P_EBCDIC_MINUS || (*bytes) == P_EBCDIC_DOT || PDCI_is_e_digit(*bytes)) { \
    sfputc(tmpstr, P_mod_ea_tab[(int)(*bytes)]); \
    bytes++; \
  } \
  ascii_bytes = PDCI_sfstr_use(tmpstr); \
  errno = 0; \
  d = strtold((const char *)ascii_bytes, &ascii_ptr); \
  if (ascii_ptr >= ascii_bytes) { \
    (*ptr_out) = (Pbyte*)bytes + (ascii_ptr - ascii_bytes); \
  } else { \
    (*ptr_out) = (Pbyte*)bytes; \
  } \
  sfstrclose(tmpstr); \
  if (ascii_ptr == ascii_bytes) { \
    errno = EINVAL; \
    return 0; \
  } \
  /* ignore all range errors, return potentially bogus wrapped/cast value */ \
  errno = 0;  \
  return (targ_type)d; \
} \
 \
targ_type \
fn_name ## _max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) \
{ \
  Sfio_t        *tmpstr; \
  char          *ascii_bytes, *ascii_ptr; \
  _ast_fltmax_t  d; \
 \
  if (!(tmpstr = sfstropen())) {  \
    P_FATAL(&Pdefault_disc, "sfstropen failed in " PDCI_MacroArg2String(fn_name)); \
  } \
 \
  while (max_bytes > 0 && PDCI_is_e_space(*bytes)) { \
    bytes++; \
    max_bytes--; \
  } \
  if (max_bytes == 0) { \
    errno = EINVAL; \
    return 0; \
  } \
  /* XXX_TODO should either add enough chars here to support e notation plus INF/INFINITY and (NAN) or disallow those forms for ASCII above */ \
  while ((*bytes) == P_EBCDIC_PLUS || (*bytes) == P_EBCDIC_MINUS || (*bytes) == P_EBCDIC_DOT || PDCI_is_e_digit(*bytes)) { \
    sfputc(tmpstr, P_mod_ea_tab[(int)(*bytes)]); \
    bytes++; \
  } \
  ascii_bytes = PDCI_sfstr_use(tmpstr); \
  errno = 0; \
  d = strntold((const char *)ascii_bytes, max_bytes, &ascii_ptr); \
  if (ascii_ptr >= ascii_bytes) { \
    (*ptr_out) = (Pbyte*)bytes + (ascii_ptr - ascii_bytes); \
  } else { \
    (*ptr_out) = (Pbyte*)bytes; \
  } \
  sfstrclose(tmpstr); \
  if (ascii_ptr == ascii_bytes) { \
    errno = EINVAL; \
    return 0; \
  } \
  if ((errno == ERANGE && d < 0) || (d < float_min)) { \
    errno = ERANGE; \
    return float_min; \
  } \
  if ((errno == ERANGE) || (d > float_max)) { \
    errno = ERANGE; \
    return float_max; \
  } \
  return (targ_type)d; \
} \

/* We need conversion routines for helpers such as Pstring2int32 */
#if 1 /* P_CONFIG_A_INT_FW > 0 || P_CONFIG_A_INT > 0 */
#  define PDCI_A2INT(fn_name, targ_type, int_min, int_max, Pstring2int_fn) \
            PDCI_A2INT_GEN(fn_name, targ_type, int_min, int_max, Pstring2int_fn)
#  define PDCI_A2UINT(fn_name, targ_type, int_max, Pstring2int_fn) \
            PDCI_A2UINT_GEN(fn_name, targ_type, int_max, Pstring2int_fn)
#  define PDCI_INT2A(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w) \
            PDCI_NUM2A_GEN(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w)
#else
#  define PDCI_A2INT(fn_name, targ_type, int_min, int_max, Pstring2int_fn)
#  define PDCI_A2UINT(fn_name, targ_type, int_max, Pstring2int_fn)
#  define PDCI_INT2A(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w)
#endif

#if P_CONFIG_E_INT_FW > 0 || P_CONFIG_E_INT > 0
#  define PDCI_E2INT(fn_name, targ_type, int_min, int_max) \
            PDCI_E2INT_GEN(fn_name, targ_type, int_min, int_max)
#  define PDCI_E2UINT(fn_name, targ_type, int_max) \
            PDCI_E2UINT_GEN(fn_name, targ_type, int_max)
#  define PDCI_INT2E(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w) \
            PDCI_NUM2E_GEN(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w)
#else
#  define PDCI_E2INT(fn_name, targ_type, int_min, int_max)
#  define PDCI_E2UINT(fn_name, targ_type, int_max)
#  define PDCI_INT2E(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w)
#endif

#if P_CONFIG_B_INT > 0
#  define PDCI_INT1_2B(rev_fn_name, targ_type) \
            PDCI_INT1_2B_GEN(rev_fn_name, targ_type)
#  define PDCI_INT2B(rev_fn_name, targ_type, num_bytes) \
            PDCI_INT2B_GEN(rev_fn_name, targ_type, num_bytes)
#else
#  define PDCI_INT1_2B(rev_fn_name, targ_type)
#  define PDCI_INT2B(rev_fn_name, targ_type, num_bytes)
#endif

#if P_CONFIG_EBC_INT > 0 || P_CONFIG_EBC_FPOINT > 0
#  define PDCI_EBC2INT(fn_name, rev_fn_name, targ_type, higher_targ_type, int_min, int_max, nd_max, act_nd_max) \
            PDCI_EBC2INT_GEN(fn_name, rev_fn_name, targ_type, higher_targ_type, int_min, int_max, nd_max, act_nd_max)
#  define PDCI_EBC2UINT(fn_name, rev_fn_name, targ_type, int_max, nd_max) \
            PDCI_EBC2UINT_GEN(fn_name, rev_fn_name, targ_type, int_max, nd_max)
#else
#  define PDCI_EBC2INT(fn_name, rev_fn_name, targ_type, higher_targ_type, int_min, int_max, nd_max, act_nd_max)
#  define PDCI_EBC2UINT(fn_name, rev_fn_name, targ_type, int_max, nd_max)
#endif

#if P_CONFIG_BCD_INT > 0 || P_CONFIG_BCD_FPOINT > 0
#  define PDCI_BCD2INT(fn_name, rev_fn_name, targ_type, higher_targ_type, int_min, int_max, nd_max, act_nd_max) \
            PDCI_BCD2INT_GEN(fn_name, rev_fn_name, targ_type, higher_targ_type, int_min, int_max, nd_max, act_nd_max)
#  define PDCI_BCD2UINT(fn_name, rev_fn_name, targ_type, int_max, nd_max) \
            PDCI_BCD2UINT_GEN(fn_name, rev_fn_name, targ_type, int_max, nd_max)
#else
#  define PDCI_BCD2INT(fn_name, rev_fn_name, targ_type, higher_targ_type, int_min, int_max, nd_max, act_nd_max)
#  define PDCI_BCD2UINT(fn_name, rev_fn_name, targ_type, int_max, nd_max)
#endif

#if P_CONFIG_SBL_INT > 0 || P_CONFIG_SBL_FPOINT > 0
#  define PDCI_SBL2INT(fn_name, rev_fn_name, targ_type, sb_endian, int_min, int_max, nb_max) \
            PDCI_SB2INT_GEN(fn_name, rev_fn_name, targ_type, sb_endian, int_min, int_max, nb_max)
#  define PDCI_SBL2UINT(fn_name, rev_fn_name, targ_type, sb_endian, int_max, nb_max) \
            PDCI_SB2UINT_GEN(fn_name, rev_fn_name, targ_type, sb_endian, int_max, nb_max)
#else
#  define PDCI_SBL2INT(fn_name, rev_fn_name, targ_type, sb_endian, int_min, int_max, nb_max)
#  define PDCI_SBL2UINT(fn_name, rev_fn_name, targ_type, sb_endian, int_max, nb_max)
#endif

#if P_CONFIG_SBH_INT > 0 || P_CONFIG_SBH_FPOINT > 0
#  define PDCI_SBH2INT(fn_name, rev_fn_name, targ_type, sb_endian, int_min, int_max, nb_max) \
            PDCI_SB2INT_GEN(fn_name, rev_fn_name, targ_type, sb_endian, int_min, int_max, nb_max)
#  define PDCI_SBH2UINT(fn_name, rev_fn_name, targ_type, sb_endian, int_max, nb_max) \
            PDCI_SB2UINT_GEN(fn_name, rev_fn_name, targ_type, sb_endian, int_max, nb_max)
#else
#  define PDCI_SBH2INT(fn_name, rev_fn_name, targ_type, sb_endian, int_min, int_max, nb_max)
#  define PDCI_SBH2UINT(fn_name, rev_fn_name, targ_type, sb_endian, int_max, nb_max)
#endif

#if P_CONFIG_A_FLOAT > 0
#  define PDCI_A2FLOAT(fn_name, targ_type, float_min, float_max, Pstring2float_fn) \
            PDCI_A2FLOAT_GEN(fn_name, targ_type, float_min, float_max, Pstring2float_fn)
#  define PDCI_FLOAT2A(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w) \
            PDCI_NUM2A_GEN(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w)
#else
#  define PDCI_A2FLOAT(fn_name, targ_type, float_min, float_max, Pstring2float_fn)
#  define PDCI_FLOAT2A(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w)
#endif

#if P_CONFIG_E_FLOAT > 0
#  define PDCI_E2FLOAT(fn_name, targ_type, float_min, float_max) \
            PDCI_E2FLOAT_GEN(fn_name, targ_type, float_min, float_max)
#  define PDCI_FLOAT2E(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w) \
            PDCI_NUM2E_GEN(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w)
#else
#  define PDCI_E2FLOAT(fn_name, targ_type, float_min, float_max)
#  define PDCI_FLOAT2E(rev_fn_name, targ_type, fmt, wfmt, sfpr_macro, sfpr_macro_w)
#endif

#endif  /*  __PADS_MISC_MACROS_GEN_H__  */

