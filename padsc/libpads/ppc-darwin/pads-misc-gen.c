/*
 * WARNING: GENERATED FILE.  Do not edit this file, edit /Users/kfisher/pads/padsc/libpads/pads.c instead. 
 */

/*
 * Generated misc functions
 * 
 * Kathleen Fisher, Robert Gruber
 * AT&T Labs Research
 */

#include "pads-internal.h"
#include "pads-macros-gen.h"

/* ================================================================================ */
/* USEFUL CONVERSION CONSTANTS */

#define P_MIN_INT8_DIV10                       -12
#define P_MIN_INT8_DIV100                       -1

#define P_MAX_UINT8_DIV10                      25U
#define P_MAX_UINT8_DIV100                      2U

#define P_MIN_INT16_DIV10                    -3276
#define P_MIN_INT16_DIV100                    -327

#define P_MAX_UINT16_DIV10                   6553U
#define P_MAX_UINT16_DIV100                   655U

#define P_MIN_INT32_DIV10              -214748364L
#define P_MIN_INT32_DIV100              -21474836L

#define P_MAX_UINT32_DIV10             429496729UL
#define P_MAX_UINT32_DIV100             42949672UL

#define P_MIN_INT64_DIV10    -922337203685477580LL
#define P_MIN_INT64_DIV100    -92233720368547758LL

#define P_MAX_UINT64_DIV10  1844674407370955161ULL
#define P_MAX_UINT64_DIV100  184467440737095516ULL

static Pint64 P_MIN_FOR_NB[] = {
  0,
  P_MIN_INT8,
  P_MIN_INT16,
  P_MIN_INT24,
  P_MIN_INT32,
  P_MIN_INT40,
  P_MIN_INT48,
  P_MIN_INT56,
  P_MIN_INT64
};

static Pint64 P_MAX_FOR_NB[] = {
  0,
  P_MAX_INT8,
  P_MAX_INT16,
  P_MAX_INT24,
  P_MAX_INT32,
  P_MAX_INT40,
  P_MAX_INT48,
  P_MAX_INT56,
  P_MAX_INT64
};

static Puint64 P_UMAX_FOR_NB[] = {
  0,
  P_MAX_UINT8,
  P_MAX_UINT16,
  P_MAX_UINT24,
  P_MAX_UINT32,
  P_MAX_UINT40,
  P_MAX_UINT48,
  P_MAX_UINT56,
  P_MAX_UINT64
};

Pint8 PDCI_a2int8(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint8 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 if (res < P_MIN_INT8_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT8 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT8 : P_MAX_INT8;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint8 PDCI_a2int8_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint8 res = 0;
 while (max_bytes > 0 && PDCI_is_a_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (*bytes == '+') {
 bytes++;
 max_bytes--;
 }
 else if (*bytes == '-') {
 bytes++;
 max_bytes--;
 neg = 1;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while (max_bytes > 0 && ((digit = PDCI_ascii_digit[*bytes]) != -1)) {
 if (res < P_MIN_INT8_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT8 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 max_bytes--;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT8 : P_MAX_INT8;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint8 Pstring2int8(const Pstring *s) {
 Pbyte *bytes, *ptr;
 size_t max_bytes;
 Pint8 res;
 if (!s) {
 errno = EINVAL;
 return 0;
 }
 ptr = bytes = (Pbyte*)s->str;
 max_bytes = s->len;
 res = PDCI_a2int8_max_bytes(bytes, max_bytes, &ptr);
 if (errno) return res;
 while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) {
 ptr++;
 }
 if (ptr - bytes != max_bytes) {
 errno = EINVAL;
 return 0;
 }
 return res;
 }
 Pint8 PDCI_a2int8_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0;
 Pint8 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return neg ? res : - res;
 }
Pint16 PDCI_a2int16(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint16 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 if (res < P_MIN_INT16_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT16 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT16 : P_MAX_INT16;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint16 PDCI_a2int16_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint16 res = 0;
 while (max_bytes > 0 && PDCI_is_a_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (*bytes == '+') {
 bytes++;
 max_bytes--;
 }
 else if (*bytes == '-') {
 bytes++;
 max_bytes--;
 neg = 1;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while (max_bytes > 0 && ((digit = PDCI_ascii_digit[*bytes]) != -1)) {
 if (res < P_MIN_INT16_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT16 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 max_bytes--;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT16 : P_MAX_INT16;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint16 Pstring2int16(const Pstring *s) {
 Pbyte *bytes, *ptr;
 size_t max_bytes;
 Pint16 res;
 if (!s) {
 errno = EINVAL;
 return 0;
 }
 ptr = bytes = (Pbyte*)s->str;
 max_bytes = s->len;
 res = PDCI_a2int16_max_bytes(bytes, max_bytes, &ptr);
 if (errno) return res;
 while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) {
 ptr++;
 }
 if (ptr - bytes != max_bytes) {
 errno = EINVAL;
 return 0;
 }
 return res;
 }
 Pint16 PDCI_a2int16_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0;
 Pint16 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return neg ? res : - res;
 }
Pint32 PDCI_a2int32(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint32 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 if (res < P_MIN_INT32_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT32 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT32 : P_MAX_INT32;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint32 PDCI_a2int32_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint32 res = 0;
 while (max_bytes > 0 && PDCI_is_a_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (*bytes == '+') {
 bytes++;
 max_bytes--;
 }
 else if (*bytes == '-') {
 bytes++;
 max_bytes--;
 neg = 1;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while (max_bytes > 0 && ((digit = PDCI_ascii_digit[*bytes]) != -1)) {
 if (res < P_MIN_INT32_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT32 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 max_bytes--;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT32 : P_MAX_INT32;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint32 Pstring2int32(const Pstring *s) {
 Pbyte *bytes, *ptr;
 size_t max_bytes;
 Pint32 res;
 if (!s) {
 errno = EINVAL;
 return 0;
 }
 ptr = bytes = (Pbyte*)s->str;
 max_bytes = s->len;
 res = PDCI_a2int32_max_bytes(bytes, max_bytes, &ptr);
 if (errno) return res;
 while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) {
 ptr++;
 }
 if (ptr - bytes != max_bytes) {
 errno = EINVAL;
 return 0;
 }
 return res;
 }
 Pint32 PDCI_a2int32_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0;
 Pint32 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return neg ? res : - res;
 }
Pint64 PDCI_a2int64(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint64 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 if (res < P_MIN_INT64_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT64 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT64 : P_MAX_INT64;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint64 PDCI_a2int64_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint64 res = 0;
 while (max_bytes > 0 && PDCI_is_a_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (*bytes == '+') {
 bytes++;
 max_bytes--;
 }
 else if (*bytes == '-') {
 bytes++;
 max_bytes--;
 neg = 1;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while (max_bytes > 0 && ((digit = PDCI_ascii_digit[*bytes]) != -1)) {
 if (res < P_MIN_INT64_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT64 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 max_bytes--;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT64 : P_MAX_INT64;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint64 Pstring2int64(const Pstring *s) {
 Pbyte *bytes, *ptr;
 size_t max_bytes;
 Pint64 res;
 if (!s) {
 errno = EINVAL;
 return 0;
 }
 ptr = bytes = (Pbyte*)s->str;
 max_bytes = s->len;
 res = PDCI_a2int64_max_bytes(bytes, max_bytes, &ptr);
 if (errno) return res;
 while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) {
 ptr++;
 }
 if (ptr - bytes != max_bytes) {
 errno = EINVAL;
 return 0;
 }
 return res;
 }
 Pint64 PDCI_a2int64_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0;
 Pint64 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return neg ? res : - res;
 }

Puint8 PDCI_a2uint8(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint8 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 range_err = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 if (res > P_MAX_UINT8_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT8 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT8;
 }
 errno = 0;
 return res;
 }
 Puint8 PDCI_a2uint8_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint8 res = 0;
 while (max_bytes > 0 && PDCI_is_a_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (*bytes == '+') {
 bytes++;
 max_bytes--;
 }
 else if (*bytes == '-') {
 bytes++;
 max_bytes--;
 range_err = 1;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while (max_bytes > 0 && ((digit = PDCI_ascii_digit[*bytes]) != -1)) {
 if (res > P_MAX_UINT8_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT8 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 max_bytes--;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT8;
 }
 errno = 0;
 return res;
 }
 Puint8 Pstring2uint8(const Pstring *s) {
 Pbyte *bytes, *ptr;
 size_t max_bytes;
 Puint8 res;
 if (!s) {
 errno = EINVAL;
 return 0;
 }
 ptr = bytes = (Pbyte*)s->str;
 max_bytes = s->len;
 res = PDCI_a2uint8_max_bytes(bytes, max_bytes, &ptr);
 if (errno) return res;
 while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) {
 ptr++;
 }
 if (ptr - bytes != max_bytes) {
 errno = EINVAL;
 return 0;
 }
 return res;
 }
 Puint8 PDCI_a2uint8_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 Puint8 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return res;
 }
Puint16 PDCI_a2uint16(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint16 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 range_err = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 if (res > P_MAX_UINT16_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT16 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT16;
 }
 errno = 0;
 return res;
 }
 Puint16 PDCI_a2uint16_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint16 res = 0;
 while (max_bytes > 0 && PDCI_is_a_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (*bytes == '+') {
 bytes++;
 max_bytes--;
 }
 else if (*bytes == '-') {
 bytes++;
 max_bytes--;
 range_err = 1;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while (max_bytes > 0 && ((digit = PDCI_ascii_digit[*bytes]) != -1)) {
 if (res > P_MAX_UINT16_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT16 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 max_bytes--;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT16;
 }
 errno = 0;
 return res;
 }
 Puint16 Pstring2uint16(const Pstring *s) {
 Pbyte *bytes, *ptr;
 size_t max_bytes;
 Puint16 res;
 if (!s) {
 errno = EINVAL;
 return 0;
 }
 ptr = bytes = (Pbyte*)s->str;
 max_bytes = s->len;
 res = PDCI_a2uint16_max_bytes(bytes, max_bytes, &ptr);
 if (errno) return res;
 while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) {
 ptr++;
 }
 if (ptr - bytes != max_bytes) {
 errno = EINVAL;
 return 0;
 }
 return res;
 }
 Puint16 PDCI_a2uint16_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 Puint16 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return res;
 }
Puint32 PDCI_a2uint32(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint32 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 range_err = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 if (res > P_MAX_UINT32_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT32 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT32;
 }
 errno = 0;
 return res;
 }
 Puint32 PDCI_a2uint32_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint32 res = 0;
 while (max_bytes > 0 && PDCI_is_a_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (*bytes == '+') {
 bytes++;
 max_bytes--;
 }
 else if (*bytes == '-') {
 bytes++;
 max_bytes--;
 range_err = 1;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while (max_bytes > 0 && ((digit = PDCI_ascii_digit[*bytes]) != -1)) {
 if (res > P_MAX_UINT32_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT32 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 max_bytes--;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT32;
 }
 errno = 0;
 return res;
 }
 Puint32 Pstring2uint32(const Pstring *s) {
 Pbyte *bytes, *ptr;
 size_t max_bytes;
 Puint32 res;
 if (!s) {
 errno = EINVAL;
 return 0;
 }
 ptr = bytes = (Pbyte*)s->str;
 max_bytes = s->len;
 res = PDCI_a2uint32_max_bytes(bytes, max_bytes, &ptr);
 if (errno) return res;
 while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) {
 ptr++;
 }
 if (ptr - bytes != max_bytes) {
 errno = EINVAL;
 return 0;
 }
 return res;
 }
 Puint32 PDCI_a2uint32_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 Puint32 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return res;
 }
Puint64 PDCI_a2uint64(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint64 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 else if (*bytes == '-') {
 bytes++;
 range_err = 1;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 if (res > P_MAX_UINT64_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT64 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT64;
 }
 errno = 0;
 return res;
 }
 Puint64 PDCI_a2uint64_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint64 res = 0;
 while (max_bytes > 0 && PDCI_is_a_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (*bytes == '+') {
 bytes++;
 max_bytes--;
 }
 else if (*bytes == '-') {
 bytes++;
 max_bytes--;
 range_err = 1;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while (max_bytes > 0 && ((digit = PDCI_ascii_digit[*bytes]) != -1)) {
 if (res > P_MAX_UINT64_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT64 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 max_bytes--;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT64;
 }
 errno = 0;
 return res;
 }
 Puint64 Pstring2uint64(const Pstring *s) {
 Pbyte *bytes, *ptr;
 size_t max_bytes;
 Puint64 res;
 if (!s) {
 errno = EINVAL;
 return 0;
 }
 ptr = bytes = (Pbyte*)s->str;
 max_bytes = s->len;
 res = PDCI_a2uint64_max_bytes(bytes, max_bytes, &ptr);
 if (errno) return res;
 while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) {
 ptr++;
 }
 if (ptr - bytes != max_bytes) {
 errno = EINVAL;
 return 0;
 }
 return res;
 }
 Puint64 PDCI_a2uint64_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 Puint64 res = 0;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 if (*bytes == '+') {
 bytes++;
 }
 if (!PDCI_is_a_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ascii_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return res;
 }

ssize_t PDCI_int8_2a_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint8 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT1_WRITE(writelen, pads->tmp1, "%I1d", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_int8_2a_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint8 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT1_WRITE(writelen, pads->tmp1, "%0.*I1d", width, i);
 if (writelen != width) {
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_int8_2a_io(P_t *pads, Sfio_t *io, Pint8 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_FMT_INT1_WRITE(writelen, io, "%I1d", i);
 return writelen;
 }
 ssize_t PDCI_int8_2a_FW_io(P_t *pads, Sfio_t *io, Pint8 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT1_WRITE(writelen, pads->tmp1, "%0.*I1d", width, i);
 if (writelen != width) {
 return -1;
 }
 return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen);
 }
ssize_t PDCI_int16_2a_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint16 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT_WRITE(writelen, pads->tmp1, "%I2d", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_int16_2a_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint16 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I2d", width, i);
 if (writelen != width) {
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_int16_2a_io(P_t *pads, Sfio_t *io, Pint16 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_FMT_INT_WRITE(writelen, io, "%I2d", i);
 return writelen;
 }
 ssize_t PDCI_int16_2a_FW_io(P_t *pads, Sfio_t *io, Pint16 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I2d", width, i);
 if (writelen != width) {
 return -1;
 }
 return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen);
 }
ssize_t PDCI_int32_2a_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint32 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT_WRITE(writelen, pads->tmp1, "%I4d", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_int32_2a_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint32 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I4d", width, i);
 if (writelen != width) {
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_int32_2a_io(P_t *pads, Sfio_t *io, Pint32 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_FMT_INT_WRITE(writelen, io, "%I4d", i);
 return writelen;
 }
 ssize_t PDCI_int32_2a_FW_io(P_t *pads, Sfio_t *io, Pint32 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I4d", width, i);
 if (writelen != width) {
 return -1;
 }
 return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen);
 }
ssize_t PDCI_int64_2a_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint64 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT_WRITE(writelen, pads->tmp1, "%I8d", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_int64_2a_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint64 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I8d", width, i);
 if (writelen != width) {
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_int64_2a_io(P_t *pads, Sfio_t *io, Pint64 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_FMT_INT_WRITE(writelen, io, "%I8d", i);
 return writelen;
 }
 ssize_t PDCI_int64_2a_FW_io(P_t *pads, Sfio_t *io, Pint64 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I8d", width, i);
 if (writelen != width) {
 return -1;
 }
 return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen);
 }

ssize_t PDCI_uint8_2a_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint8 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I1u", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_uint8_2a_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint8 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I1u", width, i);
 if (writelen != width) {
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_uint8_2a_io(P_t *pads, Sfio_t *io, Puint8 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_FMT_UINT_WRITE(writelen, io, "%I1u", i);
 return writelen;
 }
 ssize_t PDCI_uint8_2a_FW_io(P_t *pads, Sfio_t *io, Puint8 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I1u", width, i);
 if (writelen != width) {
 return -1;
 }
 return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen);
 }
ssize_t PDCI_uint16_2a_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint16 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I2u", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_uint16_2a_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint16 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I2u", width, i);
 if (writelen != width) {
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_uint16_2a_io(P_t *pads, Sfio_t *io, Puint16 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_FMT_UINT_WRITE(writelen, io, "%I2u", i);
 return writelen;
 }
 ssize_t PDCI_uint16_2a_FW_io(P_t *pads, Sfio_t *io, Puint16 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I2u", width, i);
 if (writelen != width) {
 return -1;
 }
 return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen);
 }
ssize_t PDCI_uint32_2a_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint32 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I4u", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_uint32_2a_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint32 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I4u", width, i);
 if (writelen != width) {
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_uint32_2a_io(P_t *pads, Sfio_t *io, Puint32 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_FMT_UINT_WRITE(writelen, io, "%I4u", i);
 return writelen;
 }
 ssize_t PDCI_uint32_2a_FW_io(P_t *pads, Sfio_t *io, Puint32 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I4u", width, i);
 if (writelen != width) {
 return -1;
 }
 return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen);
 }
ssize_t PDCI_uint64_2a_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint64 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I8u", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_uint64_2a_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint64 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I8u", width, i);
 if (writelen != width) {
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_uint64_2a_io(P_t *pads, Sfio_t *io, Puint64 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_FMT_UINT_WRITE(writelen, io, "%I8u", i);
 return writelen;
 }
 ssize_t PDCI_uint64_2a_FW_io(P_t *pads, Sfio_t *io, Puint64 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I8u", width, i);
 if (writelen != width) {
 return -1;
 }
 return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen);
 }

Pint8 PDCI_e2int8(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint8 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 if (res < P_MIN_INT8_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT8 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT8 : P_MAX_INT8;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint8 PDCI_e2int8_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0;
 Pint8 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return neg ? res : - res;
 }
Pint16 PDCI_e2int16(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint16 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 if (res < P_MIN_INT16_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT16 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT16 : P_MAX_INT16;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint16 PDCI_e2int16_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0;
 Pint16 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return neg ? res : - res;
 }
Pint32 PDCI_e2int32(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint32 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 if (res < P_MIN_INT32_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT32 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT32 : P_MAX_INT32;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint32 PDCI_e2int32_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0;
 Pint32 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return neg ? res : - res;
 }
Pint64 PDCI_e2int64(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0, range_err = 0;
 Pint64 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 if (res < P_MIN_INT64_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT64 + digit) {
 range_err = 1;
 }
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return neg ? P_MIN_INT64 : P_MAX_INT64;
 }
 errno = 0;
 return neg ? res : - res;
 }
 Pint64 PDCI_e2int64_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int neg = 0;
 Pint64 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 neg = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return neg ? res : - res;
 }

Puint8 PDCI_e2uint8(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint8 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 range_err = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 if (res > P_MAX_UINT8_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT8 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT8;
 }
 errno = 0;
 return res;
 }
 Puint8 PDCI_e2uint8_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 Puint8 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return res;
 }
Puint16 PDCI_e2uint16(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint16 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 range_err = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 if (res > P_MAX_UINT16_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT16 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT16;
 }
 errno = 0;
 return res;
 }
 Puint16 PDCI_e2uint16_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 Puint16 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return res;
 }
Puint32 PDCI_e2uint32(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint32 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 range_err = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 if (res > P_MAX_UINT32_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT32 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT32;
 }
 errno = 0;
 return res;
 }
 Puint32 PDCI_e2uint32_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 Puint32 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return res;
 }
Puint64 PDCI_e2uint64(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 int range_err = 0;
 Puint64 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 else if (*bytes == P_EBCDIC_MINUS) {
 bytes++;
 range_err = 1;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 if (res > P_MAX_UINT64_DIV10) {
 range_err = 1;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT64 - digit) {
 range_err = 1;
 }
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 if (range_err) {
 errno = ERANGE;
 return P_MAX_UINT64;
 }
 errno = 0;
 return res;
 }
 Puint64 PDCI_e2uint64_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 int digit;
 Puint64 res = 0;
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 if (*bytes == P_EBCDIC_PLUS) {
 bytes++;
 }
 if (!PDCI_is_e_digit(*bytes)) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 while ((digit = PDCI_ebcdic_digit[*bytes]) != -1) {
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 (*ptr_out) = (Pbyte*)bytes;
 errno = 0;
 return res;
 }

ssize_t PDCI_int8_2e_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint8 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT1_WRITE(writelen, pads->tmp1, "%I1d", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_int8_2e_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint8 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT1_WRITE(writelen, pads->tmp1, "%0.*I1d", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_int8_2e_io (P_t *pads, Sfio_t *io, Pint8 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT1_WRITE(writelen, pads->tmp1, "%I1d", i);
 if (-1 == writelen) return -1;
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
 ssize_t PDCI_int8_2e_FW_io (P_t *pads, Sfio_t *io, Pint8 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT1_WRITE(writelen, pads->tmp1, "%0.*I1d", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
ssize_t PDCI_int16_2e_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint16 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT_WRITE(writelen, pads->tmp1, "%I2d", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_int16_2e_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint16 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I2d", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_int16_2e_io (P_t *pads, Sfio_t *io, Pint16 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT_WRITE(writelen, pads->tmp1, "%I2d", i);
 if (-1 == writelen) return -1;
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
 ssize_t PDCI_int16_2e_FW_io (P_t *pads, Sfio_t *io, Pint16 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I2d", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
ssize_t PDCI_int32_2e_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint32 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT_WRITE(writelen, pads->tmp1, "%I4d", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_int32_2e_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint32 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I4d", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_int32_2e_io (P_t *pads, Sfio_t *io, Pint32 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT_WRITE(writelen, pads->tmp1, "%I4d", i);
 if (-1 == writelen) return -1;
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
 ssize_t PDCI_int32_2e_FW_io (P_t *pads, Sfio_t *io, Pint32 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I4d", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
ssize_t PDCI_int64_2e_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint64 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT_WRITE(writelen, pads->tmp1, "%I8d", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_int64_2e_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint64 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I8d", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_int64_2e_io (P_t *pads, Sfio_t *io, Pint64 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_INT_WRITE(writelen, pads->tmp1, "%I8d", i);
 if (-1 == writelen) return -1;
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
 ssize_t PDCI_int64_2e_FW_io (P_t *pads, Sfio_t *io, Pint64 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_INT_WRITE(writelen, pads->tmp1, "%0.*I8d", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }

ssize_t PDCI_uint8_2e_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint8 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I1u", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_uint8_2e_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint8 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I1u", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_uint8_2e_io (P_t *pads, Sfio_t *io, Puint8 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I1u", i);
 if (-1 == writelen) return -1;
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
 ssize_t PDCI_uint8_2e_FW_io (P_t *pads, Sfio_t *io, Puint8 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I1u", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
ssize_t PDCI_uint16_2e_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint16 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I2u", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_uint16_2e_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint16 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I2u", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_uint16_2e_io (P_t *pads, Sfio_t *io, Puint16 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I2u", i);
 if (-1 == writelen) return -1;
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
 ssize_t PDCI_uint16_2e_FW_io (P_t *pads, Sfio_t *io, Puint16 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I2u", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
ssize_t PDCI_uint32_2e_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint32 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I4u", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_uint32_2e_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint32 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I4u", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_uint32_2e_io (P_t *pads, Sfio_t *io, Puint32 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I4u", i);
 if (-1 == writelen) return -1;
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
 ssize_t PDCI_uint32_2e_FW_io (P_t *pads, Sfio_t *io, Puint32 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I4u", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
ssize_t PDCI_uint64_2e_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint64 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I8u", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_uint64_2e_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint64 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I8u", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_uint64_2e_io (P_t *pads, Sfio_t *io, Puint64 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_UINT_WRITE(writelen, pads->tmp1, "%I8u", i);
 if (-1 == writelen) return -1;
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
 ssize_t PDCI_uint64_2e_FW_io (P_t *pads, Sfio_t *io, Puint64 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_UINT_WRITE(writelen, pads->tmp1, "%0.*I8u", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }

ssize_t PDCI_int8_2b_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint8 i) {
 if (!outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 outbuf[0] = *((Pbyte*)(&i));
 errno = 0;
 return 1;
 }
 ssize_t PDCI_int8_2b_io(P_t *pads, Sfio_t *io, Pint8 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 errno = 0;
 return sfwrite(io, ibytes, 1);
 }
ssize_t PDCI_int16_2b_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint16 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 if (2 > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (pads->m_endian == pads->disc->d_endian) {
 memcpy(outbuf, ibytes, 2);
 }
 else {
 int n = 2;
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return 2;
 }
 ssize_t PDCI_int16_2b_io(P_t *pads, Sfio_t *io, Pint16 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 errno = 0;
 if (pads->m_endian == pads->disc->d_endian) {
 return sfwrite(io, ibytes, 2);
 }
 {
 Pbyte sb[2];
 int n = 2;
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, 2);
 }
 }
ssize_t PDCI_int32_2b_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint32 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 if (4 > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (pads->m_endian == pads->disc->d_endian) {
 memcpy(outbuf, ibytes, 4);
 }
 else {
 int n = 4;
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return 4;
 }
 ssize_t PDCI_int32_2b_io(P_t *pads, Sfio_t *io, Pint32 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 errno = 0;
 if (pads->m_endian == pads->disc->d_endian) {
 return sfwrite(io, ibytes, 4);
 }
 {
 Pbyte sb[4];
 int n = 4;
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, 4);
 }
 }
ssize_t PDCI_int64_2b_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint64 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 if (8 > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (pads->m_endian == pads->disc->d_endian) {
 memcpy(outbuf, ibytes, 8);
 }
 else {
 int n = 8;
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return 8;
 }
 ssize_t PDCI_int64_2b_io(P_t *pads, Sfio_t *io, Pint64 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 errno = 0;
 if (pads->m_endian == pads->disc->d_endian) {
 return sfwrite(io, ibytes, 8);
 }
 {
 Pbyte sb[8];
 int n = 8;
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, 8);
 }
 }
ssize_t PDCI_uint8_2b_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint8 i) {
 if (!outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 outbuf[0] = *((Pbyte*)(&i));
 errno = 0;
 return 1;
 }
 ssize_t PDCI_uint8_2b_io(P_t *pads, Sfio_t *io, Puint8 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 errno = 0;
 return sfwrite(io, ibytes, 1);
 }
ssize_t PDCI_uint16_2b_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint16 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 if (2 > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (pads->m_endian == pads->disc->d_endian) {
 memcpy(outbuf, ibytes, 2);
 }
 else {
 int n = 2;
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return 2;
 }
 ssize_t PDCI_uint16_2b_io(P_t *pads, Sfio_t *io, Puint16 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 errno = 0;
 if (pads->m_endian == pads->disc->d_endian) {
 return sfwrite(io, ibytes, 2);
 }
 {
 Pbyte sb[2];
 int n = 2;
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, 2);
 }
 }
ssize_t PDCI_uint32_2b_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint32 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 if (4 > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (pads->m_endian == pads->disc->d_endian) {
 memcpy(outbuf, ibytes, 4);
 }
 else {
 int n = 4;
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return 4;
 }
 ssize_t PDCI_uint32_2b_io(P_t *pads, Sfio_t *io, Puint32 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 errno = 0;
 if (pads->m_endian == pads->disc->d_endian) {
 return sfwrite(io, ibytes, 4);
 }
 {
 Pbyte sb[4];
 int n = 4;
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, 4);
 }
 }
ssize_t PDCI_uint64_2b_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint64 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 if (8 > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (pads->m_endian == pads->disc->d_endian) {
 memcpy(outbuf, ibytes, 8);
 }
 else {
 int n = 8;
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return 8;
 }
 ssize_t PDCI_uint64_2b_io(P_t *pads, Sfio_t *io, Puint64 i) {
 Pbyte *ibytes = (Pbyte*)(&i);
 errno = 0;
 if (pads->m_endian == pads->disc->d_endian) {
 return sfwrite(io, ibytes, 8);
 }
 {
 Pbyte sb[8];
 int n = 8;
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, 8);
 }
 }

Pint8 PDCI_ebc2int8(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Pint8 res = 0;
 int neg, digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 3) {
 errno = EDOM;
 return P_MIN_INT8;
 }
 neg = ((bytes[n-1]&0xF0) == 0xD0);
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT8_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT8 + digit) {
 goto range_err;
 }
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 range_err: errno = ERANGE;
 return neg ? P_MIN_INT8 : P_MAX_INT8;
 }
 Pint8 PDCI_ebc2int8_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Pint8 res = 0;
 int neg, digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 3) {
 errno = EDOM;
 return P_MIN_INT8;
 }
 neg = ((bytes[n-1]&0xF0) == 0xD0);
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 }
 ssize_t PDCI_int8_2ebc_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint8 i_in, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Pint8 lim;
 Pint16 i = i_in;
 if (num_digits > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 3) {
 errno = EDOM;
 return -1;
 }
 if (n < 3) {
 lim = PDCI_10toThe[n];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 if (i < 0) {
 i = -i;
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 ebc[num_digits-1] &= 0xDF;
 }
 else {
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 }
 errno = 0;
 memcpy(outbuf, ebc, num_digits);
 return num_digits;
 }
 ssize_t PDCI_int8_2ebc_io (P_t *pads, Sfio_t *io, Pint8 i_in, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Pint8 lim;
 Pint16 i = i_in;
 if (n == 0 || n > 3) {
 errno = EDOM;
 return -1;
 }
 if (n < 3) {
 lim = PDCI_10toThe[n];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 if (i < 0) {
 i = -i;
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 ebc[num_digits-1] &= 0xDF;
 }
 else {
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 }
 errno = 0;
 return sfwrite(io, ebc, num_digits);
 }
Pint16 PDCI_ebc2int16(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Pint16 res = 0;
 int neg, digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 5) {
 errno = EDOM;
 return P_MIN_INT16;
 }
 neg = ((bytes[n-1]&0xF0) == 0xD0);
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT16_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT16 + digit) {
 goto range_err;
 }
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 range_err: errno = ERANGE;
 return neg ? P_MIN_INT16 : P_MAX_INT16;
 }
 Pint16 PDCI_ebc2int16_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Pint16 res = 0;
 int neg, digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 5) {
 errno = EDOM;
 return P_MIN_INT16;
 }
 neg = ((bytes[n-1]&0xF0) == 0xD0);
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 }
 ssize_t PDCI_int16_2ebc_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint16 i_in, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Pint16 lim;
 Pint32 i = i_in;
 if (num_digits > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 5) {
 errno = EDOM;
 return -1;
 }
 if (n < 5) {
 lim = PDCI_10toThe[n];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 if (i < 0) {
 i = -i;
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 ebc[num_digits-1] &= 0xDF;
 }
 else {
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 }
 errno = 0;
 memcpy(outbuf, ebc, num_digits);
 return num_digits;
 }
 ssize_t PDCI_int16_2ebc_io (P_t *pads, Sfio_t *io, Pint16 i_in, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Pint16 lim;
 Pint32 i = i_in;
 if (n == 0 || n > 5) {
 errno = EDOM;
 return -1;
 }
 if (n < 5) {
 lim = PDCI_10toThe[n];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 if (i < 0) {
 i = -i;
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 ebc[num_digits-1] &= 0xDF;
 }
 else {
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 }
 errno = 0;
 return sfwrite(io, ebc, num_digits);
 }
Pint32 PDCI_ebc2int32(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Pint32 res = 0;
 int neg, digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 10) {
 errno = EDOM;
 return P_MIN_INT32;
 }
 neg = ((bytes[n-1]&0xF0) == 0xD0);
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT32_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT32 + digit) {
 goto range_err;
 }
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 range_err: errno = ERANGE;
 return neg ? P_MIN_INT32 : P_MAX_INT32;
 }
 Pint32 PDCI_ebc2int32_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Pint32 res = 0;
 int neg, digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 10) {
 errno = EDOM;
 return P_MIN_INT32;
 }
 neg = ((bytes[n-1]&0xF0) == 0xD0);
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 }
 ssize_t PDCI_int32_2ebc_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint32 i_in, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Pint32 lim;
 Pint64 i = i_in;
 if (num_digits > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 10) {
 errno = EDOM;
 return -1;
 }
 if (n < 10) {
 lim = PDCI_10toThe[n];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 if (i < 0) {
 i = -i;
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 ebc[num_digits-1] &= 0xDF;
 }
 else {
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 }
 errno = 0;
 memcpy(outbuf, ebc, num_digits);
 return num_digits;
 }
 ssize_t PDCI_int32_2ebc_io (P_t *pads, Sfio_t *io, Pint32 i_in, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Pint32 lim;
 Pint64 i = i_in;
 if (n == 0 || n > 10) {
 errno = EDOM;
 return -1;
 }
 if (n < 10) {
 lim = PDCI_10toThe[n];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 if (i < 0) {
 i = -i;
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 ebc[num_digits-1] &= 0xDF;
 }
 else {
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 }
 errno = 0;
 return sfwrite(io, ebc, num_digits);
 }
Pint64 PDCI_ebc2int64(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Pint64 res = 0;
 int neg, digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 19) {
 errno = EDOM;
 return P_MIN_INT64;
 }
 neg = ((bytes[n-1]&0xF0) == 0xD0);
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT64_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT64 + digit) {
 goto range_err;
 }
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 range_err: errno = ERANGE;
 return neg ? P_MIN_INT64 : P_MAX_INT64;
 }
 Pint64 PDCI_ebc2int64_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Pint64 res = 0;
 int neg, digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 19) {
 errno = EDOM;
 return P_MIN_INT64;
 }
 neg = ((bytes[n-1]&0xF0) == 0xD0);
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 }
 ssize_t PDCI_int64_2ebc_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint64 i_in, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Pint64 lim;
 Pint64 i = i_in;
 if (num_digits > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 19) {
 errno = EDOM;
 return -1;
 }
 if (n < 19) {
 lim = PDCI_10toThe[n];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 if (i < 0) {
 i = -i;
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 ebc[num_digits-1] &= 0xDF;
 }
 else {
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 }
 errno = 0;
 memcpy(outbuf, ebc, num_digits);
 return num_digits;
 }
 ssize_t PDCI_int64_2ebc_io (P_t *pads, Sfio_t *io, Pint64 i_in, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Pint64 lim;
 Pint64 i = i_in;
 if (n == 0 || n > 19) {
 errno = EDOM;
 return -1;
 }
 if (n < 19) {
 lim = PDCI_10toThe[n];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 if (i < 0) {
 i = -i;
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 ebc[num_digits-1] &= 0xDF;
 }
 else {
 while (--n >= 0) {
 ebc[n] = 0xF0 | (i % 10);
 i /= 10;
 }
 }
 errno = 0;
 return sfwrite(io, ebc, num_digits);
 }

Puint8 PDCI_ebc2uint8(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Puint8 res = 0;
 int digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 3) {
 errno = EDOM;
 return P_MAX_UINT8;
 }
 if ((bytes[n-1]&0xF0) == 0xD0) {
 goto range_err;
 }
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT8_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT8 - digit) {
 goto range_err;
 }
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 range_err: errno = ERANGE;
 return P_MAX_UINT8;
 }
 Puint8 PDCI_ebc2uint8_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Puint8 res = 0;
 int digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 3) {
 errno = EDOM;
 return P_MAX_UINT8;
 }
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 }
 ssize_t PDCI_uint8_2ebc_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint8 u, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Puint8 lim;
 if (num_digits > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 3) {
 errno = EDOM;
 return -1;
 }
 if (n < 3) {
 lim = PDCI_10toThe[n];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 while (--n >= 0) {
 ebc[n] = 0xF0 | (u % 10);
 u /= 10;
 }
 errno = 0;
 memcpy(outbuf, ebc, num_digits);
 return num_digits;
 }
 ssize_t PDCI_uint8_2ebc_io (P_t *pads, Sfio_t *io, Puint8 u, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Puint8 lim;
 if (n == 0 || n > 3) {
 errno = EDOM;
 return -1;
 }
 if (n < 3) {
 lim = PDCI_10toThe[n];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 while (--n >= 0) {
 ebc[n] = 0xF0 | (u % 10);
 u /= 10;
 }
 errno = 0;
 return sfwrite(io, ebc, num_digits);
 }
Puint16 PDCI_ebc2uint16(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Puint16 res = 0;
 int digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 5) {
 errno = EDOM;
 return P_MAX_UINT16;
 }
 if ((bytes[n-1]&0xF0) == 0xD0) {
 goto range_err;
 }
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT16_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT16 - digit) {
 goto range_err;
 }
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 range_err: errno = ERANGE;
 return P_MAX_UINT16;
 }
 Puint16 PDCI_ebc2uint16_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Puint16 res = 0;
 int digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 5) {
 errno = EDOM;
 return P_MAX_UINT16;
 }
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 }
 ssize_t PDCI_uint16_2ebc_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint16 u, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Puint16 lim;
 if (num_digits > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 5) {
 errno = EDOM;
 return -1;
 }
 if (n < 5) {
 lim = PDCI_10toThe[n];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 while (--n >= 0) {
 ebc[n] = 0xF0 | (u % 10);
 u /= 10;
 }
 errno = 0;
 memcpy(outbuf, ebc, num_digits);
 return num_digits;
 }
 ssize_t PDCI_uint16_2ebc_io (P_t *pads, Sfio_t *io, Puint16 u, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Puint16 lim;
 if (n == 0 || n > 5) {
 errno = EDOM;
 return -1;
 }
 if (n < 5) {
 lim = PDCI_10toThe[n];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 while (--n >= 0) {
 ebc[n] = 0xF0 | (u % 10);
 u /= 10;
 }
 errno = 0;
 return sfwrite(io, ebc, num_digits);
 }
Puint32 PDCI_ebc2uint32(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Puint32 res = 0;
 int digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 10) {
 errno = EDOM;
 return P_MAX_UINT32;
 }
 if ((bytes[n-1]&0xF0) == 0xD0) {
 goto range_err;
 }
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT32_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT32 - digit) {
 goto range_err;
 }
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 range_err: errno = ERANGE;
 return P_MAX_UINT32;
 }
 Puint32 PDCI_ebc2uint32_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Puint32 res = 0;
 int digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 10) {
 errno = EDOM;
 return P_MAX_UINT32;
 }
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 }
 ssize_t PDCI_uint32_2ebc_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint32 u, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Puint32 lim;
 if (num_digits > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 10) {
 errno = EDOM;
 return -1;
 }
 if (n < 10) {
 lim = PDCI_10toThe[n];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 while (--n >= 0) {
 ebc[n] = 0xF0 | (u % 10);
 u /= 10;
 }
 errno = 0;
 memcpy(outbuf, ebc, num_digits);
 return num_digits;
 }
 ssize_t PDCI_uint32_2ebc_io (P_t *pads, Sfio_t *io, Puint32 u, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Puint32 lim;
 if (n == 0 || n > 10) {
 errno = EDOM;
 return -1;
 }
 if (n < 10) {
 lim = PDCI_10toThe[n];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 while (--n >= 0) {
 ebc[n] = 0xF0 | (u % 10);
 u /= 10;
 }
 errno = 0;
 return sfwrite(io, ebc, num_digits);
 }
Puint64 PDCI_ebc2uint64(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Puint64 res = 0;
 int digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 20) {
 errno = EDOM;
 return P_MAX_UINT64;
 }
 if ((bytes[n-1]&0xF0) == 0xD0) {
 goto range_err;
 }
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT64_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT64 - digit) {
 goto range_err;
 }
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 range_err: errno = ERANGE;
 return P_MAX_UINT64;
 }
 Puint64 PDCI_ebc2uint64_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 Pint32 n = num_digits;
 Puint64 res = 0;
 int digit;
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 20) {
 errno = EDOM;
 return P_MAX_UINT64;
 }
 while (--n >= 0) {
 if ((digit = (0xF & *bytes)) > 9) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 }
 ssize_t PDCI_uint64_2ebc_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint64 u, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Puint64 lim;
 if (num_digits > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 20) {
 errno = EDOM;
 return -1;
 }
 if (n < 20) {
 lim = PDCI_10toThe[n];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 while (--n >= 0) {
 ebc[n] = 0xF0 | (u % 10);
 u /= 10;
 }
 errno = 0;
 memcpy(outbuf, ebc, num_digits);
 return num_digits;
 }
 ssize_t PDCI_uint64_2ebc_io (P_t *pads, Sfio_t *io, Puint64 u, Puint32 num_digits) {
 Pint32 n = num_digits;
 Pbyte ebc[30];
 Puint64 lim;
 if (n == 0 || n > 20) {
 errno = EDOM;
 return -1;
 }
 if (n < 20) {
 lim = PDCI_10toThe[n];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 while (--n >= 0) {
 ebc[n] = 0xF0 | (u % 10);
 u /= 10;
 }
 errno = 0;
 return sfwrite(io, ebc, num_digits);
 }

Pint8 PDCI_bcd2int8(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 int neg = 0;
 Pint32 num_bytes = ((num_digits+2)/2);
 Pint8 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 neg = ((num_digits % 2 == 1) && ((bytes[num_bytes-1]&0xF) == 0xD));
 if (num_digits == 0 || num_digits > 3) {
 errno = EDOM;
 return P_MIN_INT8;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT8_DIV100) {
 goto range_err;
 }
 res *= 100;
 if (res < P_MIN_INT8 + two_digits) {
 goto range_err;
 }
 res -= two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT8_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT8 + digit) {
 goto range_err;
 }
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 range_err: errno = ERANGE;
 return neg ? P_MIN_INT8 : P_MAX_INT8;
 }
 Pint8 PDCI_bcd2int8_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 int neg = 0;
 Pint32 num_bytes = ((num_digits+2)/2);
 Pint8 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 neg = ((num_digits % 2 == 1) && ((bytes[num_bytes-1]&0xF) == 0xD));
 if (num_digits == 0 || num_digits > 3) {
 errno = EDOM;
 return P_MIN_INT8;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 res *= 100;
 res -= two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 }
 ssize_t PDCI_int8_2bcd_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint8 i_in, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 int odd_digits = (num_digits % 2 == 1);
 Pint8 lim;
 Pint16 i = i_in;
 num_bytes = ((num_digits+2)/2);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (num_digits == 0 || num_digits > 3) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 3) {
 lim = PDCI_10toThe[num_digits];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 n = num_bytes - 1;
 if (i < 0) {
 if (!odd_digits) {
 errno = EDOM;
 return -1;
 }
 i = -i;
 bcd[n--] = ((i%10)<<4) | 0xD;
 i /= 10;
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 else {
 if (odd_digits) {
 bcd[n--] = ((i%10)<<4);
 i /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 errno = 0;
 memcpy(outbuf, bcd, num_bytes);
 return num_bytes;
 }
 ssize_t PDCI_int8_2bcd_io (P_t *pads, Sfio_t *io, Pint8 i_in, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 int odd_digits = (num_digits % 2 == 1);
 Pint8 lim;
 Pint16 i = i_in;
 if (num_digits == 0 || num_digits > 3) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 3) {
 lim = PDCI_10toThe[num_digits];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 num_bytes = ((num_digits+2)/2);
 n = num_bytes - 1;
 if (i < 0) {
 if (!odd_digits) {
 errno = EDOM;
 return -1;
 }
 i = -i;
 bcd[n--] = ((i%10)<<4) | 0xD;
 i /= 10;
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 else {
 if (odd_digits) {
 bcd[n--] = ((i%10)<<4);
 i /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 errno = 0;
 return sfwrite(io, bcd, num_bytes);
 }
Pint16 PDCI_bcd2int16(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 int neg = 0;
 Pint32 num_bytes = ((num_digits+2)/2);
 Pint16 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 neg = ((num_digits % 2 == 1) && ((bytes[num_bytes-1]&0xF) == 0xD));
 if (num_digits == 0 || num_digits > 5) {
 errno = EDOM;
 return P_MIN_INT16;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT16_DIV100) {
 goto range_err;
 }
 res *= 100;
 if (res < P_MIN_INT16 + two_digits) {
 goto range_err;
 }
 res -= two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT16_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT16 + digit) {
 goto range_err;
 }
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 range_err: errno = ERANGE;
 return neg ? P_MIN_INT16 : P_MAX_INT16;
 }
 Pint16 PDCI_bcd2int16_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 int neg = 0;
 Pint32 num_bytes = ((num_digits+2)/2);
 Pint16 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 neg = ((num_digits % 2 == 1) && ((bytes[num_bytes-1]&0xF) == 0xD));
 if (num_digits == 0 || num_digits > 5) {
 errno = EDOM;
 return P_MIN_INT16;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 res *= 100;
 res -= two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 }
 ssize_t PDCI_int16_2bcd_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint16 i_in, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 int odd_digits = (num_digits % 2 == 1);
 Pint16 lim;
 Pint32 i = i_in;
 num_bytes = ((num_digits+2)/2);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (num_digits == 0 || num_digits > 5) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 5) {
 lim = PDCI_10toThe[num_digits];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 n = num_bytes - 1;
 if (i < 0) {
 if (!odd_digits) {
 errno = EDOM;
 return -1;
 }
 i = -i;
 bcd[n--] = ((i%10)<<4) | 0xD;
 i /= 10;
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 else {
 if (odd_digits) {
 bcd[n--] = ((i%10)<<4);
 i /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 errno = 0;
 memcpy(outbuf, bcd, num_bytes);
 return num_bytes;
 }
 ssize_t PDCI_int16_2bcd_io (P_t *pads, Sfio_t *io, Pint16 i_in, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 int odd_digits = (num_digits % 2 == 1);
 Pint16 lim;
 Pint32 i = i_in;
 if (num_digits == 0 || num_digits > 5) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 5) {
 lim = PDCI_10toThe[num_digits];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 num_bytes = ((num_digits+2)/2);
 n = num_bytes - 1;
 if (i < 0) {
 if (!odd_digits) {
 errno = EDOM;
 return -1;
 }
 i = -i;
 bcd[n--] = ((i%10)<<4) | 0xD;
 i /= 10;
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 else {
 if (odd_digits) {
 bcd[n--] = ((i%10)<<4);
 i /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 errno = 0;
 return sfwrite(io, bcd, num_bytes);
 }
Pint32 PDCI_bcd2int32(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 int neg = 0;
 Pint32 num_bytes = ((num_digits+2)/2);
 Pint32 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 neg = ((num_digits % 2 == 1) && ((bytes[num_bytes-1]&0xF) == 0xD));
 if (num_digits == 0 || num_digits > 11) {
 errno = EDOM;
 return P_MIN_INT32;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT32_DIV100) {
 goto range_err;
 }
 res *= 100;
 if (res < P_MIN_INT32 + two_digits) {
 goto range_err;
 }
 res -= two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT32_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT32 + digit) {
 goto range_err;
 }
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 range_err: errno = ERANGE;
 return neg ? P_MIN_INT32 : P_MAX_INT32;
 }
 Pint32 PDCI_bcd2int32_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 int neg = 0;
 Pint32 num_bytes = ((num_digits+2)/2);
 Pint32 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 neg = ((num_digits % 2 == 1) && ((bytes[num_bytes-1]&0xF) == 0xD));
 if (num_digits == 0 || num_digits > 11) {
 errno = EDOM;
 return P_MIN_INT32;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 res *= 100;
 res -= two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 }
 ssize_t PDCI_int32_2bcd_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint32 i_in, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 int odd_digits = (num_digits % 2 == 1);
 Pint32 lim;
 Pint64 i = i_in;
 num_bytes = ((num_digits+2)/2);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (num_digits == 0 || num_digits > 11) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 10) {
 lim = PDCI_10toThe[num_digits];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 n = num_bytes - 1;
 if (i < 0) {
 if (!odd_digits) {
 errno = EDOM;
 return -1;
 }
 i = -i;
 bcd[n--] = ((i%10)<<4) | 0xD;
 i /= 10;
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 else {
 if (odd_digits) {
 bcd[n--] = ((i%10)<<4);
 i /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 errno = 0;
 memcpy(outbuf, bcd, num_bytes);
 return num_bytes;
 }
 ssize_t PDCI_int32_2bcd_io (P_t *pads, Sfio_t *io, Pint32 i_in, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 int odd_digits = (num_digits % 2 == 1);
 Pint32 lim;
 Pint64 i = i_in;
 if (num_digits == 0 || num_digits > 11) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 10) {
 lim = PDCI_10toThe[num_digits];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 num_bytes = ((num_digits+2)/2);
 n = num_bytes - 1;
 if (i < 0) {
 if (!odd_digits) {
 errno = EDOM;
 return -1;
 }
 i = -i;
 bcd[n--] = ((i%10)<<4) | 0xD;
 i /= 10;
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 else {
 if (odd_digits) {
 bcd[n--] = ((i%10)<<4);
 i /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 errno = 0;
 return sfwrite(io, bcd, num_bytes);
 }
Pint64 PDCI_bcd2int64(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 int neg = 0;
 Pint32 num_bytes = ((num_digits+2)/2);
 Pint64 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 neg = ((num_digits % 2 == 1) && ((bytes[num_bytes-1]&0xF) == 0xD));
 if (num_digits == 0 || num_digits > 19) {
 errno = EDOM;
 return P_MIN_INT64;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT64_DIV100) {
 goto range_err;
 }
 res *= 100;
 if (res < P_MIN_INT64 + two_digits) {
 goto range_err;
 }
 res -= two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 if (res < P_MIN_INT64_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res < P_MIN_INT64 + digit) {
 goto range_err;
 }
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 range_err: errno = ERANGE;
 return neg ? P_MIN_INT64 : P_MAX_INT64;
 }
 Pint64 PDCI_bcd2int64_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 int neg = 0;
 Pint32 num_bytes = ((num_digits+2)/2);
 Pint64 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 neg = ((num_digits % 2 == 1) && ((bytes[num_bytes-1]&0xF) == 0xD));
 if (num_digits == 0 || num_digits > 19) {
 errno = EDOM;
 return P_MIN_INT64;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 res *= 100;
 res -= two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res -= digit;
 bytes++;
 }
 errno = 0;
 return neg ? res : - res;
 }
 ssize_t PDCI_int64_2bcd_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint64 i_in, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 int odd_digits = (num_digits % 2 == 1);
 Pint64 lim;
 Pint64 i = i_in;
 num_bytes = ((num_digits+2)/2);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (num_digits == 0 || num_digits > 19) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 19) {
 lim = PDCI_10toThe[num_digits];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 n = num_bytes - 1;
 if (i < 0) {
 if (!odd_digits) {
 errno = EDOM;
 return -1;
 }
 i = -i;
 bcd[n--] = ((i%10)<<4) | 0xD;
 i /= 10;
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 else {
 if (odd_digits) {
 bcd[n--] = ((i%10)<<4);
 i /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 errno = 0;
 memcpy(outbuf, bcd, num_bytes);
 return num_bytes;
 }
 ssize_t PDCI_int64_2bcd_io (P_t *pads, Sfio_t *io, Pint64 i_in, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 int odd_digits = (num_digits % 2 == 1);
 Pint64 lim;
 Pint64 i = i_in;
 if (num_digits == 0 || num_digits > 19) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 19) {
 lim = PDCI_10toThe[num_digits];
 if (i >= lim || (-i) >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 num_bytes = ((num_digits+2)/2);
 n = num_bytes - 1;
 if (i < 0) {
 if (!odd_digits) {
 errno = EDOM;
 return -1;
 }
 i = -i;
 bcd[n--] = ((i%10)<<4) | 0xD;
 i /= 10;
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 else {
 if (odd_digits) {
 bcd[n--] = ((i%10)<<4);
 i /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = i % 100;
 i /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 }
 errno = 0;
 return sfwrite(io, bcd, num_bytes);
 }

Puint8 PDCI_bcd2uint8(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 Pint32 num_bytes = ((num_digits+2)/2);
 Puint8 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (num_digits == 0 || num_digits > 3) {
 errno = EDOM;
 return P_MAX_UINT8;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT8_DIV100) {
 goto range_err;
 }
 res *= 100;
 if (res > P_MAX_UINT8 - two_digits) {
 goto range_err;
 }
 res += two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT8_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT8 - digit) {
 goto range_err;
 }
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 range_err: errno = ERANGE;
 return P_MAX_UINT8;
 }
 Puint8 PDCI_bcd2uint8_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 Pint32 num_bytes = ((num_digits+2)/2);
 Puint8 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (num_digits == 0 || num_digits > 3) {
 errno = EDOM;
 return P_MAX_UINT8;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 res *= 100;
 res += two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 }
 ssize_t PDCI_uint8_2bcd_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint8 u, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 Puint8 lim;
 num_bytes = ((num_digits+2)/2);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (num_digits == 0 || num_digits > 3) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 3) {
 lim = PDCI_10toThe[num_digits];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 n = num_bytes - 1;
 if (num_digits % 2 == 1) {
 bcd[n--] = ((u%10)<<4);
 u /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = u % 100;
 u /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 errno = 0;
 memcpy(outbuf, bcd, num_bytes);
 return num_bytes;
 }
 ssize_t PDCI_uint8_2bcd_io (P_t *pads, Sfio_t *io, Puint8 u, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 Puint8 lim;
 if (num_digits == 0 || num_digits > 3) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 3) {
 lim = PDCI_10toThe[num_digits];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 num_bytes = ((num_digits+2)/2);
 n = num_bytes - 1;
 if (num_digits % 2 == 1) {
 bcd[n--] = ((u%10)<<4);
 u /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = u % 100;
 u /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 errno = 0;
 return sfwrite(io, bcd, num_bytes);
 }
Puint16 PDCI_bcd2uint16(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 Pint32 num_bytes = ((num_digits+2)/2);
 Puint16 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (num_digits == 0 || num_digits > 5) {
 errno = EDOM;
 return P_MAX_UINT16;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT16_DIV100) {
 goto range_err;
 }
 res *= 100;
 if (res > P_MAX_UINT16 - two_digits) {
 goto range_err;
 }
 res += two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT16_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT16 - digit) {
 goto range_err;
 }
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 range_err: errno = ERANGE;
 return P_MAX_UINT16;
 }
 Puint16 PDCI_bcd2uint16_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 Pint32 num_bytes = ((num_digits+2)/2);
 Puint16 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (num_digits == 0 || num_digits > 5) {
 errno = EDOM;
 return P_MAX_UINT16;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 res *= 100;
 res += two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 }
 ssize_t PDCI_uint16_2bcd_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint16 u, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 Puint16 lim;
 num_bytes = ((num_digits+2)/2);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (num_digits == 0 || num_digits > 5) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 5) {
 lim = PDCI_10toThe[num_digits];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 n = num_bytes - 1;
 if (num_digits % 2 == 1) {
 bcd[n--] = ((u%10)<<4);
 u /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = u % 100;
 u /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 errno = 0;
 memcpy(outbuf, bcd, num_bytes);
 return num_bytes;
 }
 ssize_t PDCI_uint16_2bcd_io (P_t *pads, Sfio_t *io, Puint16 u, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 Puint16 lim;
 if (num_digits == 0 || num_digits > 5) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 5) {
 lim = PDCI_10toThe[num_digits];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 num_bytes = ((num_digits+2)/2);
 n = num_bytes - 1;
 if (num_digits % 2 == 1) {
 bcd[n--] = ((u%10)<<4);
 u /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = u % 100;
 u /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 errno = 0;
 return sfwrite(io, bcd, num_bytes);
 }
Puint32 PDCI_bcd2uint32(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 Pint32 num_bytes = ((num_digits+2)/2);
 Puint32 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (num_digits == 0 || num_digits > 10) {
 errno = EDOM;
 return P_MAX_UINT32;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT32_DIV100) {
 goto range_err;
 }
 res *= 100;
 if (res > P_MAX_UINT32 - two_digits) {
 goto range_err;
 }
 res += two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT32_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT32 - digit) {
 goto range_err;
 }
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 range_err: errno = ERANGE;
 return P_MAX_UINT32;
 }
 Puint32 PDCI_bcd2uint32_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 Pint32 num_bytes = ((num_digits+2)/2);
 Puint32 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (num_digits == 0 || num_digits > 10) {
 errno = EDOM;
 return P_MAX_UINT32;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 res *= 100;
 res += two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 }
 ssize_t PDCI_uint32_2bcd_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint32 u, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 Puint32 lim;
 num_bytes = ((num_digits+2)/2);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (num_digits == 0 || num_digits > 10) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 10) {
 lim = PDCI_10toThe[num_digits];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 n = num_bytes - 1;
 if (num_digits % 2 == 1) {
 bcd[n--] = ((u%10)<<4);
 u /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = u % 100;
 u /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 errno = 0;
 memcpy(outbuf, bcd, num_bytes);
 return num_bytes;
 }
 ssize_t PDCI_uint32_2bcd_io (P_t *pads, Sfio_t *io, Puint32 u, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 Puint32 lim;
 if (num_digits == 0 || num_digits > 10) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 10) {
 lim = PDCI_10toThe[num_digits];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 num_bytes = ((num_digits+2)/2);
 n = num_bytes - 1;
 if (num_digits % 2 == 1) {
 bcd[n--] = ((u%10)<<4);
 u /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = u % 100;
 u /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 errno = 0;
 return sfwrite(io, bcd, num_bytes);
 }
Puint64 PDCI_bcd2uint64(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 Pint32 num_bytes = ((num_digits+2)/2);
 Puint64 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (num_digits == 0 || num_digits > 20) {
 errno = EDOM;
 return P_MAX_UINT64;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT64_DIV100) {
 goto range_err;
 }
 res *= 100;
 if (res > P_MAX_UINT64 - two_digits) {
 goto range_err;
 }
 res += two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 if (res > P_MAX_UINT64_DIV10) {
 goto range_err;
 }
 res = (res << 3) + (res << 1);
 if (res > P_MAX_UINT64 - digit) {
 goto range_err;
 }
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 range_err: errno = ERANGE;
 return P_MAX_UINT64;
 }
 Puint64 PDCI_bcd2uint64_norange(const Pbyte *bytes, Puint32 num_digits, Pbyte **ptr_out) {
 int digit, two_digits;
 Pint32 num_bytes = ((num_digits+2)/2);
 Puint64 res = 0;
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (num_digits == 0 || num_digits > 20) {
 errno = EDOM;
 return P_MAX_UINT64;
 }
 while (num_digits >= 2) {
 if (-1 == (two_digits = PDCI_bcd_hilo_digits[*bytes])) {
 (*ptr_out) = (Pbyte*)bytes;
 errno = EINVAL;
 return 0;
 }
 res *= 100;
 res += two_digits;
 bytes++;
 num_digits -= 2;
 }
 if (num_digits) {
 if (-1 == (digit = PDCI_bcd_hi_digit[*bytes])) {
 errno = EINVAL;
 return 0;
 }
 res = (res << 3) + (res << 1);
 res += digit;
 bytes++;
 }
 errno = 0;
 return res;
 }
 ssize_t PDCI_uint64_2bcd_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint64 u, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 Puint64 lim;
 num_bytes = ((num_digits+2)/2);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (num_digits == 0 || num_digits > 20) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 20) {
 lim = PDCI_10toThe[num_digits];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 n = num_bytes - 1;
 if (num_digits % 2 == 1) {
 bcd[n--] = ((u%10)<<4);
 u /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = u % 100;
 u /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 errno = 0;
 memcpy(outbuf, bcd, num_bytes);
 return num_bytes;
 }
 ssize_t PDCI_uint64_2bcd_io (P_t *pads, Sfio_t *io, Puint64 u, Puint32 num_digits) {
 Pbyte bcd[30];
 Pint32 num_bytes;
 int x, n;
 Puint64 lim;
 if (num_digits == 0 || num_digits > 20) {
 errno = EDOM;
 return -1;
 }
 if (num_digits < 20) {
 lim = PDCI_10toThe[num_digits];
 if (u >= lim) {
 errno = ERANGE;
 return -1;
 }
 }
 num_bytes = ((num_digits+2)/2);
 n = num_bytes - 1;
 if (num_digits % 2 == 1) {
 bcd[n--] = ((u%10)<<4);
 u /= 10;
 }
 else {
 bcd[n--] = 0;
 }
 while (n >= 0) {
 x = u % 100;
 u /= 100;
 bcd[n--] = (x%10) | ((x/10)<<4);
 }
 errno = 0;
 return sfwrite(io, bcd, num_bytes);
 }

Pint8 PDCI_sbl2int8(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Pint8 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (n == 0 || n > 1) {
 errno = EDOM;
 return P_MIN_INT8;
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(resbytes , bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((1 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_int8_2sbl_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint8 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((1 - num_bytes) * 8);
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(outbuf, ibytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_int8_2sbl_io (P_t *pads, Sfio_t *io, Pint8 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((1 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PlittleEndian) {
 return sfwrite(io, ibytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Pint16 PDCI_sbl2int16(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Pint16 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (n == 0 || n > 2) {
 errno = EDOM;
 return P_MIN_INT16;
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(resbytes , bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((2 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_int16_2sbl_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint16 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((2 - num_bytes) * 8);
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(outbuf, ibytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_int16_2sbl_io (P_t *pads, Sfio_t *io, Pint16 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((2 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PlittleEndian) {
 return sfwrite(io, ibytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Pint32 PDCI_sbl2int32(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Pint32 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (n == 0 || n > 4) {
 errno = EDOM;
 return P_MIN_INT32;
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(resbytes , bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((4 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_int32_2sbl_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint32 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((4 - num_bytes) * 8);
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(outbuf, ibytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_int32_2sbl_io (P_t *pads, Sfio_t *io, Pint32 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((4 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PlittleEndian) {
 return sfwrite(io, ibytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Pint64 PDCI_sbl2int64(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Pint64 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (n == 0 || n > 8) {
 errno = EDOM;
 return P_MIN_INT64;
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(resbytes , bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((8 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_int64_2sbl_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint64 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((8 - num_bytes) * 8);
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(outbuf, ibytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_int64_2sbl_io (P_t *pads, Sfio_t *io, Pint64 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((8 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PlittleEndian) {
 return sfwrite(io, ibytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }

Puint8 PDCI_sbl2uint8(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Puint8 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 1) {
 errno = EDOM;
 return P_MAX_UINT8;
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(resbytes, bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((1 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_uint8_2sbl_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint8 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((1 - num_bytes) * 8);
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(outbuf, ubytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ubytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_uint8_2sbl_io (P_t *pads, Sfio_t *io, Puint8 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((1 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PlittleEndian) {
 return sfwrite(io, ubytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ubytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Puint16 PDCI_sbl2uint16(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Puint16 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 2) {
 errno = EDOM;
 return P_MAX_UINT16;
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(resbytes, bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((2 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_uint16_2sbl_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint16 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((2 - num_bytes) * 8);
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(outbuf, ubytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ubytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_uint16_2sbl_io (P_t *pads, Sfio_t *io, Puint16 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((2 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PlittleEndian) {
 return sfwrite(io, ubytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ubytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Puint32 PDCI_sbl2uint32(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Puint32 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 4) {
 errno = EDOM;
 return P_MAX_UINT32;
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(resbytes, bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((4 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_uint32_2sbl_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint32 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((4 - num_bytes) * 8);
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(outbuf, ubytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ubytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_uint32_2sbl_io (P_t *pads, Sfio_t *io, Puint32 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((4 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PlittleEndian) {
 return sfwrite(io, ubytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ubytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Puint64 PDCI_sbl2uint64(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Puint64 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 8) {
 errno = EDOM;
 return P_MAX_UINT64;
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(resbytes, bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((8 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_uint64_2sbl_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint64 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((8 - num_bytes) * 8);
 }
 if (pads->m_endian == PlittleEndian) {
 memcpy(outbuf, ubytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ubytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_uint64_2sbl_io (P_t *pads, Sfio_t *io, Puint64 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((8 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PlittleEndian) {
 return sfwrite(io, ubytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ubytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }

Pint8 PDCI_sbh2int8(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Pint8 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (n == 0 || n > 1) {
 errno = EDOM;
 return P_MIN_INT8;
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(resbytes , bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((1 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_int8_2sbh_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint8 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((1 - num_bytes) * 8);
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(outbuf, ibytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_int8_2sbh_io (P_t *pads, Sfio_t *io, Pint8 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((1 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PbigEndian) {
 return sfwrite(io, ibytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Pint16 PDCI_sbh2int16(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Pint16 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (n == 0 || n > 2) {
 errno = EDOM;
 return P_MIN_INT16;
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(resbytes , bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((2 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_int16_2sbh_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint16 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((2 - num_bytes) * 8);
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(outbuf, ibytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_int16_2sbh_io (P_t *pads, Sfio_t *io, Pint16 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((2 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PbigEndian) {
 return sfwrite(io, ibytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Pint32 PDCI_sbh2int32(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Pint32 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (n == 0 || n > 4) {
 errno = EDOM;
 return P_MIN_INT32;
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(resbytes , bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((4 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_int32_2sbh_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint32 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((4 - num_bytes) * 8);
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(outbuf, ibytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_int32_2sbh_io (P_t *pads, Sfio_t *io, Pint32 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((4 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PbigEndian) {
 return sfwrite(io, ibytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Pint64 PDCI_sbh2int64(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Pint64 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + num_bytes;
 if (n == 0 || n > 8) {
 errno = EDOM;
 return P_MIN_INT64;
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(resbytes , bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((8 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_int64_2sbh_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pint64 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((8 - num_bytes) * 8);
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(outbuf, ibytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ibytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_int64_2sbh_io (P_t *pads, Sfio_t *io, Pint64 i, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ibytes = (Pbyte*)(&i);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (i > P_MAX_FOR_NB[n] || i < P_MIN_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 i <<= ((8 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PbigEndian) {
 return sfwrite(io, ibytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ibytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }

Puint8 PDCI_sbh2uint8(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Puint8 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 1) {
 errno = EDOM;
 return P_MAX_UINT8;
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(resbytes, bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((1 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_uint8_2sbh_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint8 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((1 - num_bytes) * 8);
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(outbuf, ubytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ubytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_uint8_2sbh_io (P_t *pads, Sfio_t *io, Puint8 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((1 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PbigEndian) {
 return sfwrite(io, ubytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ubytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Puint16 PDCI_sbh2uint16(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Puint16 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 2) {
 errno = EDOM;
 return P_MAX_UINT16;
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(resbytes, bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((2 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_uint16_2sbh_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint16 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((2 - num_bytes) * 8);
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(outbuf, ubytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ubytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_uint16_2sbh_io (P_t *pads, Sfio_t *io, Puint16 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((2 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PbigEndian) {
 return sfwrite(io, ubytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ubytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Puint32 PDCI_sbh2uint32(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Puint32 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 4) {
 errno = EDOM;
 return P_MAX_UINT32;
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(resbytes, bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((4 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_uint32_2sbh_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint32 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((4 - num_bytes) * 8);
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(outbuf, ubytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ubytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_uint32_2sbh_io (P_t *pads, Sfio_t *io, Puint32 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((4 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PbigEndian) {
 return sfwrite(io, ubytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ubytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }
Puint64 PDCI_sbh2uint64(P_t *pads, const Pbyte *bytes, Puint32 num_bytes, Pbyte **ptr_out) {
 Pint32 n = num_bytes;
 Puint64 res = 0;
 Pbyte *resbytes = (Pbyte*)(&res);
 (*ptr_out) = (Pbyte*)bytes + n;
 if (n == 0 || n > 8) {
 errno = EDOM;
 return P_MAX_UINT64;
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(resbytes, bytes, n);
 }
 else {
 while (--n >= 0) {
 resbytes[n] = *bytes++;
 }
 }
 errno = 0;
 if (pads->m_endian == PbigEndian){
 res = res >> ((8 - num_bytes) * 8);
 }
 return res;
 }
 ssize_t PDCI_uint64_2sbh_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Puint64 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (num_bytes > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 errno = EDOM;
 return -1;
 }
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((8 - num_bytes) * 8);
 }
 if (pads->m_endian == PbigEndian) {
 memcpy(outbuf, ubytes, num_bytes);
 }
 else {
 while (--n >= 0) {
 outbuf[n] = *ubytes++;
 }
 }
 errno = 0;
 return num_bytes;
 }
 ssize_t PDCI_uint64_2sbh_io (P_t *pads, Sfio_t *io, Puint64 u, Puint32 num_bytes) {
 Pint32 n = num_bytes;
 Pbyte *ubytes = (Pbyte*)(&u);
 if (n == 0 || n > 8) {
 errno = EDOM;
 return -1;
 };
 if (u > P_UMAX_FOR_NB[n]) {
 errno = ERANGE;
 return -1;
 }
 if (pads->m_endian == PbigEndian){
 u <<= ((8 - num_bytes) * 8);
 }
 errno = 0;
 if (pads->m_endian == PbigEndian) {
 return sfwrite(io, ubytes, n);
 }
 {
 Pbyte sb[30];
 while (--n >= 0) {
 sb[n] = *ubytes++;
 }
 return sfwrite(io, sb, num_bytes);
 }
 }

ssize_t PDCI_float32_2a_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pfloat32 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_FLOAT_WRITE(writelen, pads->tmp1, "%I4f", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_float32_2a_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pfloat32 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_FLOAT_WRITE(writelen, pads->tmp1, "%0.*I4f", width, i);
 if (writelen != width) {
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_float32_2a_io(P_t *pads, Sfio_t *io, Pfloat32 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_FMT_FLOAT_WRITE(writelen, io, "%I4f", i);
 return writelen;
 }
 ssize_t PDCI_float32_2a_FW_io(P_t *pads, Sfio_t *io, Pfloat32 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_FLOAT_WRITE(writelen, pads->tmp1, "%0.*I4f", width, i);
 if (writelen != width) {
 return -1;
 }
 return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen);
 }
ssize_t PDCI_float64_2a_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pfloat64 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_FLOAT_WRITE(writelen, pads->tmp1, "%I8f", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_float64_2a_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pfloat64 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_FLOAT_WRITE(writelen, pads->tmp1, "%0.*I8f", width, i);
 if (writelen != width) {
 return -1;
 }
 memcpy(outbuf, PDCI_sfstr_use(pads->tmp1), writelen);
 return writelen;
 }
 ssize_t PDCI_float64_2a_io(P_t *pads, Sfio_t *io, Pfloat64 i) {
 ssize_t writelen;
 errno = 0;
 PDCI_FMT_FLOAT_WRITE(writelen, io, "%I8f", i);
 return writelen;
 }
 ssize_t PDCI_float64_2a_FW_io(P_t *pads, Sfio_t *io, Pfloat64 i, size_t width) {
 ssize_t writelen;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_FLOAT_WRITE(writelen, pads->tmp1, "%0.*I8f", width, i);
 if (writelen != width) {
 return -1;
 }
 return sfwrite(io, PDCI_sfstr_use(pads->tmp1), writelen);
 }

Pfloat32 PDCI_a2float32(const Pbyte *bytes, Pbyte **ptr_out) {
 Pbyte* ptr;
 _ast_fltmax_t d;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 errno = 0;
 d = strtold((const char *)bytes, (char**)&ptr);
 if (ptr >= bytes) {
 (*ptr_out) = ptr;
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 if (ptr == bytes) {
 errno = EINVAL;
 return 0;
 }
 if ((errno == ERANGE && d < 0) || (d < P_MIN_FLOAT32)) {
 errno = ERANGE;
 return P_MIN_FLOAT32;
 }
 if ((errno == ERANGE) || (d > P_MAX_FLOAT32)) {
 errno = ERANGE;
 return P_MAX_FLOAT32;
 }
 return (Pfloat32)d;
 }
 Pfloat32 PDCI_a2float32_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 Pbyte* ptr;
 _ast_fltmax_t d;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 errno = 0;
 d = strtold((const char *)bytes, (char**)&ptr);
 if (ptr >= bytes) {
 (*ptr_out) = ptr;
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 if (ptr == bytes) {
 errno = EINVAL;
 return 0;
 }
 errno = 0;
 return (Pfloat32)d;
 }
 Pfloat32 PDCI_a2float32_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 Pbyte* ptr;
 _ast_fltmax_t d;
 while (max_bytes > 0 && PDCI_is_a_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 errno = 0;
 d = strntold((const char *)bytes, max_bytes, (char**)&ptr);
 if (ptr >= bytes) {
 (*ptr_out) = ptr;
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 if (ptr == bytes) {
 errno = EINVAL;
 return 0;
 }
 if ((errno == ERANGE && d < 0) || (d < P_MIN_FLOAT32)) {
 errno = ERANGE;
 return P_MIN_FLOAT32;
 }
 if ((errno == ERANGE) || (d > P_MAX_FLOAT32)) {
 errno = ERANGE;
 return P_MAX_FLOAT32;
 }
 return (Pfloat32)d;
 }
 Pfloat32 Pstring2float32(const Pstring *s) {
 Pbyte *bytes, *ptr;
 size_t max_bytes;
 Pfloat32 res;
 if (!s) {
 errno = EINVAL;
 return 0;
 }
 ptr = bytes = (Pbyte*)s->str;
 max_bytes = s->len;
 res = PDCI_a2float32_max_bytes(bytes, max_bytes, &ptr);
 if (errno) {
 return res;
 }
 while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) {
 ptr++;
 }
 if (ptr - bytes != max_bytes) {
 errno = EINVAL;
 return 0;
 }
 return res;
 }
Pfloat64 PDCI_a2float64(const Pbyte *bytes, Pbyte **ptr_out) {
 Pbyte* ptr;
 _ast_fltmax_t d;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 errno = 0;
 d = strtold((const char *)bytes, (char**)&ptr);
 if (ptr >= bytes) {
 (*ptr_out) = ptr;
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 if (ptr == bytes) {
 errno = EINVAL;
 return 0;
 }
 if ((errno == ERANGE && d < 0) || (d < P_MIN_FLOAT64)) {
 errno = ERANGE;
 return P_MIN_FLOAT64;
 }
 if ((errno == ERANGE) || (d > P_MAX_FLOAT64)) {
 errno = ERANGE;
 return P_MAX_FLOAT64;
 }
 return (Pfloat64)d;
 }
 Pfloat64 PDCI_a2float64_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 Pbyte* ptr;
 _ast_fltmax_t d;
 while (PDCI_is_a_space(*bytes)) {
 bytes++;
 }
 errno = 0;
 d = strtold((const char *)bytes, (char**)&ptr);
 if (ptr >= bytes) {
 (*ptr_out) = ptr;
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 if (ptr == bytes) {
 errno = EINVAL;
 return 0;
 }
 errno = 0;
 return (Pfloat64)d;
 }
 Pfloat64 PDCI_a2float64_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 Pbyte* ptr;
 _ast_fltmax_t d;
 while (max_bytes > 0 && PDCI_is_a_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 errno = 0;
 d = strntold((const char *)bytes, max_bytes, (char**)&ptr);
 if (ptr >= bytes) {
 (*ptr_out) = ptr;
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 if (ptr == bytes) {
 errno = EINVAL;
 return 0;
 }
 if ((errno == ERANGE && d < 0) || (d < P_MIN_FLOAT64)) {
 errno = ERANGE;
 return P_MIN_FLOAT64;
 }
 if ((errno == ERANGE) || (d > P_MAX_FLOAT64)) {
 errno = ERANGE;
 return P_MAX_FLOAT64;
 }
 return (Pfloat64)d;
 }
 Pfloat64 Pstring2float64(const Pstring *s) {
 Pbyte *bytes, *ptr;
 size_t max_bytes;
 Pfloat64 res;
 if (!s) {
 errno = EINVAL;
 return 0;
 }
 ptr = bytes = (Pbyte*)s->str;
 max_bytes = s->len;
 res = PDCI_a2float64_max_bytes(bytes, max_bytes, &ptr);
 if (errno) {
 return res;
 }
 while (ptr - bytes < max_bytes && PDCI_is_a_space(*ptr)) {
 ptr++;
 }
 if (ptr - bytes != max_bytes) {
 errno = EINVAL;
 return 0;
 }
 return res;
 }

ssize_t PDCI_float32_2e_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pfloat32 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_FLOAT_WRITE(writelen, pads->tmp1, "%I4f", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_float32_2e_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pfloat32 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_FLOAT_WRITE(writelen, pads->tmp1, "%0.*I4f", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_float32_2e_io (P_t *pads, Sfio_t *io, Pfloat32 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_FLOAT_WRITE(writelen, pads->tmp1, "%I4f", i);
 if (-1 == writelen) return -1;
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
 ssize_t PDCI_float32_2e_FW_io (P_t *pads, Sfio_t *io, Pfloat32 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_FLOAT_WRITE(writelen, pads->tmp1, "%0.*I4f", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
ssize_t PDCI_float64_2e_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pfloat64 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_FLOAT_WRITE(writelen, pads->tmp1, "%I8f", i);
 if (writelen <= 0) {
 return -1;
 }
 if (writelen > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_float64_2e_FW_buf (P_t *pads, Pbyte *outbuf, size_t outbuf_len, int *outbuf_full, Pfloat64 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 if (width > outbuf_len) {
 if (outbuf_full) {
 (*outbuf_full) = 1;
 }
 return -1;
 }
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_FLOAT_WRITE(writelen, pads->tmp1, "%0.*I8f", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 outbuf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return writelen;
 }
 ssize_t PDCI_float64_2e_io (P_t *pads, Sfio_t *io, Pfloat64 i) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_FMT_FLOAT_WRITE(writelen, pads->tmp1, "%I8f", i);
 if (-1 == writelen) return -1;
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }
 ssize_t PDCI_float64_2e_FW_io (P_t *pads, Sfio_t *io, Pfloat64 i, size_t width) {
 ssize_t j, writelen;
 char *buf;
 errno = 0;
 PDCI_sfstr_seek2zero(pads->tmp1);
 PDCI_WFMT_FLOAT_WRITE(writelen, pads->tmp1, "%0.*I8f", width, i);
 if (writelen != width) {
 return -1;
 }
 buf = PDCI_sfstr_use(pads->tmp1);
 for (j = 0;
 j < writelen;
 j++) {
 buf[j] = P_mod_ae_tab[(int)(buf[j])];
 }
 return sfwrite(io, buf, writelen);
 }

Pfloat32 PDCI_e2float32(const Pbyte *bytes, Pbyte **ptr_out) {
 Sfio_t *tmpstr;
 char *ascii_bytes, *ascii_ptr;
 _ast_fltmax_t d;
 if (!(tmpstr = sfstropen())) {
 P_FATAL(&Pdefault_disc, "sfstropen failed in " PDCI_MacroArg2String(PDCI_e2float32));
 }
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 while ((*bytes) == P_EBCDIC_PLUS || (*bytes) == P_EBCDIC_MINUS || (*bytes) == P_EBCDIC_DOT || PDCI_is_e_digit(*bytes)) {
 sfputc(tmpstr, P_mod_ea_tab[(int)(*bytes)]);
 bytes++;
 }
 ascii_bytes = PDCI_sfstr_use(tmpstr);
 errno = 0;
 d = strtold((const char *)ascii_bytes, &ascii_ptr);
 if (ascii_ptr >= ascii_bytes) {
 (*ptr_out) = (Pbyte*)bytes + (ascii_ptr - ascii_bytes);
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 sfstrclose(tmpstr);
 if (ascii_ptr == ascii_bytes) {
 errno = EINVAL;
 return 0;
 }
 if ((errno == ERANGE && d < 0) || (d < P_MIN_FLOAT32)) {
 errno = ERANGE;
 return P_MIN_FLOAT32;
 }
 if ((errno == ERANGE) || (d > P_MAX_FLOAT32)) {
 errno = ERANGE;
 return P_MAX_FLOAT32;
 }
 return (Pfloat32)d;
 }
 Pfloat32 PDCI_e2float32_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 Sfio_t *tmpstr;
 char *ascii_bytes, *ascii_ptr;
 _ast_fltmax_t d;
 if (!(tmpstr = sfstropen())) {
 P_FATAL(&Pdefault_disc, "sfstropen failed in " PDCI_MacroArg2String(PDCI_e2float32));
 }
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 while ((*bytes) == P_EBCDIC_PLUS || (*bytes) == P_EBCDIC_MINUS || (*bytes) == P_EBCDIC_DOT || PDCI_is_e_digit(*bytes)) {
 sfputc(tmpstr, P_mod_ea_tab[(int)(*bytes)]);
 bytes++;
 }
 ascii_bytes = PDCI_sfstr_use(tmpstr);
 errno = 0;
 d = strtold((const char *)ascii_bytes, &ascii_ptr);
 if (ascii_ptr >= ascii_bytes) {
 (*ptr_out) = (Pbyte*)bytes + (ascii_ptr - ascii_bytes);
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 sfstrclose(tmpstr);
 if (ascii_ptr == ascii_bytes) {
 errno = EINVAL;
 return 0;
 }
 errno = 0;
 return (Pfloat32)d;
 }
 Pfloat32 PDCI_e2float32_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 Sfio_t *tmpstr;
 char *ascii_bytes, *ascii_ptr;
 _ast_fltmax_t d;
 if (!(tmpstr = sfstropen())) {
 P_FATAL(&Pdefault_disc, "sfstropen failed in " PDCI_MacroArg2String(PDCI_e2float32));
 }
 while (max_bytes > 0 && PDCI_is_e_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 while ((*bytes) == P_EBCDIC_PLUS || (*bytes) == P_EBCDIC_MINUS || (*bytes) == P_EBCDIC_DOT || PDCI_is_e_digit(*bytes)) {
 sfputc(tmpstr, P_mod_ea_tab[(int)(*bytes)]);
 bytes++;
 }
 ascii_bytes = PDCI_sfstr_use(tmpstr);
 errno = 0;
 d = strntold((const char *)ascii_bytes, max_bytes, &ascii_ptr);
 if (ascii_ptr >= ascii_bytes) {
 (*ptr_out) = (Pbyte*)bytes + (ascii_ptr - ascii_bytes);
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 sfstrclose(tmpstr);
 if (ascii_ptr == ascii_bytes) {
 errno = EINVAL;
 return 0;
 }
 if ((errno == ERANGE && d < 0) || (d < P_MIN_FLOAT32)) {
 errno = ERANGE;
 return P_MIN_FLOAT32;
 }
 if ((errno == ERANGE) || (d > P_MAX_FLOAT32)) {
 errno = ERANGE;
 return P_MAX_FLOAT32;
 }
 return (Pfloat32)d;
 }
Pfloat64 PDCI_e2float64(const Pbyte *bytes, Pbyte **ptr_out) {
 Sfio_t *tmpstr;
 char *ascii_bytes, *ascii_ptr;
 _ast_fltmax_t d;
 if (!(tmpstr = sfstropen())) {
 P_FATAL(&Pdefault_disc, "sfstropen failed in " PDCI_MacroArg2String(PDCI_e2float64));
 }
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 while ((*bytes) == P_EBCDIC_PLUS || (*bytes) == P_EBCDIC_MINUS || (*bytes) == P_EBCDIC_DOT || PDCI_is_e_digit(*bytes)) {
 sfputc(tmpstr, P_mod_ea_tab[(int)(*bytes)]);
 bytes++;
 }
 ascii_bytes = PDCI_sfstr_use(tmpstr);
 errno = 0;
 d = strtold((const char *)ascii_bytes, &ascii_ptr);
 if (ascii_ptr >= ascii_bytes) {
 (*ptr_out) = (Pbyte*)bytes + (ascii_ptr - ascii_bytes);
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 sfstrclose(tmpstr);
 if (ascii_ptr == ascii_bytes) {
 errno = EINVAL;
 return 0;
 }
 if ((errno == ERANGE && d < 0) || (d < P_MIN_FLOAT64)) {
 errno = ERANGE;
 return P_MIN_FLOAT64;
 }
 if ((errno == ERANGE) || (d > P_MAX_FLOAT64)) {
 errno = ERANGE;
 return P_MAX_FLOAT64;
 }
 return (Pfloat64)d;
 }
 Pfloat64 PDCI_e2float64_norange(const Pbyte *bytes, Pbyte **ptr_out) {
 Sfio_t *tmpstr;
 char *ascii_bytes, *ascii_ptr;
 _ast_fltmax_t d;
 if (!(tmpstr = sfstropen())) {
 P_FATAL(&Pdefault_disc, "sfstropen failed in " PDCI_MacroArg2String(PDCI_e2float64));
 }
 while (PDCI_is_e_space(*bytes)) {
 bytes++;
 }
 while ((*bytes) == P_EBCDIC_PLUS || (*bytes) == P_EBCDIC_MINUS || (*bytes) == P_EBCDIC_DOT || PDCI_is_e_digit(*bytes)) {
 sfputc(tmpstr, P_mod_ea_tab[(int)(*bytes)]);
 bytes++;
 }
 ascii_bytes = PDCI_sfstr_use(tmpstr);
 errno = 0;
 d = strtold((const char *)ascii_bytes, &ascii_ptr);
 if (ascii_ptr >= ascii_bytes) {
 (*ptr_out) = (Pbyte*)bytes + (ascii_ptr - ascii_bytes);
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 sfstrclose(tmpstr);
 if (ascii_ptr == ascii_bytes) {
 errno = EINVAL;
 return 0;
 }
 errno = 0;
 return (Pfloat64)d;
 }
 Pfloat64 PDCI_e2float64_max_bytes(const Pbyte *bytes, size_t max_bytes, Pbyte **ptr_out) {
 Sfio_t *tmpstr;
 char *ascii_bytes, *ascii_ptr;
 _ast_fltmax_t d;
 if (!(tmpstr = sfstropen())) {
 P_FATAL(&Pdefault_disc, "sfstropen failed in " PDCI_MacroArg2String(PDCI_e2float64));
 }
 while (max_bytes > 0 && PDCI_is_e_space(*bytes)) {
 bytes++;
 max_bytes--;
 }
 if (max_bytes == 0) {
 errno = EINVAL;
 return 0;
 }
 while ((*bytes) == P_EBCDIC_PLUS || (*bytes) == P_EBCDIC_MINUS || (*bytes) == P_EBCDIC_DOT || PDCI_is_e_digit(*bytes)) {
 sfputc(tmpstr, P_mod_ea_tab[(int)(*bytes)]);
 bytes++;
 }
 ascii_bytes = PDCI_sfstr_use(tmpstr);
 errno = 0;
 d = strntold((const char *)ascii_bytes, max_bytes, &ascii_ptr);
 if (ascii_ptr >= ascii_bytes) {
 (*ptr_out) = (Pbyte*)bytes + (ascii_ptr - ascii_bytes);
 }
 else {
 (*ptr_out) = (Pbyte*)bytes;
 }
 sfstrclose(tmpstr);
 if (ascii_ptr == ascii_bytes) {
 errno = EINVAL;
 return 0;
 }
 if ((errno == ERANGE && d < 0) || (d < P_MIN_FLOAT64)) {
 errno = ERANGE;
 return P_MIN_FLOAT64;
 }
 if ((errno == ERANGE) || (d > P_MAX_FLOAT64)) {
 errno = ERANGE;
 return P_MAX_FLOAT64;
 }
 return (Pfloat64)d;
 }
